I"<h1 id="-demain-paging">👀 Demain Paging</h1>
<ul>
  <li>실제로 필요할 때 <code class="language-plaintext highlighter-rouge">page</code>를 메모리에 올리는 것</li>
  <li>왜냐면 프로그램의 대부분의 코드는 (거의 발생하지 않는 치명적인) 오류를 해결하기 위한 코드라 평소에는 쓰지지 않는 부분이 대다수다. 그래서 이걸 다 메모리에 올려 놓으면 메모리 공간만 차지하고 비효율적이다.</li>
  <li>그래서 프로세스 동작에 실제로 필요한 <code class="language-plaintext highlighter-rouge">page</code>만 메모리에 올리는 것이 효율적이다.</li>
  <li>장점
    <ul>
      <li><code class="language-plaintext highlighter-rouge">I/O</code> 양의 감소</li>
      <li>메모리 사용량 감소</li>
      <li>빠른 응답 시간</li>
      <li>더 많은 사용자 수용
<br /><br /></li>
    </ul>
  </li>
  <li>물리적 메모리에 <code class="language-plaintext highlighter-rouge">page</code>가 올려질 <code class="language-plaintext highlighter-rouge">page entry</code>에서 <code class="language-plaintext highlighter-rouge">Valid/Invalid bit</code>를 사용해 현재 메모리에 <code class="language-plaintext highlighter-rouge">page</code>가 올려져 확인한다. 만약 어떤 메모리 주소에 접근했을 때 해당 위치가 <code class="language-plaintext highlighter-rouge">Invalid bit</code>로 세팅되어 있으면 <code class="language-plaintext highlighter-rouge">page fault</code>가 일어났다고 한다.</li>
  <li><code class="language-plaintext highlighter-rouge">page fault</code>가 일어나면 디스크에 직접 접근해서 해당 페이지를 가져와야 하는데 이는 메모리에 접근해서 가져오는 것에 비해 시간이 아주 많이 걸린다.<br /><br /></li>
</ul>

<h1 id="replacement-algorithm">Replacement Algorithm</h1>
<h2 id="page-replacement">Page replacement</h2>
<ul>
  <li>새로운 페이지를 올릴 공간이 없으면 올려져 있는 페이지 중 어떤 것을 쫓아낼 지 결정해야 한다.</li>
  <li>이를 위한 여러 알고리즘이 있는데 대체로 <code class="language-plaintext highlighter-rouge">page fault</code>를 최소화하기 위해 곧바로 사용되지 않을 페이지를 쫓아내는 형태로 구현되어 있다.</li>
</ul>

<h2 id="optimal-algorithm">Optimal Algorithm</h2>
<ul>
  <li>가장 먼 미래에 사용될(당장 사용되지 않을) 페이지를 쫓아내는 알고리즘</li>
  <li>미래에 참조될 페이지를 미리 예측할 수 있다는 가정하에 사용할 수 있는 알고리즘이다. 하지만 미래를 아는 것은 불가능하기 때문에 실제 시스템에 사용은 불가능하다.</li>
</ul>

<h2 id="fifo-first-in-first-out-algorithm">FIFO (First In First Out) Algorithm</h2>
<ul>
  <li>먼저 들어온 것을 먼저 내쫓는 알고리즘</li>
  <li>실제 시스템에 사용되는 알고리즘이다.</li>
  <li>먼저 들어온 것을 내쫓는 과정에서 페이지 프레임 크기를 늘렸는데 오히려 <code class="language-plaintext highlighter-rouge">page fault</code>가 늘어나 성능이 하락하는 경우가 생길 수 있다.</li>
</ul>

<h2 id="lru-least-recently-used-algorithm">LRU (Least Recently Used) Algorithm</h2>
<ul>
  <li>가장 오래 전에 참조된 것을 지우는 알고리즘</li>
  <li>실제 시스템에서 많이 사용된다.</li>
  <li>어떤 페이지가 참조되면 그것의 순서를 맨 앞으로 바꿔주기만 하면 되기 때문에 링크드 리스트(Linked list) 형태로 구현한다. 시간복잡도는 <code class="language-plaintext highlighter-rouge">O(1)</code></li>
</ul>

<h2 id="lfu-least-frequently-used-algorithm">LFU (Least Frequently Used) Algorithm</h2>
<ul>
  <li>참조 횟수(reference count)가 가장 적은 페이지를 지우는 알고리즘
    <ul>
      <li>최저 참조 횟수 페이지가 여러 개 있는 경우
        <ul>
          <li>내쫓을 페이지를 임의로 선정한다.</li>
          <li>성능 향상을 위해 가장 오래 전에 참조된 페이지를 지우게 구현할 수도 있다.</li>
        </ul>
      </li>
      <li>장단점
        <ul>
          <li>LRU처럼 직전 참조 시점만 보는 것이 아니라 장기적인 시간 규모를 보기 때문에 페이지의 인기도를 좀 더 정확히 반영할 수 있다.</li>
          <li>참조 시점의 최근성을 반영하지 못 한다.(만약 1초 전에 처음으로 참조 되었다면 인기도가 낮은 것으로 간주하고 내쫓게 된다)</li>
          <li>LRU보다 구현이 복잡하다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>어떤 페이지가 참조되면 이전에 참조된 페이지들의 참조 횟수와 하나씩 비교해서 순서를 정해줘야 한다. 그래서 LRU처럼 링크드 리스트 형태로 구현하면 순서를 재설정 하는 데 너무 오래 걸린다. 그래서 최소힙(Min heap) 형태로 구현한다. 참조 횟수가 가장 적은 페이지가 힙의 최상단에 있는 것이다. 시간복잡도는 <code class="language-plaintext highlighter-rouge">O(log n)</code><br /><br /></li>
</ul>

<h1 id="캐슁-기법">캐슁 기법</h1>
<ul>
  <li>한정된 빠른 공간(=캐쉬)에 요청된 데이터를 저장해 두었다가 후속 요청시 캐쉬로부터 직접 서비스하는 방식</li>
  <li><code class="language-plaintext highlighter-rouge">paging system</code> 외에도 <code class="language-plaintext highlighter-rouge">cache memory</code>, <code class="language-plaintext highlighter-rouge">buffer caching</code>, <code class="language-plaintext highlighter-rouge">Web caching</code> 등 다양한 분야에서 사용된다.</li>
  <li>그런데 <code class="language-plaintext highlighter-rouge">paging system</code>에서는 <code class="language-plaintext highlighter-rouge">page fault</code>가 생겨서 디스크에서 페이지를 가져와야 할 때에만 <code class="language-plaintext highlighter-rouge">OS</code>가 관여하고 페이지가 메모리에 있어서 디스크까지 갈 필요가 없을 때엔 <code class="language-plaintext highlighter-rouge">OS</code>가 관여하지 않는다. 그래서 <code class="language-plaintext highlighter-rouge">OS</code>는 페이지의 메모리 입장 시간 정도만 알고 있지 메모리에 올라간 이후의 참조 시간과 빈도 같은 것을 알 수 없다. 그래서 사실 위에서 설명했던 LRU와 LFU 같은 알고리즘들은 <code class="language-plaintext highlighter-rouge">OS</code>의 <code class="language-plaintext highlighter-rouge">paging system</code>에서는 사용할 수 없다.</li>
</ul>

<h2 id="clock-algorithm">Clock Algorithm</h2>
<ul>
  <li>그 대신 비슷한 효과를 낼 수 있는 <code class="language-plaintext highlighter-rouge">Clock Algorithm</code>을 사용한다.</li>
  <li></li>
</ul>

<h1 id="출처">출처</h1>
<ul>
  <li><a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323">운영체제 - 이화여자대학교 KOCW 공개강의</a></li>
</ul>
:ET