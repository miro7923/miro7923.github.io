I"<h1 id="-논리적-주소와-물리적-주소">👀 논리적 주소와 물리적 주소</h1>
<ul>
  <li>
    <p>데이터가 메모리에 위치하고 있는 곳을 가리키는 주소는 논리적 주소와 물리적 주소로 나뉜다.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Logical address (= virtual address)</code>
    <ul>
      <li>프로세스마다 독립적으로 가지는 주소 공간</li>
      <li>각 프로세스마다 0번지부터 시작</li>
      <li><code class="language-plaintext highlighter-rouge">CPU</code>가 보는 주소는 <code class="language-plaintext highlighter-rouge">logical address</code>임</li>
      <li>왜냐면 코드상의 주소가 <code class="language-plaintext highlighter-rouge">logical address</code>인데 이게 물리적 주소로 바뀐다 해서 코드상의 주소도 물리적 주소로 바뀌는 것은 아니다. 만약 바뀐다면 컴파일을 새로 해야 하는데 이러면 이상하다. 그래서 <code class="language-plaintext highlighter-rouge">CPU</code>는 논리적 주소를 참고하게 된다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Physical address</code>
    <ul>
      <li>메모리에 실제로 올라가는 위치</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">CPU</code>가 <code class="language-plaintext highlighter-rouge">instruction</code>을 수행하다가 메모리에 있는 데이터에 접근할 필요가 있으면 그 데이터가 위치하고 있는 주소를 알아야 한다.</li>
  <li>이때 코드에 물리적 주소가 항상 명시되어 있어서 바로 그 위치로 가서 읽어오면 서로 편하겠지만 프로그램이 실행되는 컴퓨터와 환경에 따라 항상 같은 물리적 주소를 사용할 수 있다는 보장이 없다.</li>
  <li>그래서 코드에는 논리적 주소를 사용해 각 프로세스별로 전용 주소공간을 사용할 수 있게 하고 그 논리적 주소를 이용해 메모리에 실제로 올려져 있는 위치를 참고할 수 있도록 하는 것이다.</li>
  <li><code class="language-plaintext highlighter-rouge">CPU</code>는 메모리에 접근할 필요가 있으면 먼저 논리적 주소를 물리적 주소로 변환한 뒤 해당 위치에 접근해서 데이터를 읽어온다.</li>
</ul>

<h2 id="주소-바인딩address-binding">주소 바인딩(Address Binding)</h2>
<ul>
  <li>논리적 주소를 물리적 주소로 변환하는 것</li>
  <li>하지만 주소변환은 <code class="language-plaintext highlighter-rouge">CPU</code>가 하는 것이 아닌 하드웨어적으로 이루어진다.</li>
  <li>주소변환이 필요할 때마다 <code class="language-plaintext highlighter-rouge">CPU</code>가 필요하면 그 때마다 <code class="language-plaintext highlighter-rouge">interrupt</code>가 일어나게 될 것이고 그건 굉장히 비효율적일 것이다.</li>
</ul>

<h3 id="주소-바인딩-시점에-따른-분류">주소 바인딩 시점에 따른 분류</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Compile time binding</code>
    <ul>
      <li>컴파일될 때 물리적 주소가 결정된다.</li>
      <li>시작위치가 변경되면 재컴파일</li>
      <li>컴파일러는 절대 코드(absolute code) 생성</li>
      <li>옛날에 많이 쓰다가 지금은 잘 안 쓴다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Load time binding</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Loader</code>의 책임하에 물리적 메모리 주소 부여</li>
      <li>프로그램이 메모리에 로드될 때 물리적 주소가 결정된다.</li>
      <li>컴파일러가 재배치 가능 코드(relocatable code)를 생성한 경우 가능</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Execution time binding (= Run time binding)</code>
    <ul>
      <li>수행이 시작된 이후에도 프로세스의 메모리 상 위치를 옮길 수 있다.</li>
      <li><code class="language-plaintext highlighter-rouge">CPU</code>가 주소를 참조할 때마다 <code class="language-plaintext highlighter-rouge">binding</code> 점검 (address mapping table)</li>
      <li>하드웨어에서 지원해야 가능하다.</li>
      <li>최근 시스템에서 사용하는 방식</li>
    </ul>
  </li>
</ul>

<h2 id="memory-management-unit-mmu">Memory-Management Unit (MMU)</h2>
<ul>
  <li>주소 변환을 위한 하드웨어</li>
  <li>논리적 주소를 물리적 주소로 매핑해 준다.</li>
  <li>실제 물리적 주소의 시작점에서 논리적 주소의 <code class="language-plaintext highlighter-rouge">offset</code>만큼을 더해서 물리적 주소를 알려준다.</li>
  <li><code class="language-plaintext highlighter-rouge">Limit register</code> : 만약 프로세스가 자기 범위를 넘어가는 위치에 있는 데이터에 접근을 요구하면 다른 프로세스의 중요 데이터에 접근하게 될 수 있다. 그래서 주소를 변환할 때 프로세스가 가질 수 있는 주소의 최대 크기를 먼저 제한해놓고 그 범위 안에서만 변환할 수 있도록 한다.<br /><br /></li>
</ul>

<h1 id="주소-변환-기술들">주소 변환 기술들</h1>

<h1 id="출처">출처</h1>
<ul>
  <li><a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323">운영체제 - 이화여자대학교 KOCW 공개강의</a></li>
</ul>
:ET