I"<ul>
  <li>최근 미뤄뒀던 정보처리기사 실기를 준비하며… 꼭 외워야 하는 내용 정리<br /><br /></li>
</ul>

<h1 id="결합도coupling">결합도(Coupling)</h1>
<ul>
  <li>모듈과 모듈 사이의 관련성이 어느 정도인가를 나타내며, 관련성이 적을수록 모듈의 독립성이 높아 모듈 간 영향이 작아진다. 자료 결합도가 제일 낮고 내용 결합도가 가장 높다.</li>
  <li>자료 결합도의 품질이 가장 높고 내용 결합도의 품질이 가장 낮다.</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">자스제외공내</code></p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">자료 결합도(Data Coupling)</code> : 모듈 간의 인터페이스로 전달되는 파라미터를 통해서만 모듈 상호 작용이 일어난다.</li>
  <li><code class="language-plaintext highlighter-rouge">스탬프 결합도(Stamp Coupling)</code> : 모듈 간의 인터페이스로 배열이나 오브젝트, 스트럭처 등이 전달되는 경우</li>
  <li><code class="language-plaintext highlighter-rouge">제어 결합도(Control Coupling)</code> : 단순 처리할 대상인 값만 전달하는 것이 아니라 어떻게 처리해야 한다는 제어요소가 전달되는 경우</li>
  <li><code class="language-plaintext highlighter-rouge">외부 결합도(External Coupling)</code> : 모듈에서 외부로 선언한 데이터(변수)를 다른 모듈에서 참조할 때의 경우로 외부에서 도입된 데이터 포맷, 통신 프로토콜, 또는 디바이스 인터페이스를 공유할 때 주로 발생</li>
  <li><code class="language-plaintext highlighter-rouge">공통 결합도(Common Coupling)</code> : 파라미터가 아닌 모듈 밖에 선언되어 있는 전역변수를 참조하고 전역변수를 갱신하는 식으로 상호 작용하는 경우</li>
  <li><code class="language-plaintext highlighter-rouge">내용 결합도(Content Coupling)</code> : 다른 모듈 내부에 있는 변수나 기능을 또 다른 모듈에서 사용하는 경우<br /><br /></li>
</ul>

<h1 id="응집도cohension">응집도(Cohension)</h1>
<ul>
  <li>모듈 내부의 구성요소 간 관계의 밀접 정도로 평가되며, 응집도가 높을수록 필요한 요소들로 구성되고 낮을수록 요소들 간의 관련성이 적은 요소들로 구성된다.</li>
  <li>기능적 응집도의 품질이 가장 높고 우연적 응집도의 품질이 가장 낮다.</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">기순통절시논우</code></p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">기능적 응집도(Functional Cohension)</code> : 모듈 내부의 모든 기능이 단일한 목적을 위해 수행된다.</li>
  <li><code class="language-plaintext highlighter-rouge">순차적 응집도(Sequential Cohension)</code> : 모듈 내에서 한 활동으로부터 나온 출력값을 다른 활동이 사용하는 경우</li>
  <li><code class="language-plaintext highlighter-rouge">통신적 응집도(Communication Cohension)</code> : 동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여 있을 경우</li>
  <li><code class="language-plaintext highlighter-rouge">절차적 응집도(Procedural Cohension)</code> : 모듈이 다수의 관련 기능을 가질 때, 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행하는 경우</li>
  <li><code class="language-plaintext highlighter-rouge">시간적 응집도(Temporal Cohension)</code> : 연관된 기능이라기보다는 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리하는 경우</li>
  <li><code class="language-plaintext highlighter-rouge">논리적 응집도(Logical Cohension)</code> : 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우</li>
  <li><code class="language-plaintext highlighter-rouge">우연적 응집도(Coincidential Cohension)</code> : 모듈 내부의 각 구성 요소들이 연관이 없는 경우<br /><br /></li>
</ul>

<h1 id="소프트웨어-아키텍처-패턴">소프트웨어 아키텍처 패턴</h1>
<ul>
  <li>소프트웨어 설계 시 참조 가능한 솔루션</li>
  <li>일반적으로 발생하는 문제점들에 대해 일반화되고 재사용 가능한 솔루션<br /><br /></li>
</ul>

<h1 id="요구공학">요구공학</h1>
<ul>
  <li>요구사항을 도출, 분석, 명세, 확인하는 구조화된 활동<br /><br /></li>
</ul>

<h2 id="요구사항-분석-기법">요구사항 분석 기법</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">자료 흐름 지향 분석</code> : 데이터 흐름도(DFD)와 자료 사전(DD)을 통해 분석</li>
  <li><code class="language-plaintext highlighter-rouge">객체지향 분석</code> : 시스템 기능과 데이터를 함께 분석해 UML로 표준화</li>
</ul>

<h2 id="요구공학-프로세스">요구공학 프로세스</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">개발 단계(CMM Level 3)</code> : 요구사항 분석</li>
  <li><code class="language-plaintext highlighter-rouge">관리 단계 (CMM Levle 2)</code> : 설계 - 개발 - 테스트를 거치는 동안 요구사항 잘 만족하는지 확인</li>
</ol>

<h2 id="요구공학-개발-단계-구성-cmm-level-3">요구공학 개발 단계 구성 (CMM Level 3)</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">도출</code> : 이해관계자 식별, 고객 분석</li>
  <li><code class="language-plaintext highlighter-rouge">분석</code> : 분류 -&gt; 개념 모델링 생성 -&gt; 할당 -&gt; 협상 -&gt; 분석</li>
  <li><code class="language-plaintext highlighter-rouge">명세</code> : 정형화된 형태로 명세 작성</li>
  <li><code class="language-plaintext highlighter-rouge">확인</code> : 요구사항 이해를 확인하고 문서가 완전한지 검증</li>
</ol>

<h2 id="요구사항-도출-기법">요구사항 도출 기법</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">인터뷰</code> : 직접 대화</li>
  <li><code class="language-plaintext highlighter-rouge">브레인스토밍</code> : 말하기 쉬운 분위기 속에서 비판없이 의견을 수용</li>
  <li><code class="language-plaintext highlighter-rouge">델파이 기법</code> : 전문가 경험 활용</li>
  <li><code class="language-plaintext highlighter-rouge">롤 플레잉</code> : 각자 맡은 역을 연기</li>
  <li><code class="language-plaintext highlighter-rouge">워크숍</code> : 단기간 집중하여 정보 획득 후 공유(사전 준비 필요)</li>
  <li><code class="language-plaintext highlighter-rouge">설문 조사</code></li>
</ul>

<h2 id="요구사항-분석-단계">요구사항 분석 단계</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">요구사항 분류</code> : 기능적 요구사항 (시스템이 제공해야 할 기능) vs 비기능적 요구사항(시스템이 준수해야 할 제약사항)</li>
  <li><code class="language-plaintext highlighter-rouge">개념 모델링 생성</code> : 주로 UML 사용. 요구사항을 쉽게 이해할 수 있도록 개념적 표현</li>
  <li><code class="language-plaintext highlighter-rouge">요구사항 할당</code> : 요구사항 만족을 위한 아키텍처 구성요소 식별</li>
  <li><code class="language-plaintext highlighter-rouge">요구사항 협상</code> : 충돌되는 경우 합의, 우선순위 부여</li>
  <li><code class="language-plaintext highlighter-rouge">정형 분석</code> : 정형화된 언어를 통해 수학적 기호로 표현</li>
</ol>

<h2 id="요구사항-명세-기법">요구사항 명세 기법</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">비정형 명세 기법</code> : 자연어 기반 서술</li>
  <li><code class="language-plaintext highlighter-rouge">정형 명세 기법</code> : 수학적 표기법으로 서술</li>
</ol>

<h2 id="요구사항-명세-원리-및-검증-항목">요구사항 명세 원리 및 검증 항목</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">명확성</code> : 각 명세 내용은 하나의 의미만 부여</li>
  <li><code class="language-plaintext highlighter-rouge">완전성</code> : 모든 요구사항이 포함되어야 함</li>
  <li><code class="language-plaintext highlighter-rouge">검증 가능성</code> : 달성 정도를 확인할 수 있어야 함</li>
  <li><code class="language-plaintext highlighter-rouge">일관성</code> : 모순이 없어야 함</li>
  <li><code class="language-plaintext highlighter-rouge">수정 용이성</code> : 쉽게 수정할 수 있어야 함</li>
  <li><code class="language-plaintext highlighter-rouge">개발 후 이용성</code> : 운영 및 유지보수에 이용이 가능해야 함</li>
  <li><code class="language-plaintext highlighter-rouge">추적 가능성</code> : 추적이 가능해야 함</li>
</ol>

<h2 id="요구사항-확인-기법">요구사항 확인 기법</h2>
<ol>
  <li>정형 기술 검토(TCR)</li>
  <li>프로토타이핑 활용</li>
  <li>테스트 케이스를 통한 확인</li>
  <li>CASE 도구 활용</li>
  <li>베이스라인 검증</li>
  <li>요구사항 추적표 (RTM : Requirement Tracebility Matrix) 통해 검증
    <ul>
      <li>요구사항 정의서 기준으로 개발단계별 최종 산출물이 어떻게 변경되었는지 확인 가능한 문서</li>
    </ul>
  </li>
</ol>

<h2 id="정형-기술-검토-tcr-기법">정형 기술 검토 (TCR) 기법</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">동료 검토 (Peer Review)</code> : 작성자가 설명하고, 이해 관계자들이 설명을 들으며 결함 발견</li>
  <li><code class="language-plaintext highlighter-rouge">워크 스루 (Walk Through)</code> : 검토 자료 사전 배포 후, 짧은 시간 동안 회의 진행</li>
  <li><code class="language-plaintext highlighter-rouge">인스펙션 (Inspection)</code> : 저작자가 아닌 다른 전문가가 검토</li>
  <li>참가자 구성
    <ul>
      <li><code class="language-plaintext highlighter-rouge">주재자(Moderator)</code> : 참가자를 선정하고 계획 및 주재</li>
      <li><code class="language-plaintext highlighter-rouge">작성자</code></li>
      <li><code class="language-plaintext highlighter-rouge">낭독자</code></li>
      <li><code class="language-plaintext highlighter-rouge">기록자</code></li>
      <li><code class="language-plaintext highlighter-rouge">검토자</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">관리 리뷰 (Management Review)</code> : 프로젝트 진행 상황을 전반적으로 검토</li>
  <li><code class="language-plaintext highlighter-rouge">기술 리뷰 (Technical Review)</code> : 명세를 준수하고 있는지 검토</li>
  <li><code class="language-plaintext highlighter-rouge">감사 (Audit)</code> : 제품이 표준이나 가이드라인을 준수하는지 검토. 제품 제공자, 소비자, 제 3기관이 수행</li>
</ul>

<h2 id="요구공학-관리-단계-구성cmm-level-2">요구공학 관리 단계 구성(CMM Level 2)</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">협상</code> : 구현 가능한 기능 협상</li>
  <li><code class="language-plaintext highlighter-rouge">기준선 설정</code> : 기준선(베이스라인) 설정
    <ul>
      <li><code class="language-plaintext highlighter-rouge">베이스라인</code> : 개발 과정의 산출물의 변화를 통제하는 시점</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">변경관리</code> : 형상통제 위원회를 운영하여 변경 관리
    <ul>
      <li><code class="language-plaintext highlighter-rouge">CCB</code> : 형상 관리의 방침을 정하고 산출물을 검토하는 조직</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">확인 및 검증</code> : 요구사항에 부합하는지 확인<br /><br /></li>
</ol>

<h1 id="미들웨어">미들웨어</h1>
<ul>
  <li>컴퓨터와 컴퓨터 간 연결 및 연결 관리를 돕는 소프트웨어</li>
  <li>Weblogic, Jeus, Tomcat 등<br /><br /></li>
</ul>

<h1 id="네트워크">네트워크</h1>
<ul>
  <li>원하는 정보를 수신자에게 정확하게 전달하기 위한 인프라<br /><br /></li>
</ul>

<h1 id="osi-7계층">OSI 7계층</h1>
<ul>
  <li>네트워크 통신에서 충돌 문제를 최소화하고자, 국제표준화기구(ISO)에서 제시한 네트워크 통신 규약</li>
  <li><code class="language-plaintext highlighter-rouge">물데네트세표응</code>!</li>
</ul>

<h2 id="물리-계층">물리 계층</h2>
<ul>
  <li>데이터를 전기적인 신호로 변환시켜 통신
    <ol>
      <li><code class="language-plaintext highlighter-rouge">단위</code> : 비트</li>
      <li><code class="language-plaintext highlighter-rouge">프로토콜</code> : RS-232C</li>
      <li><code class="language-plaintext highlighter-rouge">장비</code> : 허브, 리피터</li>
    </ol>
  </li>
</ul>

<h3 id="물리-계층-장비">물리 계층 장비</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">허브</code> : 여러 대의 컴퓨터를 연결해 네트워크로 보내거나, 하나의 네트워크로 수신된 정보를 여러 대의 컴퓨터로 보내는 장비</li>
  <li><code class="language-plaintext highlighter-rouge">리피터</code> : 디지털 신호를 증폭시키는 장비<br /><br /></li>
</ul>

<h2 id="데이터링크-계층">데이터링크 계층</h2>
<ul>
  <li>노드 간 오류 제어, 흐름 제어, 회선 제어
    <ol>
      <li><code class="language-plaintext highlighter-rouge">단위</code> : 프레임</li>
      <li><code class="language-plaintext highlighter-rouge">장비</code> : L2 스위치, 브릿지, NIC, 스위칭 허브</li>
      <li><code class="language-plaintext highlighter-rouge">프로토콜</code> : HDLC, PPP, Frame Relay, ATM</li>
    </ol>
  </li>
</ul>

<h3 id="데이터링크-계층-장비">데이터링크 계층 장비</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">L2 스위치</code> : 목적지 MAC 주소를 기반으로 빠르게 데이터를 전송하는 장비
    <ol>
      <li><code class="language-plaintext highlighter-rouge">Store and Forwarding</code> : 데이터를 전부 받은 후 처리</li>
      <li><code class="language-plaintext highlighter-rouge">Cut Through</code> : 목적지 주소만 확인 후 바로 전송</li>
      <li><code class="language-plaintext highlighter-rouge">Fragment Frame</code> : 앞 64비트만 읽어 에러 처리 후 전송</li>
    </ol>
  </li>
  <li><code class="language-plaintext highlighter-rouge">브릿지</code> : LAN과 LAN을 연결하는 장비</li>
  <li><code class="language-plaintext highlighter-rouge">NIC</code> : 네트워크 인터페이스 카드. 외부 네트워크와 빠른 통신을 위해 컴퓨터 내에 설치되는 장비</li>
  <li><code class="language-plaintext highlighter-rouge">스위칭 허브</code> : 스위치 기능을 가진 허브</li>
</ul>

<h3 id="데이터링크-계층-프로토콜">데이터링크 계층 프로토콜</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">HDLC</code> : 점대점, 다중점 통신에 사용하는 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">PPP</code> : 통신 노드 간 연결을 위한 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">Frame Relay</code> : 프레임 간 중계기능, 다중화 기능을 통해 빠른 데이터 전송이 가능한 고속 전송 기술</li>
  <li><code class="language-plaintext highlighter-rouge">ATM</code> : 고정 크기 단위로 전송하는 비동기식 전송 기술<br /><br /></li>
</ul>

<h2 id="네트워크-계층">네트워크 계층</h2>
<ul>
  <li>데이터 전송을 위한 최적의 경로 설정
    <ol>
      <li><code class="language-plaintext highlighter-rouge">단위</code> : 패킷</li>
      <li><code class="language-plaintext highlighter-rouge">장비</code> : L3 스위치, 라우터, 게이트웨이, 인터넷 공유기, 망(백본) 스위칭 허브</li>
      <li><code class="language-plaintext highlighter-rouge">프로토콜</code> : IP, 라우팅 프로토콜, ARP, RARP, ICMP, IGMP</li>
    </ol>
  </li>
</ul>

<h3 id="네트워크-계층-장비">네트워크 계층 장비</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">L3 스위치</code> : 3계층에서 동작하는 스위치 (L2 스위치 기능 + L3 라우터 기능을 모두 갖춘 장비)</li>
  <li><code class="language-plaintext highlighter-rouge">라우터</code> : 최적의 경로를 지정하고 경로에 따라 전송시키는 장비</li>
  <li><code class="language-plaintext highlighter-rouge">게이트웨이</code> : 다른 통신망에 접속할 수 있게 해주는 장비</li>
  <li><code class="language-plaintext highlighter-rouge">인터넷 공유기</code> : 하나의 인터넷 라인을 여러 컴퓨터가 공유할 수 있게 해주는 장비</li>
  <li><code class="language-plaintext highlighter-rouge">망(백본) 스위칭 허브</code> : 광역 네트워크를 커버하는 스위칭 허브</li>
</ul>

<h3 id="네트워크-계층-프로토콜">네트워크 계층 프로토콜</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">IP</code> : 패킷 단위의 네트워크 통신 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">라우팅 프로토콜</code> : 최적의 데이터 전송 경로를 설정하는 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">ARP</code> : IP주소(3계층)를 MAC 주소(2계층)으로 변환하는 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">RARP</code> : MAC 주소는 알지만 IP 주소를 모를 때 사용하는 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">ICMP</code> : IP 패킷 처리 시의 문제를 알려주는 프로토콜, 신뢰성없는 IP를 대신하여 송신측으로 네트워크의 IP 상태 및 에러 메시지를 전달해주는 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">IGMP</code> : 멀티캐스트 실시간 전송을 위해 사용하는 프로토콜(화상회의 등)</li>
  <li><code class="language-plaintext highlighter-rouge">IPSec</code> : 네트워크 계층에서 사용하는 보안 프로토콜. 인증 헤더 + 암호화를 이용. MAC + 암호화를 통해 인증 + 기밀성 제공<br /><br /></li>
</ul>

<h2 id="전송계층transport">전송계층(Transport)</h2>
<ul>
  <li>종단 간 신뢰성있고 효율적으로 데이터 전송
    <ol>
      <li><code class="language-plaintext highlighter-rouge">단위</code> : 세그먼트</li>
      <li><code class="language-plaintext highlighter-rouge">장비</code> : L4 스위치</li>
      <li><code class="language-plaintext highlighter-rouge">프로토콜</code> : TCP, UDP</li>
    </ol>
  </li>
</ul>

<h3 id="전송계층-장비">전송계층 장비</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">L4 스위치</code> : OSI 4계층에서 네트워크 단위를 연결하는 장비. TCP/UDP 등 스위칭 수행</li>
</ul>

<h3 id="전송계층-프로토콜">전송계층 프로토콜</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">TCP</code>
    <ol>
      <li><code class="language-plaintext highlighter-rouge">신뢰성 보장</code> : 패킷 손실, 중복이 없도록 보장 (IP 계층 보완)</li>
      <li><code class="language-plaintext highlighter-rouge">연결지향적</code> : 연결 회선을 통해 통신이 이뤄짐</li>
      <li><code class="language-plaintext highlighter-rouge">흐름제어</code> : 송신-수신 속도 일치시킴</li>
      <li><code class="language-plaintext highlighter-rouge">혼잡제어</code> : 네트워크 혼잡도에 따라 송신율 제어</li>
    </ol>
  </li>
  <li><code class="language-plaintext highlighter-rouge">TCP 헤더 구조</code>
    <ol>
      <li><code class="language-plaintext highlighter-rouge">Source Port Number</code></li>
      <li><code class="language-plaintext highlighter-rouge">Destination Port Number</code></li>
      <li><code class="language-plaintext highlighter-rouge">Sequence Number</code> : 신뢰성과 흐름 담당</li>
      <li><code class="language-plaintext highlighter-rouge">Acknowledgement Number</code> : 승인 번호(수신을 기대하는 다음 번호)</li>
      <li><code class="language-plaintext highlighter-rouge">HLEN</code> : 헤더 길이</li>
      <li><code class="language-plaintext highlighter-rouge">Flag Bit</code> : 값 유효 여부 등을 표시하는 플래그</li>
      <li><code class="language-plaintext highlighter-rouge">Window Size</code></li>
      <li><code class="language-plaintext highlighter-rouge">Checksum</code> : 에러 확인</li>
      <li><code class="language-plaintext highlighter-rouge">Urgent Pointer</code> : 시퀀스 번호로부터의 옵셋</li>
      <li><code class="language-plaintext highlighter-rouge">Options and Padding</code></li>
    </ol>
  </li>
  <li><code class="language-plaintext highlighter-rouge">UDP</code>
    <ol>
      <li><code class="language-plaintext highlighter-rouge">비신뢰성</code> : 메시지의 도착을 보장하지 않음</li>
      <li><code class="language-plaintext highlighter-rouge">비순서화</code> : 수신된 메시지 순서 맞추지 않음</li>
      <li>실시간 응용 및 멀티캐스팅 가능</li>
      <li>단순 헤더 (고정 크기 헤더)</li>
    </ol>
  </li>
  <li><code class="language-plaintext highlighter-rouge">UDP 헤더 구조</code>
    <ol>
      <li><code class="language-plaintext highlighter-rouge">Source Port Number</code></li>
      <li><code class="language-plaintext highlighter-rouge">Destination Port Number</code></li>
      <li><code class="language-plaintext highlighter-rouge">UDP Length</code></li>
      <li><code class="language-plaintext highlighter-rouge">UDP Checksum</code></li>
      <li><code class="language-plaintext highlighter-rouge">Data</code><br /><br /></li>
    </ol>
  </li>
</ul>

<h2 id="세션계층-session">세션계층 (Session)</h2>
<ul>
  <li>송수신간(단말기 사이) 연결을 제어
    <ol>
      <li><code class="language-plaintext highlighter-rouge">단위</code> : 데이터</li>
      <li><code class="language-plaintext highlighter-rouge">프로토콜</code> : RPC, NetBIOS, SSH, SSL/TLS</li>
    </ol>
  </li>
</ul>

<h3 id="세션계층-프로토콜">세션계층 프로토콜</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">RPC</code> : 원격 프로시저 호출. 다른 주소 공간에 있는 프로세스 실행 가능</li>
  <li><code class="language-plaintext highlighter-rouge">NetBIOS</code> : 응용계층의 애플리케이션에 API 제공</li>
  <li><code class="language-plaintext highlighter-rouge">SSH</code> : 보안 쉘. 원격 호스트에 접근하기 위한 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">SSL/TLS</code> : 안전한 데이터 전송을 위한 보안 프로토콜 (4계층(응용) - 7계층(전송) 사이에서 안전한 데이터 전송을 보장)<br /><br /></li>
</ul>

<h2 id="표현계층-presentaion">표현계층 (Presentaion)</h2>
<ul>
  <li>응용프로그램의 데이터를 통신에 알맞은 형태로 만들거나, 하위 계층의 데이터를 사용자가 이해할 수 있는 형태로 만드는 계층
    <ol>
      <li><code class="language-plaintext highlighter-rouge">단위</code> : 데이터</li>
      <li><code class="language-plaintext highlighter-rouge">프로토콜</code> : JPEG, MPEG</li>
    </ol>
  </li>
</ul>

<h3 id="표현계층-프로토콜">표현계층 프로토콜</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">JPEG</code> : 이미지를 위한 표준 규격</li>
  <li><code class="language-plaintext highlighter-rouge">MPEG</code> : 멀티미디어를 위한 표준 규격<br /><br /></li>
</ul>

<h2 id="응용계층-application">응용계층 (Application)</h2>
<ul>
  <li>사용자가 OSI 환경에 접근할 수 있도록 서비스(인터페이스)를 제공하는 계층
    <ol>
      <li><code class="language-plaintext highlighter-rouge">단위</code> : 데이터</li>
      <li><code class="language-plaintext highlighter-rouge">프로토콜</code> : HTTP, FTP, SMTP, POP3, IMAP, Telnet</li>
    </ol>
  </li>
</ul>

<h3 id="응용계층-프로토콜">응용계층 프로토콜</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">HTTP</code> : 인터넷에서 데이터를 주고받기 위한 텍스트 기반의 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">FTP</code> : 서버-클라이언트 간 파일 전송을 위한 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">SMTP</code> : 이메일을 보내기 위한 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">POP3</code> : 이메일을 가져오기 위한 프로토콜 (로컬 PC에 저장 후 불러옴)</li>
  <li><code class="language-plaintext highlighter-rouge">IMAP</code> : 이메일을 가져오기 위한 프로토콜 (메일 서버에서 불러옴)</li>
  <li><code class="language-plaintext highlighter-rouge">Telnet</code> : 네트워크 연결에 사용하는 응용계층의 프로토콜<br /><br /></li>
</ul>

<h1 id="디자인-패턴">디자인 패턴</h1>
<ul>
  <li>소프트웨어 설계 시 자주 쓰이는 방법을 정리한 패턴으로, 참고 시 개발 효율성이 높아진다.</li>
</ul>

<h2 id="디자인-패턴-구성요소">디자인 패턴 구성요소</h2>
<ol>
  <li>패턴 이름</li>
  <li>문제 및 배경</li>
  <li>솔루션</li>
  <li>사례</li>
  <li>결과</li>
  <li>샘플코드</li>
</ol>

<h2 id="디자인-패턴-유형">디자인 패턴 유형</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">생성(5)</code> : 객체의 생성방식을 결정하는 패턴</li>
  <li><code class="language-plaintext highlighter-rouge">구조(7)</code> : 객체를 조직화하는데 유용한 패턴</li>
  <li><code class="language-plaintext highlighter-rouge">행위(11)</code> : 객체의 행위를 조직, 관리, 연합하는데 사용하는 패턴</li>
</ol>

<h3 id="디자인-패턴---생성-패턴">디자인 패턴 - 생성 패턴</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">팩토리 메소드(Factory Method)</code> : 상위 클래스에서 인터페이스 정의, 서브 클래스가 실제 생성</li>
  <li><code class="language-plaintext highlighter-rouge">프로토타입(Prototype)</code> : 원형 객체를 복사하여 생성 (객체 생성 시 갖춰야 할 기본 형태가 있을 때 사용)</li>
  <li><code class="language-plaintext highlighter-rouge">빌더(Builder)</code> : 객체를 조립하여 생성. 생성 방법과 구현 방법을 구분하여, 동일한 객체 생성이여도 다른 결과가 나올 수 있음)</li>
  <li><code class="language-plaintext highlighter-rouge">싱글톤(Singletone)</code> : 클래스 내 객체가 하나 뿐임을 보장. 하나의 객체를 생성해 어디든 참조할 수 있으나 동시 참조 불가</li>
  <li><code class="language-plaintext highlighter-rouge">추상 팩토리(Abstract Factory)</code> : 구체적인 클래스에 의존하지 않고, 연관된 객체들의 그룹으로 생성 (객체 간 결합이 느슨해짐)</li>
</ol>

<h3 id="디자인-패턴---구조-패턴">디자인 패턴 - 구조 패턴</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">퍼싸드(Facade)</code> : 복잡한 시스템에 단순한 인터페이스를 제공해 접근성을 높인 패턴</li>
  <li><code class="language-plaintext highlighter-rouge">플라이웨이트(Flyweight)</code> : 객체가 필요할 때 생성하는 대신 공유하여 메모리 절약</li>
  <li><code class="language-plaintext highlighter-rouge">컴포지트(Composite)</code> : 객체 관계를 파일 트리 구조로 구성하여, 복합 객체와 단일 객체를 동일하게 취급</li>
  <li><code class="language-plaintext highlighter-rouge">프록시(Proxy)</code> : 실제 기능을 수행하는 객체(Real object) 대신 가상의 객체(Proxy object)를 사용해 로직의 흐름을 제어하는 디자인 패턴</li>
  <li><code class="language-plaintext highlighter-rouge">브리지(Bridge)</code> : 구현부에서 추상층을 분리하여 결합도를 낮춘 패턴</li>
  <li><code class="language-plaintext highlighter-rouge">어댑터(Adapter)</code> : 호환성 없는 클래스의 인터페이스를 이용할 수 있게 변환</li>
  <li><code class="language-plaintext highlighter-rouge">데코레이터(Decorator)</code> : 객체 결합을 통해 기능을 확장</li>
</ol>

<h3 id="디자인-패턴---행위-패턴">디자인 패턴 - 행위 패턴</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">중재자(Mediator)</code> : 객체 사이에 중재자를 두어 의존성을 줄이는 패턴</li>
  <li><code class="language-plaintext highlighter-rouge">인터프리터(Interpreter)</code> : 여러 언어 구문을 해석할 수 있게 해주는 패턴</li>
  <li><code class="language-plaintext highlighter-rouge">템플릿 메소드(Template Method)</code> : 상위 클래스에서 기능을 정의하고, 하위 클래스에서 세부 처리 방법을 구체화하는 패턴</li>
  <li><code class="language-plaintext highlighter-rouge">옵저버(Observer)</code> : 객체를 지켜보고 있다가, 객체의 상태가 변하면 그 객체에 의존하는 다른 객체들에게 변화된 상태를 전달</li>
  <li><code class="language-plaintext highlighter-rouge">커맨드(Command)</code> : 요청을 객체로 캡슐화하여, 각 요청(명령)이 들어오면 그에 맞는 서브 클래스 실행</li>
  <li><code class="language-plaintext highlighter-rouge">비지터(Visitor)</code> : 처리 기능을 별도로 분리한 패턴 (분리된 처리 기능은 클래스를 방문하여 수행)</li>
  <li><code class="language-plaintext highlighter-rouge">반복자(Iterator)</code> : 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴 (내부 노출 없이 순차적 접근 가능)</li>
  <li><code class="language-plaintext highlighter-rouge">상태(State)</code> : 객체의 상태를 캡슐화하고, 이를 참조해 동작을 다르게 처리</li>
  <li><code class="language-plaintext highlighter-rouge">전략(Strategy)</code> : 동일한 계열의 알고리즘을 캡슐화하고, 전략을 선택해 사용</li>
  <li><code class="language-plaintext highlighter-rouge">책임 연쇄(Chain of Responsibility)</code> : 한 객체가 요청을 처리하지 못하면, 연결된 객체로 넘어가 처리</li>
  <li><code class="language-plaintext highlighter-rouge">메멘토(Memento)</code> : 특정 시점의 객체 내부 상태를 객체화하여, 해당 시점으로 되돌리는 기능을 제공<br /><br /></li>
</ol>

<h1 id="소프트웨어-아키텍처">소프트웨어 아키텍처</h1>
<ul>
  <li>소프트웨어 구성요소와, 구성요소의 특성, 구성요소 간 관계를 표현하는 구조</li>
</ul>

<h2 id="현행-시스템-파악">현행 시스템 파악</h2>
<ol>
  <li>구성 현황 / 기능 현황 / 인터페이스 파악</li>
  <li>아키텍처, 소프트웨어 구성 파악</li>
  <li>하드웨어, 네트워크 구성 파악</li>
</ol>

<h2 id="소프트웨어-41-뷰">소프트웨어 4+1 뷰</h2>
<ul>
  <li>요구사항을 4개의 관점에서 바라보는 방법. 4개 구조가 충돌되지 않는지, 요구사항을 충족하는지 증명하기 위해 유스케이스 사용
    <ul>
      <li><code class="language-plaintext highlighter-rouge">프로세스 뷰</code> : 비기능적인 속성으로 자원 사용 등을 표현한 뷰</li>
      <li><code class="language-plaintext highlighter-rouge">유스케이스 뷰</code> : 유스케이스를 도출하고 다른 뷰를 검증하는 뷰</li>
      <li><code class="language-plaintext highlighter-rouge">배치 뷰</code> : 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 보여주는 뷰</li>
      <li><code class="language-plaintext highlighter-rouge">논리 뷰</code> : 기능적인 요구사항이 어떻게 제공되는지 표현한 뷰</li>
      <li><code class="language-plaintext highlighter-rouge">구조 뷰</code> : 소프트웨어 모듈의 구성을 보여주는 뷰</li>
    </ul>
  </li>
</ul>

<h2 id="소프트웨어-아키텍처-패턴-종류">소프트웨어 아키텍처 패턴 종류</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">계층화 패턴</code> : 시스템을 계층으로 구분 (ex. <code class="language-plaintext highlighter-rouge">OSI 7계층</code> : 서로 마주보는 계층에서만 상호작용 발생)</li>
  <li><code class="language-plaintext highlighter-rouge">클라이언트-서버 패턴</code> : 하나의 서버 + 다수의 클라이언트 -&gt; 사용자는 클라이언트와만 상호작용</li>
  <li><code class="language-plaintext highlighter-rouge">파이프-필터 패턴</code> : 데이터 스트림을 처리하는 시스템에서 사용 (ex. <code class="language-plaintext highlighter-rouge">Unix의 Shell</code> : 하나의 서브시스템이 데이터를 받아 처리하고, 결과를 다음 서브 시스템에게 넘겨줌)</li>
  <li><code class="language-plaintext highlighter-rouge">브로커 패턴</code> : 사용자가 요청하면, 브로커가 적합한 컴포넌트를 연결하는 방식. 원격 서비스 호출에 응답하는 컴포넌트가 여럿일 때 적합</li>
  <li><code class="language-plaintext highlighter-rouge">모델-뷰-컨트롤러 패턴</code> : 3개의 서브시스템으로 구조화한 패턴
    <ul>
      <li><code class="language-plaintext highlighter-rouge">모델</code> : 핵심 기능과 데이터 보관</li>
      <li><code class="language-plaintext highlighter-rouge">뷰</code> : 사용자에게 정보 표시</li>
      <li><code class="language-plaintext highlighter-rouge">컨트롤러</code> : 사용자의 입력 처리 - 하나의 모델에 여러 개의 뷰를 필요로 하는 대화형 애플리케이션에 적합</li>
    </ul>
  </li>
</ol>

<h2 id="소프트웨어-아키텍처-비용-평가-모델">소프트웨어 아키텍처 비용 평가 모델</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">SAAM</code> : 변경 용이성과 기능성에 집중. 경험없어도 쉽게 사용 가능</li>
  <li><code class="language-plaintext highlighter-rouge">ATAM</code> : <code class="language-plaintext highlighter-rouge">SAAM</code>을 계승. 아키텍처 품질 속성을 만족하는지도 평가</li>
  <li><code class="language-plaintext highlighter-rouge">CBAM</code> : <code class="language-plaintext highlighter-rouge">ATAM</code>에 경제성 평가 보장</li>
  <li><code class="language-plaintext highlighter-rouge">ADR</code> : 아키텍처 구성요소 간 응집도 평가</li>
  <li><code class="language-plaintext highlighter-rouge">ARID</code> : <code class="language-plaintext highlighter-rouge">ATAM + ADR</code>. 전체가 아닌 특정 부분에 대한 비용 평가<br /><br /></li>
</ol>

<h1 id="sdlc-소프트웨어-생명주기">SDLC (소프트웨어 생명주기)</h1>
<ul>
  <li>시스템의 요구분석 ~ 유지보수까지 전 과정을 모델링한 것</li>
</ul>

<h2 id="sdlc-모델-종류">SDLC 모델 종류</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">폭포수 모델(Waterfall model)</code> : 선형 순차적 모델. 고전적 생명주기 모델. 각 개발 단계를 마무리 지은 후 넘어가는 모델로 가장 오래됐고, 성공사례가 많으며, 단계별 산출물이 명확하고 요구사항 변경이 어려움</li>
  <li><code class="language-plaintext highlighter-rouge">프로토타이핑 모델(Prototyping model)</code> : 주요 기능을 프로토타입으로 구현하고, 피드백을 반영해 만들어나가는 모델</li>
  <li><code class="language-plaintext highlighter-rouge">나선형 모델(Spiral model)</code> : 위험을 최소화하기 위해 점진적으로 개발해나가는 모델
    <ul>
      <li><code class="language-plaintext highlighter-rouge">절차</code> : 계획 및 정의 - 위험 분석 - 개발 - 고객 평가</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">반복적 모델(Iteration model)</code> : 병렬적으로 개발 후 통합하거나, 반복적으로 개발해 점차 완성시켜나가는 모델</li>
</ol>

<h2 id="sdlc-모델-프로세스">SDLC 모델 프로세스</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">요구사항 분석</code> : 요구사항을 분석하고, 제약조건, 목표 등을 정의</li>
  <li><code class="language-plaintext highlighter-rouge">설계</code> : 수행 방법을 논리적으로 결정 (ex. 시스템 구조 설계, 사용자 인터페이스 설계)</li>
  <li><code class="language-plaintext highlighter-rouge">구현</code> : 프로그래밍 언어를 사용해 실제로 코드를 작성 (ex. 인터페이스 개발, 자료 구조 개발, 오류 처리)</li>
  <li><code class="language-plaintext highlighter-rouge">테스트</code> (ex. 단위 테스트, 통합 테스트, 시스템 테스트, 인수 테스트)</li>
  <li><code class="language-plaintext highlighter-rouge">유지보수</code><br /><br /></li>
</ol>

<h1 id="소프트웨어-개발-방법론">소프트웨어 개발 방법론</h1>
<ul>
  <li>소프트웨어의 개발 시작부터 전 개발 과정을 형상화한 방법론</li>
</ul>

<h2 id="소프트웨어-개발-방법론-종류">소프트웨어 개발 방법론 종류</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">구조적 방법론</code> : 전체 시스템을 나눠 개발하고 통합하는 분할-정복 방식의 방법론. 나씨-슈나이더만 차트 사용</li>
  <li><code class="language-plaintext highlighter-rouge">정보공학 방법론</code> : 정보 시스템 개발에 필요한 절차를 체계화한 방법론 (대형 프로젝트)</li>
  <li><code class="language-plaintext highlighter-rouge">객체지향 방법론</code> : 객체라는 단위로 시스템을 설계하는 방법론</li>
  <li><code class="language-plaintext highlighter-rouge">컴포넌트 기반 방법론</code> : 컴포넌트를 조립해 작성하는 방법론</li>
  <li><code class="language-plaintext highlighter-rouge">애자일 방법론</code> : 절차보다 사람이 우선되는, 변화에 유연한 경량 개발 방법론</li>
  <li><code class="language-plaintext highlighter-rouge">제품 개발 방법론</code> : 제품에 적용할 공통 기능을 정의하여 개발하는 방법론 (임베디드 소프트웨어 작성에 유용)<br /><br /></li>
</ol>

<h1 id="xp">XP</h1>
<ul>
  <li>1-3주의 반복 주기를 갖는 애자일 방법론</li>
</ul>

<h2 id="xp의-5가지-가치">XP의 5가지 가치</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">용기</code> : 용기를 갖고 빠르게 개발</li>
  <li><code class="language-plaintext highlighter-rouge">단순성</code> : 필요한 것만 하자</li>
  <li><code class="language-plaintext highlighter-rouge">의사소통</code> : 개발자-관리자-고객 간 원활하게 소통</li>
  <li><code class="language-plaintext highlighter-rouge">피드백</code> : 의사소통에 대한 빠른 피드백</li>
  <li><code class="language-plaintext highlighter-rouge">존중</code> : 팀원간 상호 존중</li>
</ol>

<h2 id="xp의-12가지-기본-원리">XP의 12가지 기본 원리</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">짝 프로그래밍 (Pair Programming)</code> : 다른 사람과 페어로 개발하여 공동 책임을 지님</li>
  <li><code class="language-plaintext highlighter-rouge">공동 코드 소유 (Collective Ownership)</code> : 시스템에 있는 코드는 누구나 언제든 수정 가능</li>
  <li><code class="language-plaintext highlighter-rouge">지속적인 통합 (CI ; Continuos Integration)</code> : 여러 번 소프트웨어를 통합하고 빌드해야 함</li>
  <li><code class="language-plaintext highlighter-rouge">계획 세우기 (Planning Process)</code> : 고객이 원하는 가치를 정의하고, 개발에 필요한 것은 무엇이며, 어떤 곳에서 지연이 될 수 있는지 알려줘야 함</li>
  <li><code class="language-plaintext highlighter-rouge">작은 릴리즈 (Small Release)</code> : 작은 시스템을 먼저 만들고, 짧은 단위로 업데이트</li>
  <li><code class="language-plaintext highlighter-rouge">메타포어 (Metaphor)</code> : 공통 이름 체계를 통해 의사소통을 원활히</li>
  <li><code class="language-plaintext highlighter-rouge">간단한 디자인 (Simple Release)</code> : 요구사항에 적합한 단순한 시스템을 설계</li>
  <li><code class="language-plaintext highlighter-rouge">테스트 기반 개발 (TDD ; Test Drive Develop)</code> : 테스트를 먼저 수행하고, 통과할 수 있는 코드를 작성</li>
  <li><code class="language-plaintext highlighter-rouge">리팩토링 (Refactoring)</code> : 기능을 바꾸지 않으면서 중복제거, 단순화 등을 위해 코드를 재구성</li>
  <li><code class="language-plaintext highlighter-rouge">40시간 작업 (40-Hour Work)</code> : 피곤으로 인한 실수가 없도록 주 40시간만 일하자</li>
  <li><code class="language-plaintext highlighter-rouge">고객 상주 (On Site Customer)</code> : 개발자들의 질문에 즉각 대답해줄 수 있는 고객이 풀타임 상주해야 함</li>
  <li><code class="language-plaintext highlighter-rouge">코드 표준 (Coding Standard)</code> : 코딩 표준을 두고 효과적으로 개발<br /><br /></li>
</ol>

<h1 id="린">린</h1>
<ul>
  <li>낭비 요소를 제거해 품질을 향상시키는 애자일 방법론</li>
</ul>

<h2 id="린의-7가지-원칙">린의 7가지 원칙</h2>
<ol>
  <li>낭비제거</li>
  <li>품질 내재화</li>
  <li>지식 창출</li>
  <li>늦은 확정</li>
  <li>빠른 인도</li>
  <li>사람 존중</li>
  <li>전체 최적화<br /><br /></li>
</ol>

<h1 id="스크럼">스크럼</h1>
<ul>
  <li>매일 정해진 시간 / 장소에서 짧은 시간의 개발을 위한 애자일 방법론</li>
</ul>

<h2 id="스크럼-용어">스크럼 용어</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">백로그</code> : 제품에 대한 요구사항</li>
  <li><code class="language-plaintext highlighter-rouge">스프린트</code> : 짧은 기간 내 반복적으로 개발</li>
  <li><code class="language-plaintext highlighter-rouge">데일리(스크럼) 미팅</code> : 매일 To-Do List 계획 수립. 번다운 차트 작성</li>
  <li><code class="language-plaintext highlighter-rouge">스크럼 마스터</code> : 프로젝트 리더</li>
  <li><code class="language-plaintext highlighter-rouge">스프린트 회고</code> : 각자 반성하고 개선점 확인</li>
  <li><code class="language-plaintext highlighter-rouge">번 다운 차트</code> : 남아있는 백로그 대비 시간을 시각적으로 표현 (백로그를 수직, 시간을 수평)<br /><br /></li>
</ul>

<h1 id="비용산정-모델">비용산정 모델</h1>
<ul>
  <li>소프트웨어 개발 계획을 수립하기 위해 투입될 자원이나 시간을 산정하는 방식
    <ul>
      <li><code class="language-plaintext highlighter-rouge">하향식</code> : 전문가가 산정 (ex. 델파이 기법)</li>
      <li><code class="language-plaintext highlighter-rouge">상향식</code> : 요구사항과 기능에 따라 산정 (ex. LoC, Man Month, COCOMO, 푸트남, FP)</li>
    </ul>
  </li>
</ul>

<h2 id="비용산정-모델-종류">비용산정 모델 종류</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">LoC(Lines of Codes) 모형</code> : 코드 라인 수의 예측치를 구하여 비용 산정
    <ul>
      <li><code class="language-plaintext highlighter-rouge">산정방법</code> : (낙관치 + 중관치 x 4 + 비관치) / 6</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">COCOMO 모형</code> : 프로그램 규모에 따라 비용을 산정
    <ol>
      <li><code class="language-plaintext highlighter-rouge">조직형 / 단순형 (Organic)</code> : 소규모 5만 라인 (5KSDI) 이하</li>
      <li><code class="language-plaintext highlighter-rouge">반 분리형 (Semi-Detached)</code> : 중간형 30만 라인 (30KSDI) 이하</li>
      <li><code class="language-plaintext highlighter-rouge">임베디드형 (Embedded)</code> : 초대형</li>
    </ol>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Man Month 모형</code> : 한 사람이 1개월 간 할 수 있는 일의 양을 기준으로 비용 산정
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Man Month = LoC / 개발자의 월간 생산성</code></li>
      <li><code class="language-plaintext highlighter-rouge">프로젝트 기간 = Man Month / 프로젝트 인력</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">푸트남(Putnam) 모형</code> : 생명주기 단계별 인력분포를 예측하는 방식 (시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선 분포도 기초)</li>
  <li><code class="language-plaintext highlighter-rouge">FP(기능점수) 모형</code> : 요구 기능별로 가중치를 부여해 총 점수를 계산해 비용 산정<br /><br /></li>
</ul>

<h1 id="일정-관리-모델">일정 관리 모델</h1>
<ol>
  <li><code class="language-plaintext highlighter-rouge">CPM(주 공정법)</code> : 여러 작업의 수행 순서가 얽힌 프로젝트에서 일정을 계산하는 기법
    <ul>
      <li><code class="language-plaintext highlighter-rouge">임계 경로(Critical Path) 계산법</code> : 가장 긴 경로 계산</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">CCPM(중요 연쇄 공정법)</code> : 주 공정법의 연쇄법으로, 자원 제약사항을 고려해 계산</li>
  <li><code class="language-plaintext highlighter-rouge">PERT</code> : 낙관치, 중관치, 비관치의 3점 추정방식으로 일정 관리<br /><br /></li>
</ol>

<h1 id="ui">UI</h1>
<ul>
  <li>사용자와 시스템 사이의 매개체</li>
</ul>

<h2 id="ui-유형">UI 유형</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">CLI</code> : 텍스트(명령어) 기반</li>
  <li><code class="language-plaintext highlighter-rouge">GUI</code> : 그래픽 기반(마우스, 펜)</li>
  <li><code class="language-plaintext highlighter-rouge">NUI</code> : 신체 부위 이용(터치, 음성)</li>
  <li><code class="language-plaintext highlighter-rouge">OUI</code> : 유기적 상호작용 기반 인터페이스(모든 사물이 입출력장치로 변화)</li>
</ol>

<h2 id="ui-설계-원칙">UI 설계 원칙</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">직관성</code> : 누구나 쉽게 이해하고 쉽게 사용할 수 있어야 함</li>
  <li><code class="language-plaintext highlighter-rouge">유효성</code> : 사용자 목표가 달성될 수 있어야 함</li>
  <li><code class="language-plaintext highlighter-rouge">학습성</code> : 쉽게 배울 수 있어야 함</li>
  <li><code class="language-plaintext highlighter-rouge">유연성</code> : 인터렉션을 최대한 포용해야 함</li>
</ol>

<h2 id="ui-설계-지침">UI 설계 지침</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">사용자 중심</code> : 사용자가 이해하기 쉽게 설계</li>
  <li><code class="language-plaintext highlighter-rouge">일관성</code> : 조작법을 빨리 이해할 수 있도록 일관적으로 설계해야 함</li>
  <li><code class="language-plaintext highlighter-rouge">단순성</code></li>
  <li><code class="language-plaintext highlighter-rouge">결과 예측 가능</code></li>
  <li><code class="language-plaintext highlighter-rouge">명확성</code> : 개념적으로 인지하기 쉬워야 함</li>
  <li><code class="language-plaintext highlighter-rouge">표준화</code> : 디자인 표준으로 선행학습 이후 쉽게 사용할 수 있어야 함</li>
  <li><code class="language-plaintext highlighter-rouge">오류 발생 해결</code> : 오류 상황을 인지할 수 있어야 함</li>
  <li><code class="language-plaintext highlighter-rouge">접근성</code> : 연령, 성별 등 다양한 계층을 수용해야 함</li>
  <li><code class="language-plaintext highlighter-rouge">가시성</code> : 주요 기능은 메인 화면에 노출해야 함</li>
</ol>

<h2 id="ui-시나리오-문서-작성-요건">UI 시나리오 문서 작성 요건</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">완전성</code> : 누락 없이 최대한 상세하게 작성</li>
  <li><code class="language-plaintext highlighter-rouge">일관성</code> : 요구사항은 일관적이어야 함. UI도 일관적으로 작성</li>
  <li><code class="language-plaintext highlighter-rouge">이해성</code> : 이해하기 쉬워야 함</li>
  <li><code class="language-plaintext highlighter-rouge">가독성</code> : 쉽게 읽혀야 함</li>
  <li><code class="language-plaintext highlighter-rouge">추적 용이성</code> : 변경사항을 알아보기 쉬워야 함</li>
  <li><code class="language-plaintext highlighter-rouge">수정 용이성</code> : 쉽게 수정할 수 있어야 함</li>
</ol>

<h2 id="ui-설계-도구">UI 설계 도구</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">화면 설계 도구</code> : 파워 목업, 발사믹 목업, 카카오 오븐</li>
  <li><code class="language-plaintext highlighter-rouge">프로토타이핑 도구</code> : UX핀, 액슈어(디스크립션까지 작성 가능), 네이버 프로토나우</li>
  <li><code class="language-plaintext highlighter-rouge">UI 디자인 산출물로 작업하는 프로토타이핑 도구</code> : 인비전, 픽사에이트, 프레이머</li>
</ol>

<h2 id="ui-품질-요구사항-isoiec-9126-기반">UI 품질 요구사항 (ISO/IEC 9126 기반)</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">이식성</code> : 다른 환경에도 잘 적응하는가?
    <ul>
      <li><code class="language-plaintext highlighter-rouge">적용성</code> : 다른 환경에도 잘 적용되고</li>
      <li><code class="language-plaintext highlighter-rouge">설치성</code> : 잘 설치되며</li>
      <li><code class="language-plaintext highlighter-rouge">대체성</code> : 다른 SW를 대체할 수 있는지</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">신뢰성</code> : 오류가 없거나 있더라도 괜찮은가?
    <ul>
      <li><code class="language-plaintext highlighter-rouge">성숙성</code> : 오류가 없고</li>
      <li><code class="language-plaintext highlighter-rouge">고장허용성</code> : 오류가 있어도 성능을 유지할 수 있고</li>
      <li><code class="language-plaintext highlighter-rouge">회복성</code> : 오류를 금방 회복할 수 있는지</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">사용성</code> : 쓰기 편한가?
    <ul>
      <li><code class="language-plaintext highlighter-rouge">이해성</code> : 이해하기 쉽고</li>
      <li><code class="language-plaintext highlighter-rouge">학습성</code> : 배우기 쉽고</li>
      <li><code class="language-plaintext highlighter-rouge">운용성</code> : 다루기 쉬운지</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">유지보수성</code> : 개선 및 확장이 쉬운가?
    <ul>
      <li><code class="language-plaintext highlighter-rouge">분석성</code> : 결함이나 고장을 발견하기 쉽고</li>
      <li><code class="language-plaintext highlighter-rouge">변경성</code> : 수정하기 쉽고</li>
      <li><code class="language-plaintext highlighter-rouge">안정성</code> : 수정하더라도 안정적이고</li>
      <li><code class="language-plaintext highlighter-rouge">시험성</code> : 변경된 내용을 검증할 수 있는지</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">효율성</code> : 한정된 자원을 효율적으로 쓰는가?
    <ul>
      <li><code class="language-plaintext highlighter-rouge">시간반응성</code> : 처리 속도가 빠르고</li>
      <li><code class="language-plaintext highlighter-rouge">자원효율성</code> : 적절한 자원을 제공하는지</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">기능성</code> : 요구사항을 정확하게 만족하며 기능하는가?
    <ul>
      <li><code class="language-plaintext highlighter-rouge">적절성</code> : 적절하고</li>
      <li><code class="language-plaintext highlighter-rouge">정밀성</code> : 정확하고</li>
      <li><code class="language-plaintext highlighter-rouge">상호운용성</code> : 상호 운용되고</li>
      <li><code class="language-plaintext highlighter-rouge">보안성</code> : 보안성 있고</li>
      <li><code class="language-plaintext highlighter-rouge">호환성</code> : 표준 잘 지키는지</li>
    </ul>
  </li>
</ol>

<h2 id="ui-표준">UI 표준</h2>
<ol>
  <li>UX 원칙 정의</li>
  <li>정책 및 철학 설정</li>
  <li>스타일 가이드 정의</li>
  <li>UI 패턴 모델 정의</li>
  <li>조직 구성</li>
</ol>

<h2 id="ui-개발을-위한-주요-기법">UI 개발을 위한 주요 기법</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">3C 분석</code> : Customer(고객), Company(자사), Competitor(경쟁사) 분석</li>
  <li><code class="language-plaintext highlighter-rouge">SWOT 분석</code> : 강점, 약점, 기회, 위협 요인을 분석</li>
  <li><code class="language-plaintext highlighter-rouge">시나리오 플래닝</code> : 다양한 시나리오를 설계해 불확실성 제거</li>
  <li><code class="language-plaintext highlighter-rouge">사용성 테스트</code> : 사용자가 직접 제품을 사용하며 과제 수행</li>
  <li><code class="language-plaintext highlighter-rouge">워크숍</code> : 집단이 모여 지식, 아이디어를 교환하고 검토하는 연구회</li>
</ul>

<h2 id="ui-화면-설계-구분">UI 화면 설계 구분</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">와이어프레임</code> : 화면 단위의 레이아웃 설계</li>
  <li><code class="language-plaintext highlighter-rouge">스토리보드</code> : 정책, 와이어프레임 등 구축하려는 서비스를 위한 정보가 수록된 문서</li>
  <li><code class="language-plaintext highlighter-rouge">프로토타입</code> : 와이어프레임(or 스토리보드) + 동적 효과<br /><br /></li>
</ul>

<h1 id="사용자-요구사항-도출">사용자 요구사항 도출</h1>
<ol>
  <li>페르소나 정의</li>
  <li>콘셉트 모델 정의</li>
  <li>요구사항 정의</li>
  <li>UI 컨셉션<br /><br /></li>
</ol>

<h1 id="uml">UML</h1>
<ul>
  <li>표준화된 범용 모델링 언어</li>
</ul>

<h2 id="uml의-특징">UML의 특징</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">가시화 언어</code> : 원활한 의사소통을 위해 가시화</li>
  <li><code class="language-plaintext highlighter-rouge">구축 언어</code> : UML -&gt; 소스코드 변환 가능</li>
  <li><code class="language-plaintext highlighter-rouge">명세화 언어</code></li>
  <li><code class="language-plaintext highlighter-rouge">문서화 언어</code></li>
</ol>

<h2 id="uml의-구성요소">UML의 구성요소</h2>
<ol>
  <li>사물</li>
  <li>관계</li>
  <li>다이어그램</li>
</ol>

<h2 id="uml-다이어그램">UML 다이어그램</h2>
<ul>
  <li>정적(구조적) 다이어그램
    <ol>
      <li><code class="language-plaintext highlighter-rouge">클래스 다이어그램</code> : 클래스 간 관계 표현</li>
      <li><code class="language-plaintext highlighter-rouge">객체 다이어그램</code> : 객체 간 관계 표현</li>
      <li><code class="language-plaintext highlighter-rouge">컴포넌트 다이어그램</code> : 컴포넌트 간 관계를 표현. 구현 단계에서 사용</li>
      <li><code class="language-plaintext highlighter-rouge">배치 다이어그램</code> : 물리적 요소의 위치 표현. 구현 단계에서 사용</li>
      <li><code class="language-plaintext highlighter-rouge">복합체 구조 다이어그램</code> : 복합 구조인 경우 그 내부 표현</li>
      <li><code class="language-plaintext highlighter-rouge">패키지 다이어그램</code> : 패키지 간 관계 표현</li>
    </ol>
  </li>
  <li>동적(행위적) 다이어그램
    <ol>
      <li><code class="language-plaintext highlighter-rouge">시퀀스 다이어그램</code> : <code class="language-plaintext highlighter-rouge">시간적 개념</code> 중심으로 메시지 표현</li>
      <li><code class="language-plaintext highlighter-rouge">유스케이스 다이어그램</code> : 사용자 관점에서 표현</li>
      <li><code class="language-plaintext highlighter-rouge">커뮤니케이션 다이어그램</code> : 객체들이 주고 받는 메시지와 상호작용(객체 간 연관)까지 표현</li>
      <li><code class="language-plaintext highlighter-rouge">활동 다이어그램</code> : 시스템이 수행하는 활동을 표현</li>
      <li><code class="language-plaintext highlighter-rouge">상태 다이어그램</code> : 객체의 상태와 상태 변화를 표현</li>
      <li><code class="language-plaintext highlighter-rouge">타이밍 다이어그램</code> : 객체의 상태 변화와 시간 제약을 표현</li>
    </ol>
  </li>
</ul>

<h2 id="uml-스테레오-타입">UML 스테레오 타입</h2>
<ul>
  <li>UML 기본 요소 + 새로운 요소를 더한 확장 매커니즘. « »(길러멧) 기호 사용</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;&lt;include&gt;&gt;</code> : 어떤 시점에 반드시 다른 유스케이스를 실행함</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;&lt;extend&gt;&gt;</code> : 어떤 시점에 다른 유스케이스를 실행할 수도 있고 아닐 수도 있음</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;&lt;abstract&gt;&gt;</code> : 추상 클래스 (인스턴스 생성 하지 않고 공통 특징만 정의)</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;&lt;interface&gt;&gt;</code> : 모든 메서드와 상수가 추상인 클래스</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;&lt;entity&gt;&gt;</code> : 정보 또는 행위를 표현하는 클래스</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;&lt;boundary&gt;&gt;</code> : 상호작용을 담당하는 클래스</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;&lt;control&gt;&gt;</code> : 로직 및 제어를 담당하는 클래스</li>
</ul>

<h2 id="다이어그램-종류">다이어그램 종류</h2>
<h3 id="클래스-다이어그램">클래스 다이어그램</h3>
<ul>
  <li>클래스의 속성(변수), 연산(메서드), 클래스 간 관계를 표현한 다이어그램</li>
  <li>속성 : 클래스의 구조적 특성 (인스턴스가 보유 가능한 값의 범위)</li>
  <li>접근 제어자 : 접근 가능한 정도</li>
</ul>

<h4 id="클래스-접근제어자">클래스 접근제어자</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">public</code> : 외부 모든 클래스에서 접근 가능</li>
  <li><code class="language-plaintext highlighter-rouge">protected</code> : 동일 패키지(하위 클래스 포함)일 때 접근 가능</li>
  <li><code class="language-plaintext highlighter-rouge">default</code> : 자바 전용. 접근 제어자 명시가 없을 때 동일 패키지(하위 클래스 포함) 또는 파생 클래스에서 접근 가능</li>
  <li><code class="language-plaintext highlighter-rouge">private</code> : 같은 클래스 내에서만 접근 가능</li>
</ul>

<h4 id="클래스-간-관계">클래스 간 관계</h4>
<ol>
  <li><code class="language-plaintext highlighter-rouge">연관(Association)</code> : 관련되어 있음 &lt; - - &gt; (양방향은 화살표 생략)</li>
  <li><code class="language-plaintext highlighter-rouge">의존(Dependency)</code> : 클래스가 다른 클래스 사용 &lt; . . . &gt;</li>
  <li><code class="language-plaintext highlighter-rouge">집합(Aggeregation)</code> : 포함하지만 독립적</li>
  <li><code class="language-plaintext highlighter-rouge">포함(Composition)</code> : 포함하고 생명주기를 함께 함</li>
  <li><code class="language-plaintext highlighter-rouge">일반화(Generalization)</code> : 일반적인지 구체적인지</li>
  <li><code class="language-plaintext highlighter-rouge">실체화(Realization)</code> : 기능으로 묶인 관계</li>
</ol>

<h3 id="컴포넌트-다이어그램">컴포넌트 다이어그램</h3>
<ul>
  <li>컴포넌트와 컴포넌트 간 관계를 표현한 다이어그램
    <ul>
      <li>컴포넌트 : 탭 2개가 달린 직사각형 + 이름</li>
    </ul>
  </li>
</ul>

<h3 id="패키지-다이어그램">패키지 다이어그램</h3>
<ul>
  <li>패키지 관계를 표현한 다이어그램
    <ul>
      <li>패키지 : 폴더 형태</li>
    </ul>
  </li>
</ul>

<h3 id="시퀀스-다이어그램">시퀀스 다이어그램</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">시간적 개념</code> 중심으로 메시지 흐름을 표현한 다이어그램
    <ul>
      <li>생명선 : - - - - -</li>
      <li>실행 : - - [ ] - - (함수 실행시간)</li>
    </ul>
  </li>
</ul>

<h3 id="유스케이스-다이어그램">유스케이스 다이어그램</h3>
<ul>
  <li>사용자 시점에서 표현한 다이어그램</li>
</ul>

<h3 id="커뮤니케이션-다이어그램">커뮤니케이션 다이어그램</h3>
<ul>
  <li>객체들이 주고받는 메시지와 상호작용(객체 간 연관)까지 표현한 다이어그램
    <ul>
      <li>객체 : 사각형 (객체명:클래스명 으로 표현)</li>
      <li>메시지 : -&gt; 표현</li>
    </ul>
  </li>
</ul>

<h3 id="활동-다이어그램">활동 다이어그램</h3>
<ul>
  <li>시스템의 처리 활동을 순서대로 표현한 다이어그램
    <ul>
      <li>종료점 : 조건 노드, 병합 노드, 포크 노드</li>
    </ul>
  </li>
</ul>

<h3 id="상태-다이어그램">상태 다이어그램</h3>
<ul>
  <li>객체의 상태와 상태 변화를 표현한 다이어그램
    <ul>
      <li>종료점 : 전이, 전이 조건, 이벤트<br /><br /></li>
    </ul>
  </li>
</ul>

<h1 id="데이터-모델">데이터 모델</h1>
<ul>
  <li>현실 세계의 정보를 컴퓨터가 이해할 수 있도록 표현한 모델</li>
</ul>

<h2 id="데이터-모델의-구성-요소">데이터 모델의 구성 요소</h2>
<ul>
  <li>연구제!!!</li>
</ul>

<ol>
  <li>연산</li>
  <li>구조</li>
  <li>제약조건</li>
</ol>

<h2 id="데이터-모델의-절차">데이터 모델의 절차</h2>
<ul>
  <li>개논물</li>
  <li>개념적 -&gt; 논리적 -&gt; 물리적</li>
</ul>

<h3 id="개념적-데이터-모델">개념적 데이터 모델</h3>
<ul>
  <li>현실 세계의 정보를 <code class="language-plaintext highlighter-rouge">추상적</code>, <code class="language-plaintext highlighter-rouge">개념적</code>으로 표현</li>
  <li>DB 종류에 무관함</li>
  <li>주요 산출물 : E-R 다이어그램
    <ul>
      <li><code class="language-plaintext highlighter-rouge">E-R 다이어그램</code> : 현실의 정보를 사람이 이해할 수 있는 형태로 표현해 개체와 개체의 속성, 개체 간 관계를 도식화 한 다이어그램</li>
      <li><code class="language-plaintext highlighter-rouge">E-R 다이어그램 구성요소</code>
        <ul>
          <li>개체 : □</li>
          <li>속성 : ○</li>
          <li>다중 값 속성 : ◎</li>
          <li>관계-속성 : ─</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">개체 정의서</code> : 개념 데이터 모델링 단계에서 도출된 개체와 관련된 정보를 명세화한 문서</li>
    </ul>
  </li>
</ul>

<h3 id="논리적-데이터-모델">논리적 데이터 모델</h3>
<ul>
  <li>논리적 데이터베이스 구조로 매핑</li>
  <li>목표 DBMS 설정, <code class="language-plaintext highlighter-rouge">스키마 설계</code></li>
  <li>정규화 수행</li>
  <li>모델링 종류
    <ol>
      <li>관계 데이터 모델</li>
      <li>계층 데이터 모델</li>
      <li>네트워크 데이터 모델</li>
    </ol>
  </li>
</ul>

<h3 id="물리적-데이터-모델">물리적 데이터 모델</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">객체 생성</code> (테이블, 뷰, 인덱스 등)</li>
  <li>반 정규화 수행<br /><br /></li>
</ul>

<h1 id="관계-데이터-모델">관계 데이터 모델</h1>
<ul>
  <li>2차원 테이블 형태</li>
  <li>Codd 박사가 제안</li>
  <li>1:1, 1:N, N:M 자유롭게 표현<br /><br /></li>
</ul>

<h1 id="네트워크-데이터-모델">네트워크 데이터 모델</h1>
<ul>
  <li>그래프 형태</li>
  <li>CODASYL DBTG 모델이라고도 함</li>
  <li>상위-하위 레코드 간 N:M 관계<br /><br /></li>
</ul>

<h1 id="계층-데이터-모델">계층 데이터 모델</h1>
<ul>
  <li>트리 형태</li>
  <li>상하 관계 존재</li>
  <li>1:N 관계만 허용<br /><br /></li>
</ul>

<h1 id="데이터베이스">데이터베이스</h1>
<ul>
  <li>다수의 인원과 시스템이 사용할 목적으로 관리하는 데이터 집합
    <ol>
      <li>통합된 데이터</li>
      <li>저장된 데이터</li>
      <li>운영 데이터</li>
      <li>공용 데이터</li>
    </ol>
  </li>
</ul>

<h2 id="데이터베이스-특성">데이터베이스 특성</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">실시간 접근성</code> : 쿼리에 실시간으로 응답</li>
  <li><code class="language-plaintext highlighter-rouge">계속적인 변화</code> : 삽입/삭제/갱신으로 최신 데이터 유지</li>
  <li><code class="language-plaintext highlighter-rouge">동시 공용</code> : 다수 사용자가 이용</li>
  <li><code class="language-plaintext highlighter-rouge">내용 참조</code> : 사용자가 요구하는 내용으로 참조</li>
</ol>

<h2 id="데이터베이스의-종류">데이터베이스의 종류</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">파일 시스템 개념</code> : DB 전 단계의 데이터 관리 방식</li>
  <li><code class="language-plaintext highlighter-rouge">관계형 DBMS(= RDBMS)</code> : 관계형 데이터 모델을 기반으로 하는 DB 관리 시스템</li>
  <li><code class="language-plaintext highlighter-rouge">계층형 DBMS(= HDBMS)</code> : 데이터를 상하 종속 관계로 계층화한 모델</li>
  <li><code class="language-plaintext highlighter-rouge">네트워크형 DBMS(= NDBMS)</code> : 데이터를 망상 형태로 표현한 모델</li>
</ol>

<h2 id="dbms">DBMS</h2>
<ul>
  <li>데이터의 추가, 변경, 삭제 등의 관리 기능을 제공하는 소프트웨어</li>
</ul>

<h2 id="dbms의-유형">DBMS의 유형</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">Key-Value DBMS</code> : Unique한 키에 하나의 값을 갖는 형태 (ex. Redis, DynamoDB)</li>
  <li><code class="language-plaintext highlighter-rouge">Column Family Data Store DBMS</code> : Key 안에 (Column, Value) 조합의 필드를 갖는 DBMS. 구글의 Bigtable 기반 (ex.. HBase, Cassandra)</li>
  <li><code class="language-plaintext highlighter-rouge">Document Store DBMS</code> : 값의 데이터 타입이 문서 타입(XML, JSON)인 DBMS (ex. MongoDB, Couchbase)</li>
  <li><code class="language-plaintext highlighter-rouge">Graph DBMS</code> : 시멘틱 웹과 온톨로지 분야에서 활용되는 그래프로 데이터를 표현 (ex. Neo4j, AllegroGraph)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">온톨로지</code> : 실세계에 존재하는 개념 정보를 컴퓨터가 이해할 수 있도록 서술한 지식베이스</li>
    </ul>
  </li>
</ol>

<h2 id="dbms의-특징">DBMS의 특징</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">데이터 일관성</code> : 조작 후에도 데이터는 변함없음</li>
  <li><code class="language-plaintext highlighter-rouge">데이터 회복성</code> : 장애 발생 시 복구되어야 함</li>
  <li><code class="language-plaintext highlighter-rouge">데이터 무결성</code> : 동일한 내용에 서로 다른 데이터가 저장되지 않아야 함</li>
  <li><code class="language-plaintext highlighter-rouge">데이터 효율성</code> : 응답시간, 저장공간 등을 최적화해야 함</li>
  <li><code class="language-plaintext highlighter-rouge">데이터 보안성</code> : 불법적인 노출, 변경으로부터 보호해야 함</li>
</ol>

<h2 id="dbms-분석-시-고려-사항">DBMS 분석 시 고려 사항</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">성능 측면</code> : 가용성, 성능, 상호 호환성</li>
  <li><code class="language-plaintext highlighter-rouge">지원 측면</code> : 기술 지원, 구축 비용<br /><br /></li>
</ol>

<h1 id="관계-대수">관계 대수</h1>
<ul>
  <li>원하는 정보를 어떻게 유도하는가에 대한 절차적 정형 언어</li>
</ul>

<h2 id="일반-집합-연산자">일반 집합 연산자</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">합집합(Union)</code> : 전체</li>
  <li><code class="language-plaintext highlighter-rouge">교집합(Intersection)</code> : 공통</li>
  <li><code class="language-plaintext highlighter-rouge">차집합(Difference)</code> : R에만 존재하고 S에는 없음</li>
  <li><code class="language-plaintext highlighter-rouge">카티션 프로덕트(CARTESIAN Product)</code> : R과 S에 속한 모든 튜플 연결</li>
</ol>

<h2 id="순수-관계-연산자">순수 관계 연산자</h2>
<ol>
  <li>셀렉트 <code class="language-plaintext highlighter-rouge">σ</code> : <code class="language-plaintext highlighter-rouge">σ 조건 (R)</code> R에서 조건을 만족하는 튜플 반환 -&gt; 가로</li>
  <li>프로젝트 <code class="language-plaintext highlighter-rouge">π</code> : <code class="language-plaintext highlighter-rouge">π 속성리스트 (R)</code> R에서 주어진 속성들로만 구성된 튜플 반환 -&gt; 세로</li>
  <li>조인 <code class="language-plaintext highlighter-rouge">▷◁</code> : <code class="language-plaintext highlighter-rouge">R ▷◁ S</code> 공통 속성으로 R과 S의 튜플 연결하여 반환</li>
  <li>디비전 <code class="language-plaintext highlighter-rouge">÷</code> : <code class="language-plaintext highlighter-rouge">R ÷ S</code> S의 모든 튜플과 관련된 R의 튜플 반환<br /><br /></li>
</ol>

<h1 id="관계-해석">관계 해석</h1>
<ul>
  <li>원하는 정보가 무엇인가에 대한 비절차적 언어 (프레디킷 해석 기반)<br /><br /></li>
</ul>

<h1 id="정규화normalization">정규화(Normalization)</h1>
<ul>
  <li>데이터의 중복성을 제거하여 이상 현상을 방지하는 과정</li>
</ul>

<h2 id="이상-현상anomaly">이상 현상(Anomaly)</h2>
<ul>
  <li>데이터 중복으로 인해 릴레이션 조작 시 발생하는 비합리적 현상</li>
  <li><code class="language-plaintext highlighter-rouge">삽입, 삭제, 갱신 이상</code> (select, update, delete)</li>
</ul>

<h2 id="정규화-단계">정규화 단계</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">1NF (1차 정규화)</code> : 도메인은 원자값으로만 구성</li>
  <li><code class="language-plaintext highlighter-rouge">2NF (2차 정규화)</code> : 부분 함수 종속성 제거 (완전 함수적 종속 관계)</li>
  <li><code class="language-plaintext highlighter-rouge">3NF (3차 정규화)</code> : 이행 함수 종속성 제거 (A -&gt; B, B -&gt; C, A -&gt; C일 때 이행 함수 종속 관계)</li>
  <li><code class="language-plaintext highlighter-rouge">보이스-코드(BC)NF</code> : 결정자는 모두 후보키여야 함</li>
  <li><code class="language-plaintext highlighter-rouge">4NF (4차 정규화)</code> : 다치(다중값) 종속 제거</li>
  <li><code class="language-plaintext highlighter-rouge">5NF (5차 정규화)</code> : 조인 종속 제거 (릴레이션의 모든 조인 종속이 후보키를 통해서만 설립)<br /><br /></li>
</ol>

<h1 id="반-정규화de-normalization">반 정규화(De-Normalization)</h1>
<ul>
  <li>정규화된 개체/속성/관계를 단순화하는 기법</li>
  <li>장점 : 성능 &amp; 관리 효율성 증대</li>
  <li>단점 : 일관성 &amp; 무관성 하락</li>
</ul>

<h2 id="반-정규화-기법">반 정규화 기법</h2>
<ol>
  <li>테이블 병합</li>
  <li>테이블 분할</li>
  <li>중복 테이블 추가 : 집계테이블, 진행테이블, 특정 부분만을 포함하는 테이블</li>
  <li>중복 컬럼 허용</li>
  <li>중복 관계 허용<br /><br /></li>
</ol>

<h1 id="nosql">NoSQL</h1>
<ul>
  <li>Not Only SQL</li>
  <li>전통적인 RDBMS가 아닌 DBMS를 지칭</li>
  <li>조인 연산 불가, 수평적으로 확장 가능</li>
</ul>

<h2 id="nosql의-특징">NoSQL의 특징</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">Basically Available</code> : 언제든지 접근 가능해야 함</li>
  <li><code class="language-plaintext highlighter-rouge">Soft-State</code> : 노드의 상태는 외부 정보로 결정됨</li>
  <li><code class="language-plaintext highlighter-rouge">Eventually Consistency</code> : 일정 시간이 지나면 데이터 일관성이 유지됨</li>
</ol>

<h2 id="nosql의-유형">NoSQL의 유형</h2>
<ol>
  <li>Key-Value</li>
  <li>Column Family Data Store</li>
  <li>Document Store</li>
  <li>Graph<br /><br /></li>
</ol>

<h1 id="데이터-마이닝">데이터 마이닝</h1>
<ul>
  <li>대규모 데이터 속에서 의미있는 정보를 파악해 의사결정에 활용하는 기법</li>
</ul>

<h2 id="데이터-마이닝-기법">데이터 마이닝 기법</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">분류 규칙 (Classification)</code> : 과거 데이터로부터 분류 모델을 만들어 이를 토대로 새로운 결과 값을 예측</li>
  <li><code class="language-plaintext highlighter-rouge">연관 규칙 (Association)</code> : 데이터 항목 간 종속 관계를 찾아냄 (ex. 넥타이 구매자는 셔츠도 같이 구매함)</li>
  <li><code class="language-plaintext highlighter-rouge">연속 규칙 (Sequence)</code> : 연관 규칙에 ‘시간’ 관련 정보가 포함된 기법</li>
  <li><code class="language-plaintext highlighter-rouge">데이터 군집화 (Clustering)</code> : 유사한 특성을 지닌 그룹으로 분류하되 정보가 없는 상태에서 분류</li>
</ol>

<h2 id="데이터-마이닝-종류">데이터 마이닝 종류</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">텍스트 마이닝</code> : 대량의 텍스트 속에서 의미있는 정보를 찾아내는 기법 (자연어, 문서 처리기술 적용)</li>
  <li><code class="language-plaintext highlighter-rouge">웹 마이닝</code> : 웹으로부터 얻는 방대한 정보 속에서 의미있는 정보를 찾아내는 기법 (데이터 마이닝 기술 응용)<br /><br /></li>
</ul>

<h1 id="빅데이터의-특성">빅데이터의 특성</h1>
<ol>
  <li><code class="language-plaintext highlighter-rouge">Volumn(양)</code> : PB 수준의 대규모 데이터</li>
  <li><code class="language-plaintext highlighter-rouge">Variety(다양성)</code> : 유형이 로그, 소셜, 위치 등 다양해짐</li>
  <li><code class="language-plaintext highlighter-rouge">Velocity(속도)</code> : 정보가 빠르게 증가하고 수집됨</li>
</ol>

<h2 id="빅데이터-수집-및-처리-기술">빅데이터 수집 및 처리 기술</h2>
<ol>
  <li>비정형 데이터 수집 (ex. 척화(Chuckwa), 플럼(Flume), 스크라이브(Scribe)</li>
  <li>정형 데이터 수집 (ex. 스쿱(Squoop), 하이호(Hiho), ETL, FTP</li>
  <li>분산 데이터 저장/처리 (ex. HDFS(하둡 분산 파일 시스템), 맵리듀스(구글이 발표)</li>
  <li>분산 데이터 베이스 (ex. HBase)</li>
</ol>

<h2 id="빅데이터-분석-및-처리-기술">빅데이터 분석 및 처리 기술</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">빅데이터 분석</code>
    <ul>
      <li>데이터 가공 : ex. 피그(Pig), 하이브(Hive),</li>
      <li>데이터 마이닝 : ex. 머하웃(Mahout)</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">빅데이터 실시간 처리</code>
    <ul>
      <li>실시간 SQL 처리 : ex. 임팔라(Impala)</li>
      <li>요청 작업의 워크플로우 관리 : ex. 우지(Oozie)</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">분산 코디네이션</code>
    <ul>
      <li>분산 처리 기술 : ex. 주키퍼(Zookeeper)</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">분석 및 시각화</code>
    <ul>
      <li>시각화 기술 : ex. R<br /><br /></li>
    </ul>
  </li>
</ol>

<h1 id="인터페이스연계-명세서">인터페이스(연계) 명세서</h1>
<ul>
  <li>연계에 필요한 항목을 명세화한 문서 구성요소
    <ol>
      <li>인터페이스 ID</li>
      <li>최대 처리 횟수</li>
      <li>데이터 크기 (평균/최대)</li>
      <li>시스템 정보 (송수신 각각) : 시스템명, 업무명, 연계방식 등</li>
      <li>데이터 정보 (송수신 각각) : 번호, 필드, 데이터 타입 등</li>
    </ol>
  </li>
</ul>

<h2 id="연계-요구사항-분석-시-참고-문서">연계 요구사항 분석 시 참고 문서</h2>
<ol>
  <li>코드 정의서</li>
  <li>테이블 정의서</li>
  <li>응용 프로그램 구성도 (화면 설계서, 사용자 인터페이스 정의서 등)</li>
  <li>시스템 구성도 (소프트웨어 구성도, 하드웨어 구성도, 네트워크 구성도 등)</li>
</ol>

<h2 id="연계-시스템의-구성">연계 시스템의 구성</h2>
<ol>
  <li>송신 시스템 : 연계할 데이터를 송신</li>
  <li>수신 시스템 : 수신한 데이터를 변환해 저장하고 활용하는 시스템</li>
  <li>중계 시스템 : 송신-수신 시스템 사이에서 송수신하고 모니터링하는 시스템</li>
</ol>

<h2 id="연계-데이터-표준화">연계 데이터 표준화</h2>
<ol>
  <li>인터페이스 데이터 공통부 : 표준 항목</li>
  <li>인터페이스 데이터 개별부 : 개별 데이터</li>
  <li>인터페이스 데이터 종료부 : 전송데이터의 끝을 알림</li>
</ol>

<h2 id="연계-매커니즘-수행-절차">연계 매커니즘 수행 절차</h2>
<ol>
  <li>연계 데이터 추출 및 생성</li>
  <li>코드 매핑 (데이터 변환)</li>
  <li>연계 테이블 또는 연계 파일 생성</li>
  <li>로그 기록</li>
  <li>연계 서버 또는 송수신 어댑터</li>
  <li>전송</li>
  <li>수신된 데이터 DB에 반영</li>
</ol>

<h2 id="연계-매커니즘-종류">연계 매커니즘 종류</h2>
<h3 id="직접-연계">직접 연계</h3>
<ul>
  <li>장점 : 구현이 쉽고 개발 기간이 짧음</li>
  <li>단점 : 결합도가 높음</li>
  <li>종류
    <ul>
      <li>DB Link : 수신 시스템에서 DB 링크를 생성하고 송신 시스템에서 해당 링크를 참조하는 방식</li>
      <li>DB Connection : DB Connection Pool을 생성하고 해당 풀 명을 이용하여 연결하는 방식
        <ul>
          <li>커넥션 풀 : DB와 연결된 커넥션을 미리 만들어 풀 속에 저장하고, 필요할 때마다 쓰고 반환하는 기법</li>
        </ul>
      </li>
      <li>API : 데이터를 주고 받을 때 어떤 방식으로 요청하고 제공받을 수 있는지, 규격을 정해 놓은 인터페이스</li>
      <li>JDBC : JDBC 드라이버를 이용해 송신 시스템의 DB와 연결하는 방식
        <ul>
          <li>JDBC : 자바에서 데이터베이스에 접속할 수 있게 해주는 API</li>
          <li>JDBC 드라이버의 구성 : Java Application - JDBC API - JDBC Driver Manager - JDBC Driver</li>
        </ul>
      </li>
      <li>하이퍼링크 : 현재 페이지에서 다른 부분 또는 다른 페이지로 이동하게 해주는 속성</li>
    </ul>
  </li>
</ul>

<h3 id="간접-연계">간접 연계</h3>
<ul>
  <li>장점 : 서로 상이한 네트워크, 프로토콜 연계 가능</li>
  <li>단점 : 성능 저하, 개발 비용 높음</li>
  <li>종류
    <ul>
      <li>EAI : 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션 간 <code class="language-plaintext highlighter-rouge">연계</code>를 돕는 솔루션
        <ul>
          <li>구성요소
            <ul>
              <li>EAI 플랫폼</li>
              <li>어댑터 : EAI의 핵심장치. 애플리케이션을 연결하는 데이터 입출력 도구</li>
              <li>브로커 : 데이터 전송 시 포맷과 코드를 변환해 줌</li>
              <li>메시지 큐 : 비동기 메시지를 사용하는 프로그램 사이에서 송수신 해 주는 기술</li>
              <li>비즈니스 워크플로우 : 미리 정의된 워크플로우에 따라 업무 처리</li>
            </ul>
          </li>
          <li>유형
            <ul>
              <li>Point-to-Point : 가장 기초적인 1:1 단순 통합방법</li>
              <li>Hub &amp; Spoke : 허브 시스템을 통한 중앙 집중 방식</li>
              <li>Message Bus : 애플리케이션 사이에 미들웨어(버스)를 두어 연계</li>
              <li>Hybrid : 그룹 내 = Hub &amp; Spoke 그룹 간 = Message Bus</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>ESB : 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션을 하나의 시스템으로 관리할 수 있게 하는 아키텍처로, 미들웨어(버스)를 중심으로 애플리케이션 <code class="language-plaintext highlighter-rouge">통합</code>을 ‘느슨한 결합’ 방식으로 지원</li>
      <li>
        <p>Socket : 프로세스 간 통신의 접속점(IP 주소 + 포트넘버) 클라이언트 요청을 서버와 연결해 줌</p>
      </li>
      <li><code class="language-plaintext highlighter-rouge">EAI</code>는 연계! <code class="language-plaintext highlighter-rouge">ESB</code>는 통합!</li>
    </ul>
  </li>
</ul>

<h2 id="인터페이스-기능-구현">인터페이스 기능 구현</h2>
<ol>
  <li>대상자 선택(대상이 될 데이터를 SQL로 선택)</li>
  <li>인터페이스 데이터 생성(JSON 등 형식에 맞게 가공)</li>
  <li>인터페이스 데이터 전송 요청</li>
  <li>인터페이스 데이터 전송</li>
  <li>인터페이스 데이터 수신</li>
  <li>인터페이스 데이터 파싱</li>
  <li>인터페이스 데이터 검증(포맷 및 제약조건 오류 검사)</li>
  <li>후속 기능 수행(수신 시스템에 정의된 후속 기능 진행)</li>
  <li>수신 결과 생성 및 전송<br />
10.수신 측의 처리 결과 반환 <br /><br /></li>
</ol>

<h1 id="웹-서비스-방식">웹 서비스 방식</h1>
<ol>
  <li><code class="language-plaintext highlighter-rouge">SOAP</code> : HTTP, HTTPS 등을 사용해 XML 기반의 메시지를 교환하는 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">WSDL</code> : Web Service Description Language. 웹 서비스명, 제공위치 등 웹 서비스의 정보가 기술된 XML 형식의 언어</li>
  <li><code class="language-plaintext highlighter-rouge">UDDI</code> : WSDL의 등록, 검색을 위한 저장소 (공개적으로 접근 가능한 레지스트리)</li>
</ol>

<ul>
  <li>XML 프로토콜이면 <code class="language-plaintext highlighter-rouge">SOAP</code>, 언어면 <code class="language-plaintext highlighter-rouge">WSDL</code><br /><br /></li>
</ul>

<h1 id="json">JSON</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">키-값</code> 쌍으로 이루어진 데이터를 전달하기 위해 인간이 읽을 수 있는 텍스트를 사용한 포맷(AJAX에서 많이 사용)</li>
</ul>

<h2 id="json의-표현-자료형">JSON의 표현 자료형</h2>
<ol>
  <li>숫자</li>
  <li>문자열(항상 “” 따옴표 사용)</li>
  <li>배열(대괄호 [] 표시)</li>
  <li>객체(중괄호 {} 로 표시하며, 이름은 문자열을 쓴다)<br /><br /></li>
</ol>

<h1 id="xml">XML</h1>
<ul>
  <li>HTML의 단점을 보완하여, 특수한 목적을 갖는 마크업 언어</li>
</ul>

<h2 id="xml의-특징">XML의 특징</h2>
<ul>
  <li>트리 구조이며 모든 태그에는 종료 태그가 필수</li>
  <li>속성값은 큰 따옴표(“)로 묶고 대소문자를 구분함<br /><br /></li>
</ul>

<h1 id="ajax">AJAX</h1>
<ul>
  <li>서버-클라이언트 간 비동기적으로 데이터를 교환하기 위한 기술</li>
</ul>

<h2 id="ajax의-동작-원리">AJAX의 동작 원리</h2>
<ol>
  <li>요청 이벤트 발생</li>
  <li>자바스크립트 호출</li>
  <li>자바스크립트가 XMLHttpRequest 객체를 사용해 서버에 요청 (비동기이므로 그동안 다른 일 처리)</li>
  <li>서버는 XMLHttpRequest 객체를 가지고 AJAX 요청 처리</li>
  <li>전달받은 데이터를 사용해 웹 페이지 일부만을 갱신하는 자바스크립트 호출</li>
</ol>

<h2 id="ajax의-주요기술">AJAX의 주요기술</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">XMLHttpRequest</code> : 비동기 통신을 담당하는 자바스크립트 객체</li>
  <li><code class="language-plaintext highlighter-rouge">XML</code> : HTML의 단점을 보완하여, 특수한 목적을 갖는 마크업 언어</li>
  <li><code class="language-plaintext highlighter-rouge">DOM</code> : XML 문서를 트리 구조 형태로 접근하게 해주는 API</li>
  <li><code class="language-plaintext highlighter-rouge">XSLT(eXtensible Stylesheet Language Transformations)</code> : XML 문서를 다른 XML 문서로 변환하는 데 사용하는 언어</li>
  <li><code class="language-plaintext highlighter-rouge">HTML</code> : 웹 문서를 표현하는 마크업 언어</li>
  <li><code class="language-plaintext highlighter-rouge">CSS</code> : 마크업 언어가 표시되는 방법을 기술하는 언어<br /><br /></li>
</ul>

<h1 id="rest">REST</h1>
<ul>
  <li>HTTP URI로 자원을 표시하고, HTTP 메서드를 통해 해당 자원에 대한 삽입, 삭제, 갱신 등의 명령을 적용하는 아키텍처</li>
</ul>

<h2 id="rest-메서드의-종류">REST 메서드의 종류</h2>
<ol>
  <li>POST (Create)</li>
  <li>GET (Read)</li>
  <li>PUT (Update)</li>
  <li>DELETE (Delete)</li>
</ol>

<h2 id="rest의-구성">REST의 구성</h2>
<ol>
  <li>리소스</li>
  <li>메서드</li>
  <li>메시지<br /><br /></li>
</ol>

<h1 id="db-암호화-기법">DB 암호화 기법</h1>
<ol>
  <li><code class="language-plaintext highlighter-rouge">API 방식</code> : 애플리케이션 서버에 암호 모듈 적용(애플리케이션 서버에 부하 발생)</li>
  <li><code class="language-plaintext highlighter-rouge">플러그인 방식</code> : DB 서버에 암호 모듈 적용(DB 서버에 부하 발생)</li>
  <li><code class="language-plaintext highlighter-rouge">TDE 방식</code> : DBMS 커널이 자체적으로 암호화 기능 수행 (Transparent Data Encryption)</li>
  <li><code class="language-plaintext highlighter-rouge">하이브리드 방식</code> : API + 플러그인 (부하 분산)<br /><br /></li>
</ol>

<h1 id="인터페이스-구현-검증-도구">인터페이스 구현 검증 도구</h1>
<ol>
  <li><code class="language-plaintext highlighter-rouge">xUnit</code> : Java, C++ 등 다양한 언어를 지원하는 단위 테스트 프레임워크</li>
  <li><code class="language-plaintext highlighter-rouge">STAF</code> : 각 테스트 대상 분산 환경에 ‘데몬’을 사용하여 테스트를 수행</li>
  <li><code class="language-plaintext highlighter-rouge">FitNesse</code> : 웹 기반 테스트 케이스를 지원</li>
  <li><code class="language-plaintext highlighter-rouge">NTAF</code> : STAF(재사용 및 확장성) + FitNesse(협업 기능) 장점을 통합한 NHN의 프레임워크</li>
  <li><code class="language-plaintext highlighter-rouge">Selenium</code> : 다양한 브라우저와 개발 언어를 지원하는 웹 애플리케이션 테스트 프레임워크</li>
  <li><code class="language-plaintext highlighter-rouge">Watir</code> : 루비 기반의 웹 애플리케이션 테스트 프레임워크</li>
</ol>

<h2 id="인터페이스-감시-도구">인터페이스 감시 도구</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">스카우터</code> : 애플리케이션 및 DB 모니터링 가능한 감시 도구</li>
  <li><code class="language-plaintext highlighter-rouge">제니퍼</code> : 개발부터 운영에 이르기까지 전 생애주기 동안 모니터링 가능한 감시 도구</li>
</ol>

<h2 id="오류-처리-방법">오류 처리 방법</h2>
<ol>
  <li>화면에서 오류를 인지하도록 구현</li>
  <li>오류 로그 생성</li>
  <li>관련 테이블에 오류 사항 기록<br /><br /></li>
</ol>

<h1 id="프로그래밍-언어-분류실행방식에-따라">프로그래밍 언어 분류(실행방식에 따라)</h1>
<ol>
  <li>명령형 언어(= 절차형 언어) : 명령들이 순차적으로 실행되는 방식
    <ul>
      <li>ex. FORTRAN, COBOL, PASCAL, C, ALGOL, BASIC</li>
    </ul>
  </li>
  <li>객체지향 언어 : 객체 간 메시지 통신을 이용하는 방식
    <ul>
      <li>ex. 자바, C++</li>
    </ul>
  </li>
  <li>함수형 언어 : 수학수식과 같은 함수들로 프로그램을 구성하여 호출하는 방식
    <ul>
      <li>ex. 리스프(LISP), 하스켈(Haskell)</li>
    </ul>
  </li>
  <li>논리형 언어 : 논리 문장을 이용하여 표현하는 방식
    <ul>
      <li>ex. 프롤로그(Prolog)</li>
    </ul>
  </li>
  <li>스크립트 언어
    <ul>
      <li>PHP : 동적 웹페이지를 위한 언어</li>
      <li>Perl : 실용성 모토, 인터프리터</li>
      <li>Python, JavaScript</li>
    </ul>
  </li>
  <li>선언형 언어
    <ul>
      <li>함수형 언어</li>
      <li>논리형 언어</li>
      <li>특수분야 언어 : SQL(DBMS 관리를 위한 질의어)</li>
    </ul>
  </li>
</ol>

<h2 id="프로그래밍-구현-기법">프로그래밍 구현 기법</h2>
<ol>
  <li>컴파일 방식 : 고급 언어 -&gt; 기계어로 번역
    <ul>
      <li>ex. FORTRAN, PASCAL, C, C++</li>
    </ul>
  </li>
  <li>인터프리터 방식 : 명령문을 하나씩 번역하고 실행하는 방식
    <ul>
      <li>ex. BASIC, LISP, PHP, Perl, Prolog</li>
    </ul>
  </li>
  <li>혼합형 방식 : 고급 언어를 컴파일하여 중간 언어로 변환 후 인터프리터가 번역을 실행하는 방식
    <ul>
      <li>ex. 자바</li>
    </ul>
  </li>
</ol>

<h2 id="절차적-프로그래밍">절차적 프로그래밍</h2>
<ol>
  <li>FORTRAN : 과학 기술 전문 언어로, 고급 수학 함수들 사용 가능(컴파일 방식)</li>
  <li>C : 유닉스 운영체제에서 사용하기 위한 언어(컴파일 방식)</li>
  <li>알골 : 알고리즘 연구개발 목적</li>
  <li>베이직 : 교육용으로 개발된 언어(인터프리터 방식)</li>
</ol>

<h2 id="객체지향-프로그래밍">객체지향 프로그래밍</h2>
<ol>
  <li>C++ : C 언어에 객체지향 프로그래밍 개념 추가(컴파일 방식)</li>
  <li>C# : MS에서 개발. 불안전 코드(Unsafe Code) 같은 기술을 통해 상호 운용성 확보</li>
  <li>자바 : 웹 애플리케이션 개발에 가장 많이 사용되는 언어</li>
  <li>델파이 : 파스칼 문법 + 여러 기능. Windows 아래에서 모든 부분 프로그래밍 가능</li>
</ol>

<h3 id="객체지향-프로그래밍의-구성요소">객체지향 프로그래밍의 구성요소</h3>
<ol>
  <li>객체 : 개체 + 속성 + 메서드로 이루어진 인스턴스</li>
  <li>클래스 : 객체를 표현하는 추상 데이터 타입</li>
  <li>메서드 : 객체 간 통신<br /><br /></li>
</ol>

<h1 id="파이썬-자료형">파이썬 자료형</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">List</code> : 순서 있는 배열
    <ul>
      <li>값 맨 뒤에 삽입 : <code class="language-plaintext highlighter-rouge">append(value)</code></li>
      <li>중간에 삽입 : <code class="language-plaintext highlighter-rouge">insert(index, value)</code></li>
      <li>삭제 : <code class="language-plaintext highlighter-rouge">remove(value)</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Dictionary</code> : 키-값 쌍
    <ul>
      <li>값 참조 : <code class="language-plaintext highlighter-rouge">딕셔너리이름[키] = 값</code></li>
      <li>값 삭제 : <code class="language-plaintext highlighter-rouge">del 딕셔너리이름[키]</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Set</code> : 중복 허용 X, 순서 없음
    <ul>
      <li>값 추가 : <code class="language-plaintext highlighter-rouge">add(value)</code></li>
      <li>값 삭제 : <code class="language-plaintext highlighter-rouge">remove(value)</code><br /><br /></li>
    </ul>
  </li>
</ul>

<h1 id="자바-자료형">자바 자료형</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">HashMap</code> : 키-값 쌍
    <ul>
      <li>값 추가 : <code class="language-plaintext highlighter-rouge">put(key, value)</code></li>
      <li>값 삭제 : <code class="language-plaintext highlighter-rouge">remove(key)</code></li>
      <li>값 얻기 : <code class="language-plaintext highlighter-rouge">get(key)</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">ArrayList</code> : 순서 있는 배열
    <ul>
      <li>값 맨 뒤에 추가 : <code class="language-plaintext highlighter-rouge">add(value)</code></li>
      <li>값 중간에 삽입 : <code class="language-plaintext highlighter-rouge">add(index, value)</code></li>
      <li>값 삭제 : <code class="language-plaintext highlighter-rouge">remove(index)</code></li>
      <li>인덱스 값 참조 : <code class="language-plaintext highlighter-rouge">get(index)</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">HashSet</code> : 중복 허용 X, 순서 없음
    <ul>
      <li>값 추가 : <code class="language-plaintext highlighter-rouge">add(value)</code></li>
      <li>값 제거 : <code class="language-plaintext highlighter-rouge">remove(value)</code><br /><br /></li>
    </ul>
  </li>
</ul>

<h1 id="라이브러리">라이브러리</h1>
<ul>
  <li>효율적인 개발을 위해 필요한 프로그램들을 모은 집합체(모듈과 패키지를 총칭)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">모듈</code> : 변수, 함수 등을 모아둔 파일</li>
      <li><code class="language-plaintext highlighter-rouge">패키지</code> : 모듈을 구조화한 라이브러리</li>
    </ul>
  </li>
</ul>

<h2 id="라이브러리-구성">라이브러리 구성</h2>
<ol>
  <li>도움말</li>
  <li>설치 파일</li>
  <li>샘플 코드<br /><br /></li>
</ol>

<h1 id="클래스-관련-용어">클래스 관련 용어</h1>
<h2 id="인터페이스">인터페이스</h2>
<ul>
  <li>자바에서 다향성을 극대화하기 위한 문법으로 추상 메서드와 상수만을 멤버로 갖는다.</li>
</ul>

<h2 id="추상-클래스">추상 클래스</h2>
<ul>
  <li>자식 클래스에서 상위 클래스의 미구현 추상 메서드를 구현하는 것</li>
</ul>

<h2 id="추상-클래스-구현">추상 클래스 구현</h2>
<ul>
  <li>C++ : 메서드 뒤에 <code class="language-plaintext highlighter-rouge">= 0</code> 붙임</li>
  <li>자바 : 클래스명과 메서드명 앞에 <code class="language-plaintext highlighter-rouge">abstract</code> 붙임</li>
  <li>파이썬 : 메서드 내부에 <code class="language-plaintext highlighter-rouge">pass</code> 키워드 사용</li>
</ul>

<h2 id="상위-클래스-접근">상위 클래스 접근</h2>
<ul>
  <li>C++ : 부모클래스::메서드명()</li>
  <li>자바 : super.메서드명()</li>
  <li>파이썬 : super().메서드명()</li>
</ul>

<h2 id="오버로딩">오버로딩</h2>
<ul>
  <li>같은 이름의 메서드를 매개변수만 다르게 하여 여러 개 정의하는 것</li>
</ul>

<h2 id="오버라이딩">오버라이딩</h2>
<ul>
  <li>하위 클래스에서 상위 클래스 메서드를 재정의하는 것. C++은 <code class="language-plaintext highlighter-rouge">virtual</code> 키워드 필요</li>
</ul>

<h2 id="상속">상속</h2>
<ul>
  <li>어떤 객체의 변수와 메서드를 다른 객체가 물려받는 것</li>
</ul>

<h3 id="상속-문법">상속 문법</h3>
<ul>
  <li>C++ : <code class="language-plaintext highlighter-rouge">class 자식클래스 : public 부모클래스 {}</code></li>
  <li>자바 : <code class="language-plaintext highlighter-rouge">class 자식클래스 extends 부모클래스 {}</code></li>
  <li>파이썬 : <code class="language-plaintext highlighter-rouge">class 자식클래스 (부모클래스):</code></li>
</ul>

<h2 id="생성자">생성자</h2>
<ul>
  <li>해달 클래스의 객체가 생성될 때 자동으로 호출되는 메서드</li>
  <li>C++, 자바 : 클래스명과 동일하면 생성자</li>
  <li>파이썬 : <code class="language-plaintext highlighter-rouge">__int__</code> 메서드명 사용하면 생성자</li>
</ul>

<h2 id="소멸자">소멸자</h2>
<ul>
  <li>객체가 소멸될 때 호출되는 메서드. 할당된 메모리를 해제하는 용도로 사용됨</li>
  <li>C++ : 클래스명과 동일하나 클래스명 앞에 <code class="language-plaintext highlighter-rouge">~</code> 기호를 붙이면 소멸자</li>
  <li>자바 : <code class="language-plaintext highlighter-rouge">finalize</code> 메서드명을 사용하면 소멸자</li>
  <li>파이썬 : <code class="language-plaintext highlighter-rouge">__del__</code> 메서드명 사용하면 소멸자</li>
</ul>

<h2 id="자신-클래스-참조">자신 클래스 참조</h2>
<ul>
  <li>C++, 자바는 <code class="language-plaintext highlighter-rouge">this-&gt;</code>, <code class="language-plaintext highlighter-rouge">this.</code></li>
  <li>파이썬은 <code class="language-plaintext highlighter-rouge">self.</code></li>
</ul>

<h2 id="구조체">구조체</h2>
<ul>
  <li>기본 타입을 이용해 새롭게 정의하는 자료형</li>
  <li>C/C++ 한정 <code class="language-plaintext highlighter-rouge">struct</code>로 선언 후 사용</li>
</ul>

<h2 id="열거체">열거체</h2>
<ul>
  <li>정수형 상수에 이름을 붙여 쓰기 편하게 만드는 것</li>
</ul>

<h2 id="포맷-스트링">포맷 스트링</h2>
<ul>
  <li>%c : 문자</li>
  <li>%s : 문자열</li>
  <li>%d : 10진수</li>
  <li>%x : 16진수</li>
  <li>%o : 8진수</li>
  <li>%f : 실수(6자리까지)</li>
</ul>

<h2 id="비트-연산자">비트 연산자</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">&amp;</code> : 같은 비트 값이 모두 1이면 1 - AND</li>
  <li><code class="language-plaintext highlighter-rouge">|</code> : 같은 비트 중 하나라도 1이면 1 - OR</li>
  <li><code class="language-plaintext highlighter-rouge">^</code> : 같은 비트값이 서로 다르면 1 - XOR</li>
  <li><code class="language-plaintext highlighter-rouge">~</code> : 모든 비트값을 반대로 뒤집음 - NOT</li>
</ul>

<h2 id="시프트-연산자">시프트 연산자</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;&lt;</code> 왼쪽으로 비트 이동 : * 2 효과가 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">&gt;&gt;</code> 오른쪽으로 비트 이동 : / 2 효과</li>
</ul>

<h2 id="식별자-표기법">식별자 표기법</h2>
<ul>
  <li>헝가리안 표기법 : 식별자 앞에 자료형을 붙이는 표기법</li>
  <li>스네이크 표기법 : 식별자에 여러 단어가 이어질 때 각 단어 사이에 언더바를 넣는 표기법</li>
  <li>카멜 표기법 : 식별자에 여러 단어가 이어질 때 첫 단어의 시작만 소문자로, 각 단어의 첫 글자는 대문자로 쓰는 표기법</li>
  <li>파스칼 표기법 : 식별자에 여러 단어가 이어질 때 각 단어의 첫 글자는 대문자로 쓰는 표기법</li>
</ul>

<h2 id="리스트-인덱스">리스트 인덱스</h2>
<ul>
  <li>[0] [1] … [n-2] [n-1] [-n] [-(n-1)] [-2] [-1]</li>
</ul>

<h2 id="리스트-슬라이싱">리스트 슬라이싱</h2>
<ol>
  <li>시작 인덱스 : 생략 시 처음부터</li>
  <li>종료 인덱스 : <code class="language-plaintext highlighter-rouge">종료 인덱스 전</code> 까지만 슬라이싱하며 <code class="language-plaintext highlighter-rouge">생략 시 마지막까지</code></li>
  <li>스텝 : 생략 시 1</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">[:</span><span class="mi">4</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
</code></pre></div></div>

<ul>
  <li>출력 : [7,3]</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="s">"Hello Phython"</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<ul>
  <li>출력 : Heltho<br /><br /></li>
</ul>

<h1 id="트랜잭션">트랜잭션</h1>
<ul>
  <li>DB 시스템에서 하나의 논리적 기능을 정상적으로 수행하기 위한 작업 단위 (특성 : <code class="language-plaintext highlighter-rouge">ACID</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">원자성(Atomicity)</code> : All or Nothing. 연산 전체는 성공 또는 실패여야 하며, 하나라도 실패할 경우 전체가 취소되어야 하는 특성</li>
  <li><code class="language-plaintext highlighter-rouge">일관성(Consistency)</code> : 트랜잭션이 성공적으로 실행되면, DB는 일관된 상태를 유지해야 하는 특성 (기법 : 병행(동시성) 제어)</li>
  <li><code class="language-plaintext highlighter-rouge">격리성(Isolation)(독립성)</code> : 트랜잭션 실행 중 중간 연산 결과에 다른 트랜잭션이 접근할 수 없다. (기법 : 고립화 수준)</li>
  <li><code class="language-plaintext highlighter-rouge">영속성(Durability)(지속성)</code> : 성공적으로 완료된 트랜잭션 결과는 DB에 영속적으로 저장되어야 한다. (기법 : 회복기법)</li>
</ul>

<h2 id="트랜잭션의-상태-변환">트랜잭션의 상태 변환</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">활동상태(Active)</code> : 트랜잭션 실행 중</li>
  <li><code class="language-plaintext highlighter-rouge">부분 완료 상태(Partially Committed)</code> : 마지막 명령문 실행 상태</li>
  <li><code class="language-plaintext highlighter-rouge">완료 상태(Committed)</code> : 성공적으로 완료</li>
  <li><code class="language-plaintext highlighter-rouge">실패 상태(Failed)</code> : 정상적 실행 불가</li>
  <li><code class="language-plaintext highlighter-rouge">철회 상태(Aborted)</code> : 트랜잭션 취소</li>
</ol>

<h2 id="tcl">TCL</h2>
<ul>
  <li>트랜잭션 제어 언어</li>
  <li>트랜잭션 결과를 허용하거나 취소하기 위한 제어 언어</li>
  <li><code class="language-plaintext highlighter-rouge">COMMIT</code>, <code class="language-plaintext highlighter-rouge">ROLLBACK</code>, <code class="language-plaintext highlighter-rouge">CHECKPOINT</code></li>
</ul>

<h2 id="병행제어">병행제어</h2>
<ul>
  <li>다수 사용자 환경에서 일관성 유지를 위해 제어하는 기법</li>
</ul>

<h3 id="병행제어-미보장-문제점">병행제어 미보장 문제점</h3>
<ul>
  <li>갱현모연</li>
  <li>갱신손실(Lost Update)</li>
  <li>현황파악오류(Dirty Read)</li>
  <li>모순성(Inconsistency)</li>
  <li>연쇄복귀(Cascading Rollback)</li>
</ul>

<h3 id="병행제어-기법">병행제어 기법</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">로킹(Locking)</code> : 트랜잭션의 순차적 진행을 보장하는 기법
    <ul>
      <li><code class="language-plaintext highlighter-rouge">로킹단위</code> : 한 번에 로킹할 수 있는 객체 크기</li>
      <li>로킹단위가 작을수록 DB 공유도는 증가하지만 로킹 오버헤드 증가</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">낙관적 검증 기법(Validation)</code> : 일단 검증 없이 진행 후, 종료한 다음 검증을 수행해 반영</li>
  <li><code class="language-plaintext highlighter-rouge">타임 스탬프 순서(Time Stamp Ordering)</code> : 트랜잭션이나 데이터에 타임 스탬프를 부여하여, 그 시간에 따라 작업을 수행</li>
  <li><code class="language-plaintext highlighter-rouge">다중버전 동시성 제어(MVCC; Multi Version Concurrency Control)</code> : 트랜잭션의 타임스탬프와 접근하려는 데이터의 타임스탬프를 비교해, 적절한 버전을 선택하여 접근하도록 하는 기법</li>
</ol>

<h2 id="고립화">고립화</h2>
<ul>
  <li>무결성을 해치지 않기 위해 잠금을 설정하는 정도</li>
</ul>

<h3 id="고립화-수준-종류">고립화 수준 종류</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">Read Uncommitted</code> : 연산 중인 데이터를 다른 트랜잭션이 읽는 것을 허용</li>
  <li><code class="language-plaintext highlighter-rouge">Read Committed</code> : 연산이 완료되기 전까지 다른 트랜잭션이 읽는 것을 제한</li>
  <li><code class="language-plaintext highlighter-rouge">Repetable Read</code> : 선행 트랜잭션이 특정 데이터를 읽을 때, 해당 데이터의 갱신/삭제를 제한</li>
  <li><code class="language-plaintext highlighter-rouge">Serializable Read</code> : 선행 트랜잭션이 특정 데이터 영역을 읽을 때, 해당 영역 전체의 접근을 제한</li>
</ol>

<h2 id="회복-기법">회복 기법</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">로그 기반 회복 기법</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">지연 갱신 회복 기법</code> : 트랜잭션 완료 전에는 로그에만 기록. 장애 발생 시 로그를 폐기</li>
      <li><code class="language-plaintext highlighter-rouge">즉각 갱신 회복 기법</code> : 트랜잭션 갱신 결과를 바로 DB에 반영. 장애 발생 시 로그를 참고하여 되돌림</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">체크포인트 회복 기법</code> : 체크포인트 이전으로 복원</li>
  <li><code class="language-plaintext highlighter-rouge">그림자 페이징 회복 기법</code> : 트랜잭션 수행 시 복제본을 생성해 이를 이용해 복구</li>
</ol>

<h2 id="sql-문법">SQL 문법</h2>
<ol>
  <li>DDL(정의어) : <code class="language-plaintext highlighter-rouge">Create, Alter, Drop, Truncate</code></li>
  <li>DML(조작어) : <code class="language-plaintext highlighter-rouge">Select, Insert, Update, Delete</code></li>
  <li>DCL(제어어) : <code class="language-plaintext highlighter-rouge">Grant, Revoke</code></li>
</ol>

<h2 id="도메인">도메인</h2>
<ul>
  <li>하나의 속성이 가질 수 있는 원자값의 집합</li>
</ul>

<h2 id="스키마">스키마</h2>
<ul>
  <li>DB의 구조, 제약조건 등의 정보를 담고 있는 구조</li>
</ul>

<h3 id="스키마-3계층">스키마 3계층</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">외부 스키마</code> : 사용자(개발자) 관점에서의 구조. 사용자 뷰를 나타냄</li>
  <li><code class="language-plaintext highlighter-rouge">개념 스키마</code> : 제약조건, 권한, 보안 등 전체적인 논리 구조</li>
  <li><code class="language-plaintext highlighter-rouge">내부 스키마</code> : 물리적 저장장치 관점에서의 구조. 레코드 형식, 물리적 순서 등</li>
</ol>

<h2 id="테이블-관련-용어">테이블 관련 용어</h2>
<ul>
  <li>테이블 : 데이터를 저장하는 공간 (=릴레이션, =엔터티)</li>
  <li>튜플 : =Row. =레코드. 한 릴레이션에서 중복되는 튜플은 존재 불가</li>
  <li>카디널리티 : 튜플의 개수</li>
  <li>애트리뷰트 : =Column</li>
  <li>디그리 : 애트리뷰트의 개수</li>
</ul>

<h2 id="테이블-관리-명령어">테이블 관리 명령어</h2>
<ul>
  <li>테이블 생성 : CREATE TABLE 테이블명 (컬럼명 데이터타입 [제약조건]);</li>
  <li>테이블 생성 제약조건
    <ul>
      <li>PRIMARY KEY</li>
      <li>FOREIGN KEY REFERENCES 테이블(컬럼)</li>
      <li>NOT NULL</li>
      <li>UNIQUE</li>
      <li>CHECK (조건 OR 조건)</li>
      <li>DEFAULT</li>
    </ul>
  </li>
  <li>테이블 변경
    <ul>
      <li>ALTER TABLE 테이블명 ADD 컬럼명 데이터타입 [제약조건];</li>
      <li>ALTER TABLE 테이블명 MODIFY 컬럼명 데이터타입 [제약조건];</li>
      <li>ALTER TABLE 테이블명 DROP 컬럼명;</li>
    </ul>
  </li>
  <li>테이블 삭제
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>DROP TABLE 테이블명 [CASCADE</td>
              <td>RESTRICT];</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>TRUNCATE TABLE 테이블명;</li>
    </ul>
  </li>
</ul>

<h2 id="뷰">뷰</h2>
<ul>
  <li>데이터의 독립성을 보장하고 조작 연산을 간소화할 수 있는 논리 테이블</li>
  <li>ALTER로 변경 불가</li>
  <li>자체 인덱스 불가</li>
</ul>

<h3 id="뷰-속성">뷰 속성</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">REPLACE</code> : 기존 테이블 존재 시 재생성</li>
  <li><code class="language-plaintext highlighter-rouge">FORCE</code> : 기본 테이블 관계 없이 뷰 생성</li>
  <li><code class="language-plaintext highlighter-rouge">NO FORCE</code> : 기본 테이블이 있을 때만 뷰 생성</li>
  <li><code class="language-plaintext highlighter-rouge">WITH CHECK OPTION</code> : 서브 쿼리 내 조건을 만족하는 행만 변경</li>
  <li><code class="language-plaintext highlighter-rouge">WITH READ ONLY</code> : DML(조작어) 불가</li>
</ul>

<h3 id="뷰-관리-명령어">뷰 관리 명령어</h3>
<ul>
  <li>뷰 생성 : CREATE [OR REPLACE] VIEW 뷰이름 AS SELECT 이름 FROM 학생 WHERE 성별 = ‘F’;</li>
  <li>뷰 삭제 : DROP VIEW 이름;</li>
</ul>

<h2 id="인덱스">인덱스</h2>
<ul>
  <li>DB 시스템에서 빠른 검색을 위한 데이터 구조</li>
  <li>인덱스가 없으면 Table Full Scan을 하지만, 인덱스가 있으면 Index Range Scan을 하므로 검색 속도가 빠르다.</li>
</ul>

<h3 id="인덱스-관리-명령어">인덱스 관리 명령어</h3>
<ul>
  <li>인덱스 생성 : CREATE INDEX 인덱스명 ON 테이블(컬럼);</li>
  <li>인덱스 변경 : ALTER INDEX 인덱스명 ON 테이블(컬럼);</li>
  <li>인덱스 삭제 : DROP INDEX 인덱스명;</li>
</ul>

<h3 id="인덱스-종류">인덱스 종류</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">비트맵 인덱스</code> : 컬럼 개수가 적고 수정이 적을수록 좋은 인덱스(생년월일, 상품번호 등)</li>
  <li><code class="language-plaintext highlighter-rouge">단일 인덱스</code> : 하나의 컬럼으로만 구성된 인덱스</li>
  <li><code class="language-plaintext highlighter-rouge">순서 인덱스</code> : 데이터가 정렬된 순서로 생성되는 인덱스</li>
  <li><code class="language-plaintext highlighter-rouge">함수기반 인덱스</code> : 함수를 적용해 만든 인덱스</li>
  <li><code class="language-plaintext highlighter-rouge">해시 인덱스</code> : 해시 함수를 통해 키 값으로 데이터에 접근하는 인덱스(튜플 양에 무관하게 접근 비용 동일함)</li>
  <li><code class="language-plaintext highlighter-rouge">결합 인덱스</code> : 두 개 이상의 컬럼으로 구성된 인덱스</li>
  <li><code class="language-plaintext highlighter-rouge">클러스터드 인덱스</code> : PK 기준으로 레코드를 묶어 데이터의 물리적 순서에 따라 생성된 인덱스</li>
</ol>

<h3 id="인덱스-컬럼-선정">인덱스 컬럼 선정</h3>
<ul>
  <li>적정 분포도 : 10-15%
    <ul>
      <li>분포도 : 특정 컬럼 값이 테이블에 평균적으로 분포된 정도</li>
    </ul>
  </li>
  <li>수정이 빈번하지 않은 컬럼이 분포도가 좋은 컬럼 - 단일 인덱스</li>
  <li>자주 결합되는 컬럼 - 결합 인덱스</li>
</ul>

<h3 id="인덱스-스캔-방식">인덱스 스캔 방식</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">인덱스 범위 스캔</code> : ⬇️➡️ 루트 블록에서 리프 블록까지 수직 탐색 후, 리프 블록을 수평 탐색</li>
  <li><code class="language-plaintext highlighter-rouge">인덱스 전체 스캔</code> : ➡️➡️ 리프 블록을 처음부터 끝까지 수평 탐색</li>
  <li><code class="language-plaintext highlighter-rouge">인덱스 단일 스캔</code> : ⬇️⬇️ 수직 탐색으로만 스캔</li>
  <li><code class="language-plaintext highlighter-rouge">인덱스 생략 스캔</code> : 선두 컬럼이 조건 절에 없더라도 인덱스를 활용하는 스캔 (필요없는 부분은 과감히 스킵)</li>
</ol>

<h2 id="클러스터링">클러스터링</h2>
<ul>
  <li>검색 속도 향상을 위해 물리적으로 저장하는 것</li>
  <li>분포도가 넓을 수록(=좋지 않을 수록) 클러스터링이 적합</li>
</ul>

<h2 id="파티셔닝">파티셔닝</h2>
<ul>
  <li>테이블을 논리적 단위로 쪼개는 것</li>
</ul>

<h3 id="파티셔닝-유형">파티셔닝 유형</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">레인지 파티셔닝</code> : 숫자나 날짜와 같은 범위 기준으로 파티셔닝</li>
  <li><code class="language-plaintext highlighter-rouge">해시 파티셔닝</code> : 해시 함수의 값을 기준으로 파티셔닝(균등 분할 가능)</li>
  <li><code class="language-plaintext highlighter-rouge">리스트 파티셔닝</code> : 값 목록을 기준으로 파티셔닝</li>
  <li><code class="language-plaintext highlighter-rouge">컴포지트 파티셔닝</code> : 2개 이상의 파티셔닝을 결합</li>
</ol>

<h3 id="파티셔닝-장점">파티셔닝 장점</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">성능 향상</code> : 액세스 범위가 줄어드니까</li>
  <li><code class="language-plaintext highlighter-rouge">가용성 향상</code> : 데이터 훼손 가능성이 적으니까</li>
  <li><code class="language-plaintext highlighter-rouge">백업 기능</code></li>
  <li><code class="language-plaintext highlighter-rouge">경합 감소</code></li>
</ol>

<h2 id="참조-무결성">참조 무결성</h2>
<ul>
  <li>외래키 값은 항상 참조되는 테이블의 기본키여야 함</li>
</ul>

<h3 id="참조-무결성을-위한-옵션">참조 무결성을 위한 옵션</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">RESTRICT</code> : 참조 무결성 위배 시 연산 거절</li>
  <li><code class="language-plaintext highlighter-rouge">CASCADE</code> : 해당 투플을 참조하는 튜플도 함께 삭제</li>
  <li><code class="language-plaintext highlighter-rouge">SET NULL</code> : 해당 튜플을 참조하는 튜플의 외래키에 NULL 값 삽입(단, NOT NULL 제약조건 시 연산 거절)</li>
</ol>

<h2 id="조인">조인</h2>
<ul>
  <li>두 개 이상의 테이블을 연결해 데이터를 검색하는 방법</li>
</ul>

<h3 id="조인-명령어">조인 명령어</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">A</span><span class="p">.</span><span class="err">번호</span><span class="p">,</span> <span class="n">B</span><span class="p">.</span><span class="err">가격</span> 
<span class="k">FROM</span> <span class="err">상품목록</span> <span class="n">A</span> <span class="k">JOIN</span> <span class="err">가격목록</span> <span class="n">B</span> <span class="k">ON</span> <span class="n">A</span><span class="p">.</span><span class="err">번호</span> <span class="o">=</span> <span class="n">B</span><span class="p">.</span><span class="err">번호</span> 
<span class="k">WHERE</span> <span class="n">A</span><span class="p">.</span><span class="err">번호</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="논리적-조인">논리적 조인</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">내부 조인</code> : 양 테이블의 공통 컬럼의 값이 같을 때 사용 <code class="language-plaintext highlighter-rouge">INNER JOIN</code></li>
  <li><code class="language-plaintext highlighter-rouge">외부 조인</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">왼쪽 외부 조인</code> : 왼쪽 테이블 전체 + 오른쪽 테이블 동일 데이터 <code class="language-plaintext highlighter-rouge">LEFT OUTER JOIN</code></li>
      <li><code class="language-plaintext highlighter-rouge">오른쪽 외부 조인</code> : 오른쪽 테이블 전체 + 왼쪽 테이블 동일 데이터 <code class="language-plaintext highlighter-rouge">RIGHT OUTER JOIN</code></li>
      <li><code class="language-plaintext highlighter-rouge">완전 외부 조인</code> : 양쪽 모든 데이터 추출 <code class="language-plaintext highlighter-rouge">FULL OUTER JOIN</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">교차 조인</code> : 조인 조건이 없는 모든 데이터 조합 추출 <code class="language-plaintext highlighter-rouge">CROSS JOIN</code></li>
  <li><code class="language-plaintext highlighter-rouge">셀프 조인</code> : 자기 자신에게 별칭을 지정한 후 조인</li>
</ol>

<h3 id="물리적-조인">물리적 조인</h3>
<ol>
  <li>Nested-Loop Join(중첩 반복 조인)</li>
  <li>Sort-Merge Join(정렬 합병 조인)</li>
  <li>Hash Join(해시 조인)</li>
</ol>

<h2 id="집합-연산자">집합 연산자</h2>
<ul>
  <li>2개 이상의 테이블의 질의의 결과를 합치는 연산자(검색을 위해 합치는 조인과 다름)</li>
  <li><code class="language-plaintext highlighter-rouge">UNION 연산자</code> : 합집합. <strong>중복을 제거</strong>하고 모두 포함</li>
  <li><code class="language-plaintext highlighter-rouge">UNION ALL 연산자</code> : 완전 합집합. 중복까지 포함</li>
  <li><code class="language-plaintext highlighter-rouge">INSERT 연산자</code> : 교집합. 겹치는 데이터만 추출</li>
  <li><code class="language-plaintext highlighter-rouge">MINUS 연산자</code> : 차집합. 첫 번째 쿼리에만 있고, 두 번째 쿼리에만 없는 결과만 추출</li>
</ul>

<h2 id="dcl-명령어">DCL 명령어</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">권한 부여</code> : GRANT 권한 ON 테이블 TO 사용자 [WITH GRANT OPTION];</li>
  <li><code class="language-plaintext highlighter-rouge">권한 회수</code> : REVOKE 권한 ON 테이블 FROM 사용자 [CASCADE CONSTRAINT];</li>
</ul>

<h2 id="dbms_output">DBMS_OUTPUT</h2>
<ul>
  <li>버퍼로부터 메시지를 읽어오는 인터페이스 패키지
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DBMS_OUTPUT</span><span class="p">.</span><span class="n">PUT</span><span class="p">(</span><span class="err">문자열</span><span class="p">);</span> <span class="o">//</span> <span class="err">문자열</span> <span class="err">출력하는</span> <span class="err">프로시저</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="절차형-sql">절차형 SQL</h2>
<ul>
  <li>SQL 안에서도 절차 지향적인 프로그래밍이 가능하도록 하는 트랜잭션 언어</li>
</ul>

<h3 id="절차형-sql의-종류">절차형 SQL의 종류</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">프로시저</code> : 일련의 쿼리들을 하나의 함수처럼 실행하기 위한 쿼리의 집합</li>
  <li><code class="language-plaintext highlighter-rouge">사용자 정의 함수</code> : 일련의 SQL 처리 후, 그 결과를 단일값으로 반환</li>
  <li><code class="language-plaintext highlighter-rouge">트리거</code> : DB 시스템에서 삽입, 삭제, 갱신 등의 이벤트 발생 시 관련 작업이 자동으로 수행</li>
</ol>

<h2 id="튜닝쿼리-성능-개선">튜닝(쿼리 성능 개선)</h2>
<ul>
  <li>SQL 실행 계획을 수정해 프로시저 성능을 개선하는 것</li>
</ul>

<h3 id="튜닝-개선-절차">튜닝 개선 절차</h3>
<ol>
  <li>문제 있는 SQL 식별(APM 모니터링 도구 사용)</li>
  <li>옵티마이저 통계 확인</li>
  <li>SQL문 재구성</li>
  <li>인덱스 재구성</li>
  <li>실행계획 유지관리</li>
</ol>

<h2 id="옵티마이저">옵티마이저</h2>
<ul>
  <li>SQL을 수행할 최적의 처리경로를 찾는 DBMS의 핵심엔진</li>
</ul>

<h3 id="옵티마이저-유형">옵티마이저 유형</h3>
<ol>
  <li>RBO : 규칙 기반 옵티마이저. 사전에 등록된 규칙에 따라 실행 계획을 선택함</li>
  <li>CBO : 비용 기반 옵티마이저. 모든 접근 경로를 고려해 실행 계획을 선택함
    <ul>
      <li>실행 계획(Execution Plan) : 옵티마이저가 생성한 처리경로</li>
    </ul>
  </li>
</ol>

<h3 id="옵티마이저의-역할">옵티마이저의 역할</h3>
<ol>
  <li>쿼리 변환 : SQL을 표준화된 형태로 변환</li>
  <li>비용 산정 : 카디널리티, 비용 등을 계산</li>
  <li>계획 생성
    <ul>
      <li><code class="language-plaintext highlighter-rouge">힌트</code>를 통해 옵티마이저의 실행 계획을 변경이 가능하다.<br /><br /></li>
    </ul>
  </li>
</ol>

<h1 id="개발-도구-분류">개발 도구 분류</h1>
<ol>
  <li>빌드 도구</li>
  <li>구현 도구</li>
  <li>테스트 도구</li>
  <li>형상관리 도구<br /><br /></li>
</ol>

<h1 id="형상관리cm">형상관리(CM)</h1>
<ul>
  <li>소프트웨어 개발 과정에서 발생하는 변경사항을 관리하는 것</li>
</ul>

<h2 id="형상관리-절차">형상관리 절차</h2>
<ol>
  <li>형상 식별(관리할 대상 식별 후 번호 부여)</li>
  <li>형상 통제(형상통제위원회 운영, 베이스라인 관리)
    <ul>
      <li>베이스라인 : 개발 산출물 변화를 통제하는 시점</li>
    </ul>
  </li>
  <li>형상 감사(무결성 평가)</li>
  <li>형상 기록</li>
</ol>

<h2 id="형상관리-도구-유형">형상관리 도구 유형</h2>
<ol>
  <li>공유 폴더 방식(개발이 완료된 파일을 공유 폴더에 복사)</li>
  <li>클라이언트/서버 방식(중앙에 버전관리 시스템이 동작)</li>
  <li>분산 저장소 방식(로컬 저장소/원격 저장소 분산)</li>
</ol>

<h2 id="형상관리-도구별-특징">형상관리 도구별 특징</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">RCS</code> : 공유폴더 방식(잠금 처리 후 1명만 수정)</li>
  <li><code class="language-plaintext highlighter-rouge">CVS</code> : 클라이언트/서버 방식(동시 접근 가능)</li>
  <li><code class="language-plaintext highlighter-rouge">SVN</code> : 클라이언트/서버 방식</li>
  <li><code class="language-plaintext highlighter-rouge">Clear Case</code> : 복수 클라이언트/복수 서버(필요시 서버 증설 가능)</li>
  <li><code class="language-plaintext highlighter-rouge">Bitkeeper</code> : 분산 저장소 방식</li>
  <li><code class="language-plaintext highlighter-rouge">Git</code> : 분산 저장소 방식</li>
</ol>

<h2 id="형상관리-통제-위원회ccb">형상관리 통제 위원회(CCB)</h2>
<ul>
  <li>형상관리 방침을 정하고 관리하는 조직<br /><br /></li>
</ul>

<h1 id="모듈">모듈</h1>
<ul>
  <li>그 자체로 하나의 완전한 기능을 수행할 수 있는 독립된 실체</li>
  <li>기능 단위로 분해, 추상화되어 재사용 가능한 단위</li>
</ul>

<h2 id="모듈화">모듈화</h2>
<ul>
  <li>성능 향상, 유지 관리 등을 위해 기능 단위 모듈로 분해하는 기법</li>
  <li>모듈 단위로 설계하는 기법<br /><br /></li>
</ul>

<h1 id="팬인-팬아웃">팬인 팬아웃</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">팬인(Fan-In)</code> : 어떤 모듈을 제어(호출)하는 모듈의 수</li>
  <li><code class="language-plaintext highlighter-rouge">팬아웃(Fan-Out)</code> : 어떤 모듈에 의해 제어(호출)되는 모듈의 수<br /><br /></li>
</ul>

<h1 id="루틴">루틴</h1>
<ul>
  <li>특정 동작을 수행하는 일련의 코드</li>
  <li>메인 루틴 : 전체의 개략적인 동작 절차를 표시하며 서브 루틴을 호출하는 루틴</li>
  <li>서브 루틴 : 메인 루틴에 의해 호출되는 루틴<br /><br /></li>
</ul>

<h1 id="웹서버">웹서버</h1>
<ul>
  <li>정적 콘텐츠를 처리하는 서버(ex. 아파치 웹 서버, 구글 웹 서버 등)<br /><br /></li>
</ul>

<h1 id="웹-어플리케이션-서버was">웹 어플리케이션 서버(WAS)</h1>
<ul>
  <li>동적 콘텐츠(JSP, 서블릿)를 처리하는 서버(ex. Tomcat, Weblogic 등)<br /><br /></li>
</ul>

<h1 id="서버-프로그램-구현-방법">서버 프로그램 구현 방법</h1>
<ul>
  <li>DTO/VO -&gt; SQL -&gt; DAO -&gt; Service Class -&gt; Controller Class
    <ul>
      <li><code class="language-plaintext highlighter-rouge">DTO</code> : Data Transfer Object. 화면에서 전달받은 데이터를 전송하는 객체</li>
      <li><code class="language-plaintext highlighter-rouge">VO</code> : Value Object. 간단한 객체</li>
      <li><code class="language-plaintext highlighter-rouge">DAO</code> : Data Access Object. 실질적으로 DB에 접근하는 객체<br /><br /></li>
    </ul>
  </li>
</ul>

<h1 id="배치-프로그램">배치 프로그램</h1>
<ul>
  <li>사용자와 상호작용 없이 일련의 작업들을 묶어 일괄적으로 처리하는 방법</li>
</ul>

<h2 id="배치-프로그램-유형">배치 프로그램 유형</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">이벤트 배치</code> : 사전에 정의된 조건이 충족될 때 실행</li>
  <li><code class="language-plaintext highlighter-rouge">온디맨드 배치</code> : 사용자의 요구가 있을 때 실행</li>
  <li><code class="language-plaintext highlighter-rouge">정기 배치</code> : 정해진 시점에 실행</li>
</ol>

<h2 id="배치-스케줄러">배치 스케줄러</h2>
<ul>
  <li>배치(일괄 처리)를 위해 반복적인 작업을 지원하는 도구</li>
</ul>

<h2 id="배치-스케줄러-종류">배치 스케줄러 종류</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">스프링 배치</code> : 스프링 프레임워크에서 사용하는 스케줄러</li>
  <li><code class="language-plaintext highlighter-rouge">쿼츠 스케줄러</code> : Job과 Trigger를 분리하는 오픈 소스 스케줄러</li>
</ol>

<h2 id="쿼츠-크론-표현식">쿼츠 크론 표현식</h2>
<ul>
  <li>스케줄러에서 배치 수행시간을 설정하기 위한 표현식<br /><br /></li>
</ul>

<h1 id="sw-개발-보안-3대-요소">SW 개발 보안 3대 요소</h1>
<ol>
  <li><code class="language-plaintext highlighter-rouge">기밀성</code> : 인가되지 않은 접근에 정보 노출을 차단하는 특성</li>
  <li><code class="language-plaintext highlighter-rouge">무결성</code> : 정당한 방법으로만 데이터를 변경할 수 있으며, 데이터의 정확성을 보장하는 특성</li>
  <li><code class="language-plaintext highlighter-rouge">가용성</code> : 권한을 가지고 있으면 서비스를 지속해서 사용할 수 있도록 하는 특성</li>
</ol>

<h2 id="sw-개발-보안-용어">SW 개발 보안 용어</h2>
<ol>
  <li>자산</li>
  <li>위협</li>
  <li>취약점</li>
  <li>위험<br /><br /></li>
</ol>

<h1 id="해킹-종류">해킹 종류</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">DRDos 공격</code> : 공격대상이 반사 서버로부터 다량의 응답을 받도록 하는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">DDos 공격</code> : 여러 대의 공격자를 분산 배치 후 동시에 동작시키는 DoS 공격(대역폭 소진 공격 &amp; 서비스 마비 공격)
    <ul>
      <li>구성요소
        <ol>
          <li><code class="language-plaintext highlighter-rouge">공격자</code> : 해커 컴퓨터</li>
          <li><code class="language-plaintext highlighter-rouge">마스터(Master)</code> : 공격자의 명령을 받고 에이전트를 관리하는 시스템</li>
          <li><code class="language-plaintext highlighter-rouge">핸들러(Handler)</code> : 마스터 시스템의 프로그램</li>
          <li><code class="language-plaintext highlighter-rouge">에이전트(Agent)</code> : 직접 공격하는 시스템</li>
          <li><code class="language-plaintext highlighter-rouge">데몬(Daemon)</code> : 에이전트 시스템의 프로그램</li>
        </ol>
      </li>
      <li><code class="language-plaintext highlighter-rouge">Stacheldraht</code> : DDoS의 에이전트 역할을 하는 도구</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">UDP 플러딩</code> : 대량의 UDP 패키지를 임의의 포트번호로 전송하지만 응답 메시지는 공격자에 전달되지 않아 자원을 고갈시키는 공격
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Trino</code> : UDP 플러딩 공격 도구</li>
      <li><code class="language-plaintext highlighter-rouge">TFN</code> : UDP 플러딩, SYN 플러딩, 스머프 등등 여러 DDoS 공격이 가능한 도구</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">SYN 플러딩</code> : ACK를 발송하지 않고 SYN 패킷만 보내 점유하여 자원을 고갈시키는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">죽음의 핑</code> : ICMP 패킷(핑)을 아주 크게 만들어 과부하시키는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">스머프/스머핑</code> : 출발지 IP를 공격 대상의 IP로 변조하여 브로드캐스팅으로 ICMP Echo 패킷 요청을 보내 과부하시키는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">티어 드롭</code> : 조작된 IP 패킷 조각을 보내 재조립 과정에서 오류를 발생시키는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">랜드 어택</code> : 출발지 IP와 도착지 IP를 같은 주소로 만들어, 자기 자신에게 응답을 보내도록 하는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">봉크/보잉크</code> : IP 패킷의 재전송, 재조합 과정에서 오류를 발생시키는 공격(봉크 : 같은 시퀀스 번호 / 보잉크 : 시퀀스 번호에 빈 공간)</li>
  <li><code class="language-plaintext highlighter-rouge">Slow HTTP Read Dos</code> : TCP 윈도 크기와 데이터 처리율을 감소시킨 뒤 다량의 HTTP 요청을 보내는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">Slow HTTP Header Dos</code> : =Slowloris. 헤더 정보를 조작하여 웹 서버가 온전한 헤더정보가 올 때까지 기다리게 하는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">Slow HTTP Post Dos</code> : =RUDY. 헤더의 Content-Length를 아주 크게 만들고 데이터를 아주 소량으로 보내 연결을 유지하게 하는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">HTTP GET 플러딩</code> : 과도한 GET 메시지를 통해 과부하시키는 공격(캐싱서버가 아닌 웹 서버가 직접 처리하도록 유도)</li>
  <li><code class="language-plaintext highlighter-rouge">Hulk Dos</code> : 공격자가 공격대상의 URL을 계속 변경하면서(=차단 정책 우회) 다량의 GET 요청을 보내는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">Hash Dos</code> : 웹 서버의 해시 테이블에 해시 충돌을 일으켜 자원을 소모시키는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">Dos 공격</code> : 시스템의 자원을 고갈시켜 서비스 거부를 유발하는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">스니핑</code> : 공격대상에 직접 공격을 가하지 않고 몰래 정보를 들여다보는 수동적인 공격 기법</li>
  <li><code class="language-plaintext highlighter-rouge">패스워드 크래킹</code>
    <ol>
      <li><code class="language-plaintext highlighter-rouge">사전 크래킹 Dictionary Cracking</code> : IP/PW가 될 가능성이 있는 단어를 대입하는 공격</li>
      <li><code class="language-plaintext highlighter-rouge">무차별 크래킹 Brute Force Cracking</code> : PW로 사용될 수 있는 문자를 무작위로 대입하는 공격</li>
      <li><code class="language-plaintext highlighter-rouge">패스워드 하이브리드 공격 Password Hybrid Attack</code> : 사전 + 무차별을 결합하여 공격</li>
      <li><code class="language-plaintext highlighter-rouge">레인보우 테이블 공격 Rainbow Table Attack</code> : 크래킹하려는 해시값을 테이블에서 검색하는 공격</li>
    </ol>
  </li>
  <li><code class="language-plaintext highlighter-rouge">네트워크 스캐너/스니퍼</code> : 공격자가 취약점을 탐색하는 도구</li>
  <li><code class="language-plaintext highlighter-rouge">ICMP Redirect 공격</code> : ICMP Redirect 메시지를 공격자가 원하는 형태로 위조해 패킷을 스니핑하는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">IP 스푸핑</code> : IP를 위조하여 인증된 시스템인 것처럼 IP를 위조하여 목표 시스템의 정보를 빼내는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">ARP 스푸핑</code> : MAC 주소를 위장하여 패킷을 스니핑하는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">트로이 목마</code> : 겉으로는 정상적이나 실행하면 악성코드가 실행되는 프로그램</li>
  <li><code class="language-plaintext highlighter-rouge">버퍼 오버플로우 공격</code> : 메모리의 버퍼 크기를 초과하는 데이터를 입력해 프로세스 흐름을 변경시키는 공격 기법
    <ul>
      <li><code class="language-plaintext highlighter-rouge">버퍼 오버플로우 공격 대응</code>
        <ol>
          <li><code class="language-plaintext highlighter-rouge">스택가드</code> (활용 : 카나리(무결성 체크용 값)를 미리 삽입해 두고 버퍼 오버플로우 발생 시 카나리값을 체크해 변한 경우 복귀 주소를 호출하지 않음)</li>
          <li><code class="language-plaintext highlighter-rouge">스택쉴드</code> (활용 : 함수 시작시 복귀주소를 특수 스택에 저장해 두고 함수 종료시 스택 값을 비교해 다를 경우 오버플로우로 간주하고 중단)</li>
          <li><code class="language-plaintext highlighter-rouge">ASLR</code> (활용 : Address Space Layout Randomization; 주소 공간 배치 난수화. 주소 공간 배치를 난수화하여 실행 시마다 메모리 주소를 변경시키는 것)</li>
          <li><code class="language-plaintext highlighter-rouge">안전한 함수 사용</code> : 버퍼오버플로우에 취약한 scanf() 대신 fscanf() 등을 사용</li>
          <li><code class="language-plaintext highlighter-rouge">실행 제한</code> : 스택에서의 쓰기 권한 제한 등</li>
        </ol>
      </li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">스택 버퍼 오버플로우 공격</code> : 스택 영역(지역변수, 매개변수가 저장되는 영역)의 버퍼에 오버플로우를 일으켜서 복귀주소를 바꾸는 공격 기법</li>
  <li><code class="language-plaintext highlighter-rouge">힙 버퍼 오버플로우 공격</code> : 힙 영역(사용자가 직접 관리 가능한 메모리 영역)의 버퍼에 오버플로우를 일으켜서 데이터를 오염시키는 공격 기법</li>
  <li><code class="language-plaintext highlighter-rouge">포맷 스트링 공격</code> : 포맷 스트링을 인자로 하는 함수의 취약점을 이용한 공격</li>
  <li><code class="language-plaintext highlighter-rouge">키로거 공격</code> : 키보드 움직임을 탐지해 주요정보를 빼가는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">루트킷</code> : 불법 해킹에 사용되는 기능을 제공하는 프로그램 모음</li>
  <li><code class="language-plaintext highlighter-rouge">백도어</code> : 정상적인 인증절차를 우회하는 기법</li>
  <li><code class="language-plaintext highlighter-rouge">레이스 컨디션 공격</code> : 프로세스가 임시 파일을 만들 때 실행 중에 끼어들어 임시파일을 심볼릭 링크하는 공격
    <ul>
      <li><code class="language-plaintext highlighter-rouge">심볼릭 링크</code> : 링크를 연결하여 원본 파일을 사용하는 것과 같은 효과를 내는 링크</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">스피어피싱</code> : 특정 대상 선정 후, 일반적인 메일로 위장한 메일을 발송해 개인정보를 탈취하는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">스미싱</code> : SMS + 피싱. 문자메시지를 통해 개인정보를 탈취하거나 소액결제를 유도하는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">공급망 공격</code> : SW 개발사의 코드를 수정하거나 배포 서버에 접근해 파일을 변경하는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">큐싱</code> : QR코드 + 피싱. QR을 이용한 피싱 공격</li>
  <li><code class="language-plaintext highlighter-rouge">APT 공격</code> : 특정 대상을 목표로 한 지능적/지속적인 공격
    <ul>
      <li>대응 : <code class="language-plaintext highlighter-rouge">사이버 킬체인</code> - 공격형 방위 시스템. APT 공격의 방어 모델</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">봇넷</code> : 악성 프로그램에 감염된 컴퓨터들이 네트워크로 연결된 형태</li>
  <li><code class="language-plaintext highlighter-rouge">악성 봇</code> : 해커의 명령에 의해 원격으로 제어되는 프로그램(DDos 등에 악용)</li>
  <li><code class="language-plaintext highlighter-rouge">웜</code> : 스스로를 복제하여 전파하는 악성 프로그램</li>
  <li><code class="language-plaintext highlighter-rouge">제로데이 공격</code> : 보안 취약점이 공표되기 전 신속히 이뤄지는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">이블 트윈 공격</code> : 합법적인 Wifi 제공자처럼 행세하며 연결된 사용자 정보를 탈취하는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">랜섬웨어</code> : 암호화 후 복호화를 위해 돈을 요구하는 악성 소프트웨어</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Tcpdump</code> : 스니핑 도구(패킷 내용을 출력하는 프로그램)</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">XSS</code> : 검증되지 않은 입력데이터가 포함된 웹페이지를 열람할 때, 웹페이지에 포함된 부적절한 스크립트가 실행되는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">Stored XSS</code> : 악성 스크립트가 포함된 웹페이지를 읽을 때 감염되는 기법</li>
  <li><code class="language-plaintext highlighter-rouge">DOM XSS</code> : DOM 기반 XSS 취약점이 있는 브라우저를 대상으로 한 기법</li>
  <li><code class="language-plaintext highlighter-rouge">Reflected XSS</code> : 악성 URL 클릭 시 공격 스크립트가 반사되는 기법</li>
  <li><code class="language-plaintext highlighter-rouge">CSRF</code> : =Cross Site Request Forgery(사이트 간 요청 위조) 사용자가 자신의 의지와 무관하게 공격자가 의도한 행위를 요청하게 하는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">SQL Injection</code> : 악의적인 SQL 구문을 삽입, 실행시켜 DB 정보를 탈취하거나 조작하는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">Union SQL Injection</code> : UNION 연산자를 이용해 쿼리 결과를 결합해 공격</li>
  <li><code class="language-plaintext highlighter-rouge">Form SQL Injection</code> : HTML Form 기반 인증의 취약점을 이용한 공격</li>
  <li><code class="language-plaintext highlighter-rouge">Stored Procedure SQL Injection</code> : 저장 프로시저를 이용해 공격</li>
  <li><code class="language-plaintext highlighter-rouge">Maxx SQL Injection</code> : 한 번의 공격으로 대량의 DB값을 변조하는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">Error-Based SQL Injection</code> : 에러값을 기반으로 한 단계씩 점진적으로 정보를 캐내는 공격</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Blind SQL Injection</code> : 쿼리 결과의 참/거짓을 통해 공격</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">부 채널 공격(Side Channel Attack)</code> : 전격 소비와 같은 물리적 특성을 측정해 비밀 정보를 알아내는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">드라이브 바이 다운로드(Drive By Download)</code> : 악성 스크립트를 웹 서버에 설치 후, 사용자를 멀웨어 서버로 연결해 감염시키는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">워터링 홀(Watering Hole)</code> : 특정인을 표적으로 삼아 특정인이 자주 방문하는 웹사이트에 악성코드를 심어 공격</li>
  <li><code class="language-plaintext highlighter-rouge">하트 블리드(Heart Bleed)</code> : 하트비트(암호화 라이브러리)의 확장 모듈 취약점을 이용해 데이터를 탈취하는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">IoT-SSDP</code> : SSDP(단순 서비스 검색 프로토콜)의 특성을 이용해 IoT 디바이스를 좀비 PC로 이용해 DDoS 공격</li>
  <li><code class="language-plaintext highlighter-rouge">크라임웨어(Crimeware)</code> : 금융, 인증 정보를 탈취해 금전적 이익을 취하는 악성 코드</li>
  <li><code class="language-plaintext highlighter-rouge">스캠 공격(SCAM)</code> : 기업 이메일을 도용해 거래 대금을 가로채는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">MIMT(Man in the Middle)</code> : 통신 연결 중간에 침입해 통신 내용을 도청하는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">DNS 스푸핑</code> : DNS 서버 캐시를 조작해 의도치 않은 주소로 접속하게 하는 공격 (=DNS 캐시 포이즈닝)</li>
  <li><code class="language-plaintext highlighter-rouge">포트 스캐닝(Port Scanning)</code> : 침입 전 어떤 포트가 활성화되어 있는지 확인하는 기법</li>
  <li><code class="language-plaintext highlighter-rouge">디렉토리 리스팅 취약점(Directory Listing)</code> : 웹 서버의 인덱싱 기능이 활성화된 경우, 서버 내 모든 디렉토리를 볼 수 있는 취약점</li>
  <li><code class="language-plaintext highlighter-rouge">리버스 쉘 공격(Reverse Shell)</code> : 타깃 서버(피해자)가 클라이언트로 접속하게 하고, 클라이언트에서 서버의 쉘을 획득하는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">익스플로잇(Exploit)</code> : SW/HW의 버그나 취약점을 악용해 공격하는 행위</li>
  <li><code class="language-plaintext highlighter-rouge">스턱스넷 공격(Stuxnet)</code> : 독일 지멘스사의 SCADA 시스템을 목표로 제작된 악성코드(주요 산업 기반 시설의 제어 시스템에 침투하는 공격)</li>
  <li><code class="language-plaintext highlighter-rouge">크리덴셜 스터핑(Credential Stuffing)</code> : 다른 곳에서 유출된 로그인 정보를 다른 곳에 무작위 대입하는 공격</li>
  <li><code class="language-plaintext highlighter-rouge">토르 네트워크(Tor Network)</code> : 암호화 기법으로 데이터를 전송해 익명으로 사용 가능한 네트워크</li>
  <li><code class="language-plaintext highlighter-rouge">윈드토커(WindTalker)</code> : 터치, 타이핑 등의 패턴을 스니핑하여 해킹</li>
  <li><code class="language-plaintext highlighter-rouge">멜트다운(Meltdown)</code> : 인텔 아키텍처의 버그를 이용해 시스템 메모리에 접근하는 취약점</li>
  <li><code class="language-plaintext highlighter-rouge">스펙터(Specter)</code> : 실패한 분기 예측으로 메모리 영역을 훔쳐보는 취약점</li>
</ul>

<h2 id="보안-취약점">보안 취약점</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">API 오용 취약점</code>
    <ul>
      <li>DNS Lookup에 의존하지 않기 (DNS 엔트리를 속일 수 있음)</li>
      <li>보안에 취약한 함수 사용하지 않기</li>
      <li>널 매개변수 검사하기(자바에서 매개변수가 NULL이면 반환오류가 있을 수 있다)</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">캡슐화 취약점</code>
    <ul>
      <li>디버그 코드는 꼭 제거</li>
      <li>민감한 데이터를 가진 클래스 사용에 주의</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">코드 오류 취약점</code>
    <ul>
      <li>NULL이 될 수 있는 레퍼런스는 참조 전 NULL 값인지 검사</li>
      <li>정수를 문자로 변환할 때 잘려나가지 않도록 크기 확인</li>
      <li>자원 사용 후에는 반드시 해제</li>
      <li>변수 선언 시 초기화(이전에 사용한 내용이 남지 않도록)</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">시간 및 상태 취약점</code>
    <ul>
      <li>세션 통제 취약점 : 세션 정보에 읽고 쓰기가 가능한 변수 미사용</li>
      <li>병렬 시스템 : 공유 자원의 접근 직렬화, 블록문 내에서만 재귀함수 호출</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">에러 처리 취약점</code>
    <ul>
      <li>취약한 패스워드 조건 미사용</li>
      <li>오류 메시지에 정보 노출 하지 않음</li>
      <li>예외 처리 구문 작성</li>
    </ul>
  </li>
</ul>

<h3 id="보안-취약점-분석-절차">보안 취약점 분석 절차</h3>
<ol>
  <li>자산 조사</li>
  <li>진단 대상 선정(전수조사 vs. 샘플링)</li>
  <li>제약사항 확인</li>
  <li>진단 수행(기술 진단, 인터뷰, 내부 실사 등)</li>
  <li>결과 보고서 작성<br /><br /></li>
</ol>

<h1 id="보안-솔루션">보안 솔루션</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">네트워크 접근 제어(NAC)</code> : 내부 네트워크에 접속을 시도할 때 통제하는 솔루션</li>
  <li><code class="language-plaintext highlighter-rouge">웹 방화벽(WAF)</code> : 웹 애플리케이션에 특화되어 XSS나 SQL Injection 등을 탐지하고 차단하는 시스템</li>
  <li><code class="language-plaintext highlighter-rouge">방화벽(Firewall)</code> : 내부, 외부 트래픽을 모니터링하여 접근을 사용/차단하는 시스템</li>
  <li><code class="language-plaintext highlighter-rouge">침입 탐지 시스템(IDS)</code> : 비인가 사용자의 침입을 실시간으로 탐지하는 시스템</li>
  <li><code class="language-plaintext highlighter-rouge">가상사설망(VPN)</code> : 공중망을 사용할 때 마치 전용망을 사용하는 것과 같은 보안 효과를 주는 솔루션</li>
  <li><code class="language-plaintext highlighter-rouge">침입 방지 시스템(IPS)</code> : 공격 및 침입을 실시간으로 차단하는 시스템</li>
  <li><code class="language-plaintext highlighter-rouge">통합 보안 시스템(UTM)</code> : 방화벽, IDS, IPS, VPN 등 다양한 보안 장비 기능을 통합 제공하는 시스템</li>
  <li><code class="language-plaintext highlighter-rouge">무선 침입 방지 시스템(WIPS)</code> : 비인가 무선 단말기의 접속을 차단하는 시스템</li>
  <li><code class="language-plaintext highlighter-rouge">Secure OS</code> : OS 커널에 보안 기능을 추가한 솔루션</li>
  <li><code class="language-plaintext highlighter-rouge">Anti-Spam Solution</code> : 메일 서버 앞단에 바이러스 검사, 정보 유출 방지 등의 기능을 제공하는 솔루션</li>
  <li><code class="language-plaintext highlighter-rouge">DLP</code> : Data Loss Prevention; 주요 자료가 외부로 유출되는 것을 차단하는 솔루션</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">DRM</code> : Digital Right Management; 디지털 저작물에 암호를 걸어 권한이 없는 사용자의 사용을 막는 솔루션</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">BIA</code> : 비즈니스 영향 평가(Business Impact Analysis). 장애나 재해에 따른 영향도 조사</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">BCP</code> : 비즈니스 연속성 계획(Business Continuity Plan). 위기 관리를 기반으로 비상시 비즈니스 연속성을 보장하는 체계. BIA가 선행되어야 함</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">DRS</code> : 재해 복구 시스템(Disaster Recovery System) : DRP를 위한 관리체제
    <ul>
      <li>유형
        <ol>
          <li><code class="language-plaintext highlighter-rouge">Mirror Site</code> : 주 센터 &amp; 복구센터 모두 운영 상태(RTO는 0)</li>
          <li><code class="language-plaintext highlighter-rouge">Hot Site</code> : 주 센터와 동일한 수준의 자원을 대기 상태로 보유하며 데이터를 최신 상태로 유지(RTO는 4시간 이내)</li>
          <li><code class="language-plaintext highlighter-rouge">Warm Site</code> : 중요성이 높은 자원만 주 센터와 동일한 수준으로 보유(RTO는 수일~수주)</li>
          <li><code class="language-plaintext highlighter-rouge">Cold Site</code> : 데이터만 원격지에 보관하고 재해 시 이를 근간으로 복구(RTO는 수주~수개월)</li>
        </ol>
      </li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">DRP</code> : 재해 복구 계획(Disaster Recovery Plan). 재해로 장기간 운영이 불가한 경우를 대비한 계획</li>
  <li><code class="language-plaintext highlighter-rouge">RTO</code> : 복구 목표 시간(Recovery Time Object). 재해 시 업무중단 시점~업무복구 시점까지 걸린 시간</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">RPO</code> : 복구 목표 지점(Recovery Point Object). 재해 시 업무중단 시점~정상가동까지 허용하는 손실</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">허니팟(HoneyPot)</code> : 일부러 허술하게 만들어 해커에게 노출하는 유인시스템</li>
  <li><code class="language-plaintext highlighter-rouge">OWASP Top 10</code> : 웹 애플리케이션의 10가지 보안 취약점에 대한 방안을 제공하는 가이드</li>
  <li><code class="language-plaintext highlighter-rouge">핑거프린팅(Finger Printing)</code> : 저작권 정보와 구매자 정보를 콘텐츠에 삽입해 불법 배포자를 추적할 수 있는 기술</li>
  <li><code class="language-plaintext highlighter-rouge">CPTED</code> : 범죄 예방 환경 설계(Crime Privent Through Environment Design). 학문 간 연계를 통해 범죄를 최소화할 수 있는 환경을 설계하는 전략</li>
  <li><code class="language-plaintext highlighter-rouge">워터 마킹(Water Marking)</code> : 디지털 콘텐츠에 저작자 정보를 삽입해 불법 복제 시 원소유자를 증명하는 기술</li>
  <li><code class="language-plaintext highlighter-rouge">CC(Common Criteria)</code> : 컴퓨터 보안을 위한 국제 평가 기준</li>
  <li><code class="language-plaintext highlighter-rouge">C-TAS(사이버 위협 정보 분석 공유 시스템)</code> : 사이버 위협정보를 체계적으로 수립해 관계 기관과 자동화된 정보공유를 할 수 있는 시스템(KISA 주관)</li>
  <li><code class="language-plaintext highlighter-rouge">CWE(Common Weakness Enumeration)</code> : 소프트웨어의 공통 약점(CW)을 식별화(E)한 것</li>
  <li><code class="language-plaintext highlighter-rouge">CVE(Common Vulerabilities and Exposures)</code> : 소프트웨어의 공통 취약점(CV)을 식별화(E)한 것(CVE-연도-순서)</li>
  <li><code class="language-plaintext highlighter-rouge">CVSS(Common Vulnerability Scoring System)</code> : 공통 취약점(CV)에 등급(S)을 매긴 시스템(S). 위험도 계산 가능<br /><br /></li>
</ul>

<h1 id="해킹-대응-방법">해킹 대응 방법</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Tripwire</code> : 백도어가 생기거나 설정 파일 변화가 있을 때 이를 감지할 수 있게 돕는 도구</li>
  <li><code class="language-plaintext highlighter-rouge">난독화</code> : 코드의 가독성을 낮춰 역공학에 대비</li>
  <li><code class="language-plaintext highlighter-rouge">Ping</code> : 접속하려는 원격 호스트가 정상 운영 중인지 확인하는 명령어<br /><br /></li>
</ul>

<h1 id="접근-통제-유형">접근 통제 유형</h1>
<ol>
  <li><code class="language-plaintext highlighter-rouge">식별</code> : 주체가 객체에게 정보 제공</li>
  <li><code class="language-plaintext highlighter-rouge">인증</code> : 객체가 주체의 신원을 인정</li>
  <li><code class="language-plaintext highlighter-rouge">인가</code> : 인증된 주체에게 접근을 허용</li>
  <li><code class="language-plaintext highlighter-rouge">책임추적성</code> : 주체의 접근과 행동을 추적 및 기록</li>
</ol>

<h2 id="서버-접근-통제-유형">서버 접근 통제 유형</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">DAC(임의적 접근 통제)</code>
    <ul>
      <li>접근결정 : 신분</li>
      <li>권한 부여 : 데이터 소유자. ACL(Access Control List)로 자원에 대한 권한 부여</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">MAC(강제적 접근 통제)</code>
    <ul>
      <li>접근결정 : 권한(등급)</li>
      <li>권한 부여 : 시스템</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">RBAC(역할 기반 접근 통제)</code>
    <ul>
      <li>접근결정 : 역할</li>
      <li>권한 부여 : 중앙관리자</li>
    </ul>
  </li>
</ol>

<h2 id="인증-기술의-유형">인증 기술의 유형</h2>
<ol>
  <li>지식기반 ex. ID/PW</li>
  <li>소지기반 ex. 공인인증서</li>
  <li>생체기반 ex. 지문, 홍채</li>
  <li>특징기반 ex. 서명, 발걸음<br /><br /></li>
</ol>

<h1 id="암호화-알고리즘-방식">암호화 알고리즘 방식</h1>
<ol>
  <li><code class="language-plaintext highlighter-rouge">대칭 키 암호 방식</code> : 암호화 알고리즘의 한 종류로, 암/복호화에 같은 암호 키를 쓰는 알고리즘을 의미
    <ul>
      <li><code class="language-plaintext highlighter-rouge">블록 암호</code> : 고정 길이의 블록을 암호화하는 대칭 키 암호 방식
        <ul>
          <li><code class="language-plaintext highlighter-rouge">DES</code> : 미 연방표준국(NIST)에서 발표. 키 길이는 56bit, 블록크기는 64bit</li>
          <li><code class="language-plaintext highlighter-rouge">3DES</code></li>
          <li><code class="language-plaintext highlighter-rouge">AES</code> : =Advanced Encryption Standard. 3DES의 문제점을 극복하기 위해 개발. 라운드 수는 10, 12, 14로 분류되고, 한 라운드는 빼고(SubBytes)+이동하고(ShiftRows)+섞고(MixColumns)+더하는(AddRoundKey) 4계층으로 구성됨</li>
          <li><code class="language-plaintext highlighter-rouge">SEED</code> : KISA가 개발. 16라운드를 거쳐 128비트 블록으로 암호화</li>
          <li><code class="language-plaintext highlighter-rouge">ARIA</code> : 학계(Academy) + 연구기관(Research Institute) + 정부(Agency) 국정원과 산학연구협회가 개발함</li>
          <li><code class="language-plaintext highlighter-rouge">IDEA</code> : DES를 대체하기 위해 개발</li>
          <li><code class="language-plaintext highlighter-rouge">RC5</code> : RC4를 개선한 알고리즘. 입출력, Key, 라운드 수가 가변인 블록 알고리즘. 32/64/128비트의 키 사용</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">스트림 암호</code> : 매우 긴 주기의 난수열을 발생시켜 암호화하는 대칭 키 암호 방식
        <ul>
          <li><code class="language-plaintext highlighter-rouge">LFSR</code> : 선형 되먹음 시프트 레지스터</li>
          <li><code class="language-plaintext highlighter-rouge">RC4</code> : 셔플링 기법을 이용해 평뮨과 XOR 연산해 암호화</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">비대칭 키 암호 방식</code> : 공개 키는 누구나 알 수 있지만 그에 대응하는 비밀키는 키의 소유자만이 알 수 있도록, 공개 키와 비밀 키를 사용하는 알고리즘
    <ul>
      <li><code class="language-plaintext highlighter-rouge">디피-헬만</code> : 비대칭키 최초의 비밀키 교환 프로토콜. 이산대수 계산의 어려움을 근거로 함</li>
      <li><code class="language-plaintext highlighter-rouge">RSA</code> : 비대칭키 수학교수 3명의 앞글자를 땄음(리베르트, 샤미르, 아들만). 소인수 분해 문제의 어려움을 근거로 함</li>
      <li><code class="language-plaintext highlighter-rouge">ECC</code> : 비대칭키 타원 곡선 암호. RSA의 대안. 짧은 키로 높은 암호 강도</li>
      <li><code class="language-plaintext highlighter-rouge">DSA</code> : 전자서명 알고리즘 표준. 이산대수 계산의 어려움을 근거로 함. 구조가 간단한 것이 장점</li>
      <li><code class="language-plaintext highlighter-rouge">Elgamel</code> : 비대칭키 이산대수의 어려움을 근거로 함. 전자서명에 사용 가능</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">해시 암호 방식</code> : 해시 값으로 원래 입력값을 찾아낼 수 없는, 일방향성의 특성을 가진 알고리즘
    <ul>
      <li><code class="language-plaintext highlighter-rouge">SHA-1</code> : 160비트 암호화 해시함수. 1993년 미국 NIST에서 개발됨. 보안강도가 약해 <code class="language-plaintext highlighter-rouge">SHA-256</code>이나 <code class="language-plaintext highlighter-rouge">SHA-512</code>로 대체되고 있다. 전자서명시 활용</li>
      <li><code class="language-plaintext highlighter-rouge">MD5</code> : 128비트 기반 암호화 해시 함수. 결과 값이 16개 문자열. 설계상 결함으로 사용이 줄어드는 추세. 메시지 무결성에 활용</li>
      <li><code class="language-plaintext highlighter-rouge">HAVAL</code> : <code class="language-plaintext highlighter-rouge">MD5</code>를 변형하여 만든 해시 함수. 128비트~256비트까지 다양한 크기 가능</li>
      <li><code class="language-plaintext highlighter-rouge">Tiger</code> : 64비트 CPU에 최적화 됨. 32비트 CPU에서도 빠르게 동작 가능. 64비트 CPU의 해시에 활용됨</li>
      <li><code class="language-plaintext highlighter-rouge">HAS-160</code> : 국내 표준 디지털 서명 알고리즘(KCDSA)을 위해 개발된 알고리즘(MD5의 장점 + SHA-1의 장점)</li>
    </ul>
  </li>
</ol>

<ul>
  <li><code class="language-plaintext highlighter-rouge">S-HTTP</code> : 클라이언트/서버 간 메시지를 암호화하는 보안 기술(HTTP를 사용한 경우에만 가능)<br /><br /></li>
</ul>

<h1 id="개인정보보호-관련-법령">개인정보보호 관련 법령</h1>
<ol>
  <li><code class="language-plaintext highlighter-rouge">개인정보보호법</code> : 주민등록번호, 여권번호, 운전면허번호, 외국인등록번호와 같은 고유 식별 번호는 분실, 도난, 유출, 변조, 훼손에 주의해야 함</li>
  <li><code class="language-plaintext highlighter-rouge">정보통신망법</code> : 정보통신망의 이용을 촉진하고 정보통신서비스를 이용하는 자의 개인정보를 보호함과 아울러 정보통신망을 건전하고 안전하게 이용할 수 있는 환경을 조성하기 위한 규정</li>
  <li><code class="language-plaintext highlighter-rouge">신용정보법</code> : 개인 신용정보의 취급 단계별 보호조치 및 의무사항에 관한 규정<br /><br /></li>
</ol>

<h1 id="open-samm">Open SAMM</h1>
<ul>
  <li>확대가 가능한 개방형 프레임워크. 설계 리뷰, 코드 리뷰, 보안 테스팅 3개를 주요 검증 활동으로 함 (*SAMM : 소프트웨어 보증 성숙도 모델)<br /><br /></li>
</ul>

<h1 id="시큐어-코딩-가이드">시큐어 코딩 가이드</h1>
<ol>
  <li>입력데이터 검증 및 표현</li>
  <li>보안 기능</li>
  <li>시간 및 상태</li>
  <li>에러 처리</li>
  <li>코드 오류</li>
  <li>캡슐화</li>
  <li>API 오용<br /><br /></li>
</ol>

<h1 id="sw-테스트">SW 테스트</h1>
<ul>
  <li>개발된 소프트웨어가 요구사항을 만족하는지 확인하고 결함을 검출하는 활동</li>
</ul>

<h2 id="sw-테스트의-필요성">SW 테스트의 필요성</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">오류 발견 관점</code> : 잠재된 오류를 발견 가능</li>
  <li><code class="language-plaintext highlighter-rouge">오류 예방 관점</code> : 사전에 오류를 발견하고 예방</li>
  <li><code class="language-plaintext highlighter-rouge">품질 향상 관점</code> : 요구사항과 기대 수준을 만족하도록 품질 향상</li>
</ol>

<h2 id="sw-테스트의-기본-원칙">SW 테스트의 기본 원칙</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">완벽한 테스팅은 불가</code> : 무한입력값, 무한경로</li>
  <li><code class="language-plaintext highlighter-rouge">살충제 패러독스</code> : 같은 테스트케이스를 반복하면 새 오류 검출이 불가능하다.</li>
  <li><code class="language-plaintext highlighter-rouge">초기에 테스팅을 시작할 것</code> : 후반으로 갈수록 비용이 증가한다.(오르돈의 법칙, 눈덩이 법칙)</li>
  <li><code class="language-plaintext highlighter-rouge">정황에 의존하지 말 것</code> : SW 성격, 환경에 맞춰 테스트해야 함</li>
  <li><code class="language-plaintext highlighter-rouge">오류-부재의 궤변</code> : 오류(결함)가 없더라도 요구사항을 만족하지 못하면 품질이 높다고 할 수 없음</li>
  <li><code class="language-plaintext highlighter-rouge">결함 집중</code> : 결함의 80%는 전체 모듈 20% 내에서 발견된다.(파레토 법칙)</li>
  <li><code class="language-plaintext highlighter-rouge">결함은 늘 존재한다</code> : 테스팅은 결함이 존재함을 밝히는 활동</li>
</ol>

<h2 id="테스트-케이스-test-case">테스트 케이스 Test Case</h2>
<ul>
  <li>요구사항을 만족하는지 확인하기 위해 설계된 입력값, 실행조건, 기대결과로 구성된 명세서</li>
  <li><code class="language-plaintext highlighter-rouge">테스트 스크립트 Test Script</code> : TC 실행순서를 작성한 문서 (=테스트 스텝, 테스트 프로시저)</li>
  <li><code class="language-plaintext highlighter-rouge">테스트 시나리오 Test Scenario</code> : 테스트할 기능, 상황을 정리해 절차를 명세화한 문서</li>
  <li><code class="language-plaintext highlighter-rouge">테스트 슈트 Test Suites</code> : 실행환경에 따라 구분해 놓은 TC의 집합</li>
</ul>

<h3 id="테스트-케이스-구성요소">테스트 케이스 구성요소</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">입력 명세</code> : 입력할 데이터 및 조건</li>
  <li><code class="language-plaintext highlighter-rouge">출력 명세</code> : 기대되는 결과값</li>
  <li><code class="language-plaintext highlighter-rouge">테스트 항목</code></li>
  <li><code class="language-plaintext highlighter-rouge">특수절차요구</code></li>
  <li><code class="language-plaintext highlighter-rouge">환경설정</code> : 수행에 필요할 HW/SW 환경</li>
  <li><code class="language-plaintext highlighter-rouge">의존성 기술</code> : TC 간 의존성</li>
  <li><code class="language-plaintext highlighter-rouge">식별자</code></li>
</ol>

<h2 id="테스트-종류에-따른-분류">테스트 종류에 따른 분류</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">구조 기반</code> : 내부 논리 흐름에 따라 테스트 (화이트박스)</li>
  <li><code class="language-plaintext highlighter-rouge">명세 기반</code> : 명세서 기반으로 테스트 (블랙박스)</li>
  <li><code class="language-plaintext highlighter-rouge">경험 기반</code> : 유사 평가 경험을 기반으로 테스트 (탐색적 테스트, 오류 추정, 체크리스트, 특성 테스트)</li>
</ol>

<h2 id="테스트-목적에-따른-분류">테스트 목적에 따른 분류</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">회복 테스트(Recovery)</code> : 고의로 실패를 유도한 뒤, 정상 복귀를 테스트</li>
  <li><code class="language-plaintext highlighter-rouge">안전 테스트(Security)</code> : 보안 결함 점검</li>
  <li><code class="language-plaintext highlighter-rouge">성능 테스트(Performance)</code> : 요구에 대한 반응속도를 측정
    <ul>
      <li><code class="language-plaintext highlighter-rouge">부하 테스트(Load)</code> : 부하를 점점 늘려 임계점을 찾는 테스트</li>
      <li><code class="language-plaintext highlighter-rouge">스트레스 테스트(Stress)</code> : 임계점 이상의 부하를 가해 비정상적인 상황에서의 성능을 측정</li>
      <li><code class="language-plaintext highlighter-rouge">스파크 테스트(Spark)</code> : 짧은 시간 내 많은 사용자가 몰릴 때 반응 테스트</li>
      <li><code class="language-plaintext highlighter-rouge">내구성 테스트(Endurance)</code> : 오랜 시간 동안 높은 부하를 가해 성능 테스트</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">구조 테스트(Structure)</code> : 논리 경로, 소스코드 복잡도 측정</li>
  <li><code class="language-plaintext highlighter-rouge">회귀 테스트(Regression)</code> : 오류 제거 후, 수정에 의해 유입된 오류가 없는지 테스트</li>
  <li><code class="language-plaintext highlighter-rouge">병행 테스트(Parallel)</code> : 변경된 시스템과 기존 시스템에 동일 데이터 입력 후 결과값 비교</li>
</ol>

<h2 id="테스트-시각에-따른-분류">테스트 시각에 따른 분류</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">검증(Verification)</code> : 개발자 시점, 규격(명세기능)을 만족하는가</li>
  <li><code class="language-plaintext highlighter-rouge">확인(Validation)</code> : 사용자 시점, 올바른 SW</li>
</ol>

<h2 id="정적-테스트-종류">정적 테스트 종류</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">리뷰</code> : SW의 결함을 검출하거나 진행 상황을 파악하는 활동으로 전문가가 수행
    <ul>
      <li>리뷰의 유형
        <ol>
          <li>관리 리뷰</li>
          <li>기술 리뷰(=코드 리뷰)</li>
          <li>인스펙션 : 저작자가 아닌 다른 전문가가 검토</li>
          <li>워크스루 : 사전에 자료 배포 후 짧은 회의</li>
          <li>감사 : 표준 준수 확인, 제3기관 수행</li>
        </ol>
      </li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">정적 분석</code> : 분석 도구의 도움을 받아 수행(소스코드 실행 안 함). 코딩 표준, 소스코드 복잡도 검사</li>
</ol>

<h3 id="화이트박스-테스트">화이트박스 테스트</h3>
<ul>
  <li>모듈 내부 구조, 논리 경로를 테스트(구조 기반 테스트, 동적 테스트)</li>
  <li>유형
    <ol>
      <li><code class="language-plaintext highlighter-rouge">구문 커버리지</code> : 모든 명령문을 한 번 이상 수행. 결과에 무관하게 구문 실행 개수로 측정</li>
      <li><code class="language-plaintext highlighter-rouge">결정 커버리지(=선택 커버리지, 분기 커버리지)</code> : 결정 포인트 내 개별 조건식이 참/거짓을 한 번씩 수행</li>
      <li><code class="language-plaintext highlighter-rouge">조건 커버리지</code> : 결정 포인트 내 개별 조건식이 참/거짓을 한 번씩 수행(전체 조건식에 주는 영향은 고려하지 않음)</li>
      <li><code class="language-plaintext highlighter-rouge">조건/결정 커버리지</code> : 결정 포인트 내 전체 조건식도 참/거짓을 한 번씩, 개별 조건식도 참/거짓을 한 번씩 수행)</li>
      <li><code class="language-plaintext highlighter-rouge">변경 조건/결정 커버리지</code> : 결정 포인트 내 개별 조건식이 다른 개별 조건식의 영향을 받지 않고 전체 조건식에 독립적으로 영향을 주도록 수행</li>
      <li><code class="language-plaintext highlighter-rouge">다중 조건 커버리지</code> : 모든 개별 조건식의 가능한 조합을 100% 보장
        <ul>
          <li>개별 조건식의 수가 N이라고 했을 때, 2^N의 결과가 나옴. 즉 개별조건식이 2개면 2^2=4, 3개면 2^3=8개</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">기본 경로 커버리지</code> : 맥케이브의 순환복잡도를 기반으로 수행 가능한 모든 경로를 테스트
        <ul>
          <li>순환복잡도 계산 : V=E-N+2 또는 V=P+1</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">제어 흐름 테스트</code> : 제어 구조를 그래프로 나타내어 테스트</li>
      <li><code class="language-plaintext highlighter-rouge">데이터 흐름 테스트</code> : 제어 흐름 그래프에 데이터 사용 현황을 추가한 그래프를 통해 테스트</li>
    </ol>
  </li>
</ul>

<h3 id="블랙박스-테스트">블랙박스 테스트</h3>
<ul>
  <li>요구사항 명세를 보며 기능 위주 테스트(명세 기반 테스트, 동적 테스트)</li>
  <li>유형
    <ol>
      <li><code class="language-plaintext highlighter-rouge">상태 전이 테스트</code> : 이벤트에 의해 객체 상태가 전이되는 경우의 수를 측정
        <ul>
          <li>상태 전이도 모델링 -&gt; 전이 트리 도출 -&gt; 전이 경로 TC -&gt; 비정상 전이 TC</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">원인-결과 그래프 테스트</code> : 그래프를 통해 입력값 간의 관계 및 출력에 미치는 영향을 분석해 효용성이 높은 TC를 선택해 테스트</li>
      <li><code class="language-plaintext highlighter-rouge">동치 분할 테스트</code> : 입력 데이터 영역을 유효값/무효값으로 그룹핑해 대표값 TC를 도출해 테스트</li>
      <li><code class="language-plaintext highlighter-rouge">경계값 분석 테스트</code> : 최소값을 바로 위나 아래와 같이 입력 데이터의 극한 한계를 테스트(2-Value, 3-Value)</li>
      <li><code class="language-plaintext highlighter-rouge">비교 테스트</code> : 여러 버전의 프로그램에 같은 입력값을 넣어 결과를 비교</li>
      <li><code class="language-plaintext highlighter-rouge">분류 트리 테스트</code> : 트리 구조로 분석 및 표현하여 테스트
        <ul>
          <li>항목 선정 -&gt; 분류 트리 구축 -&gt; 불류 클래스 조합해 TC 생성</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">페어와이즈 테스트</code> : 테스트 데이터값을 최소 한 번씩 조합</li>
      <li><code class="language-plaintext highlighter-rouge">유스케이스 테스트</code> : 유스케이스로 모델링 되어있을 때, 프로세스 흐름 기반으로 테스트 수행</li>
      <li><code class="language-plaintext highlighter-rouge">결과 테이블 테스트</code> : 요구사항을 테이블로 구성해 원인(조건)-결과(행위)를 조합해 테스트</li>
    </ol>
  </li>
</ul>

<h3 id="경험-기반-테스트">경험 기반 테스트</h3>
<ul>
  <li>테스터의 경험과 직관을 기반으로 한 테스트</li>
  <li>유형
    <ol>
      <li><code class="language-plaintext highlighter-rouge">특성테스트</code> : ISO/IEC 9126 등 표준 품질 특성을 염두에 두고 테스트 수행</li>
      <li><code class="language-plaintext highlighter-rouge">탐색적 테스트</code> : TC 명세화 없이 경험에 의존해 탐색적으로 테스트 수행(테스터의 휴리스틱한 능력 필요)</li>
      <li><code class="language-plaintext highlighter-rouge">오류 추정</code> : 개발자가 범하기 쉬운 실수를 추정하고 이에 맞춰 테스트</li>
      <li><code class="language-plaintext highlighter-rouge">체크리스트</code> : 테스트 내용을 목록화하여 테스트(재사용 목적)</li>
    </ol>
  </li>
</ul>

<h2 id="테스트-오라클">테스트 오라클</h2>
<ul>
  <li>테스트 결과가 참/거짓인지 판단하기 위해 사전에 정의된 참값을 입력해 비교하는 기법</li>
  <li>유형
    <ol>
      <li><code class="language-plaintext highlighter-rouge">참 오라클</code> : 모든 입력값의 기대결과를 생성(오류를 모두 검출 가능)</li>
      <li><code class="language-plaintext highlighter-rouge">샘플링 오라클</code> : 특정 몇 개 입력값의 기대결과만 생성</li>
      <li><code class="language-plaintext highlighter-rouge">휴리스틱 오라클 (Heuristic)</code> : 몇 개 입력값에 대해서는 정확한 결과를 제공하고 나머지는 휴리스틱으로 처리(샘플링 오라클 개선)</li>
      <li><code class="language-plaintext highlighter-rouge">일관성 검사 오라클 (Consistent)</code> : 변경이 있을 때 수행 전후 결과값이 동일한지 확인</li>
    </ol>
  </li>
</ul>

<h2 id="테스트-레벨">테스트 레벨</h2>
<ul>
  <li>개발 단계에 따라 테스트를 분류한 것</li>
  <li>유형
    <ol>
      <li><code class="language-plaintext highlighter-rouge">단위 테스트</code> : 설계 최소 단위인 모듈, 컴포넌트, 서브 루틴 등을 테스트</li>
      <li><code class="language-plaintext highlighter-rouge">통합 테스트</code> : 단위 테스트를 통과한 모듈 간 인터페이스, 컴포넌트 상호작용 등을 테스트
        <ul>
          <li><code class="language-plaintext highlighter-rouge">빅뱅 테스트</code> : 모든 컴포넌트를 통합해 한꺼번에 테스트(비점증적 방식)</li>
          <li><code class="language-plaintext highlighter-rouge">상향식 테스트</code> : 최하위 모듈부터 위 방향으로 통합하며 테스트
            <ol>
              <li>하위 모듈을 클러스터로 결합(클러스터링)</li>
              <li>드라이버 개발</li>
              <li>통합된 클러스터 테스트</li>
              <li>드라이버를 실제 모듈로 대체</li>
            </ol>
          </li>
          <li><code class="language-plaintext highlighter-rouge">하향식 테스트</code> : 메인 제어 모듈로부터 아래 방향으로 통합하며 테스트
            <ol>
              <li>초기에 시스템 구조 파악</li>
              <li>스텁 개발</li>
              <li>깊이-우선 또는 너비-우선 방식에 따라 스텁을 실제 모듈로 대체</li>
            </ol>
          </li>
          <li><code class="language-plaintext highlighter-rouge">샌드위치 테스트</code> : 상위모듈은 하향식, 하위 모듈은 상향식 테스트를 수행</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">시스템 테스트</code> : 통합된 단위시스템 검증(기능적 요구사항 테스트, 비기능적 요구사항 테스트)</li>
      <li><code class="language-plaintext highlighter-rouge">인수 테스트</code> : 계약상 요구사항을 만족하는지 확인
        <ul>
          <li><code class="language-plaintext highlighter-rouge">알파 테스트</code> : 통제된 환경에서 선택된 사용자가 개발자랑 확인</li>
          <li><code class="language-plaintext highlighter-rouge">베타 테스트</code> : 실제 환경에서 확인</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h2 id="테스트-하네스">테스트 하네스</h2>
<ul>
  <li>단위 테스트를 지원하기 위한 코드와 데이터</li>
  <li>유형
    <ul>
      <li><code class="language-plaintext highlighter-rouge">목 객체</code> : 사전에 조건을 입력하면 그 상황에 예정된 행위를 수행하는 가짜 객체
        <ul>
          <li>유형
            <ol>
              <li><code class="language-plaintext highlighter-rouge">테스트 스텁</code> : 특정 값을 리턴하거나 메시지를 출력하는 등 단순 기능을 수행하는 더미 모듈(하향식 테스트에서 사용)</li>
              <li><code class="language-plaintext highlighter-rouge">테스트 드라이버</code> : 하위 모듈을 호출하거나 파라미터를 전달하는 모듈(상향식 테스트에서 사용)</li>
              <li><code class="language-plaintext highlighter-rouge">테스트 스파이</code> : 테스트 대상 클래스와 협력 클래스로 가는 출력을 검증하는 데 사용</li>
              <li><code class="language-plaintext highlighter-rouge">가짜 객체</code> : 협력 클래스 기능을 대체하기 위해 사용</li>
            </ol>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="테스트-자동화-도구-유형">테스트 자동화 도구 유형</h2>
<ol>
  <li>정적 분석 도구 : 실행하지 않고 소스 코드를 테스트</li>
  <li>테스트 실행 도구 : 작성된 스크립트를 실행해 테스트(데이터 주도 접근 방식 vs. 키워드 주도 접근 방식)</li>
  <li>성능 테스트 도구</li>
  <li>테스트 통제 도구 : 형상 관리 도구, 결함 추적 도구 등</li>
</ol>

<h2 id="테스트-리포팅">테스트 리포팅</h2>
<ol>
  <li>테스트 결과 정리</li>
  <li>테스트 요약문서 작성</li>
  <li>품질 상태 파악</li>
  <li>결과서 작성</li>
  <li>테스트 실행 절차 리뷰 및 평가</li>
</ol>

<h2 id="테스트-커버리지">테스트 커버리지</h2>
<ul>
  <li>테스트의 수행 정도를 나타내는 값
    <ol>
      <li><code class="language-plaintext highlighter-rouge">기능 기반 커버리지</code> : 전체 기능을 모수로 측정</li>
      <li><code class="language-plaintext highlighter-rouge">라인 커버리지</code> : 소스 코드 라인 수를 모수로 측정</li>
      <li><code class="language-plaintext highlighter-rouge">코드 커버리지</code> : 구문(코드) 자체가 얼마나 테스트됐는가를 측정(커버리지라 함은 대부분 코드 커버리지를 가리킴)<br /><br /></li>
    </ol>
  </li>
</ul>

<h1 id="소프트웨어-결함">소프트웨어 결함</h1>
<ul>
  <li>Error/오류 : 사람에 의해 생성됨. Defect(결함)의 원인</li>
  <li>Defect / Bug : Error로 인해 포함된 결함. 제거되지 않으면 Failure나 Problem이 됨</li>
  <li>Failure / Problem : Defect가 실행될 때 발생하는 현상</li>
</ul>

<h2 id="결함-관리-프로세스">결함 관리 프로세스</h2>
<ol>
  <li>결함 관리 계획</li>
  <li>결함 관리 DB에 기록</li>
  <li>결함 검토</li>
  <li>결함 수정</li>
  <li>결함 재검토</li>
  <li>결함 추적 및 모니터링</li>
  <li>최종 결함 분석 및 보고서 작성</li>
</ol>

<h2 id="결함-생명주기">결함 생명주기</h2>
<ul>
  <li>Open -&gt; Review -&gt; Assigned -&gt; Resolved -&gt; Verified -&gt; Closed -&gt; Deferred -&gt; Reopen -&gt; Closed</li>
</ul>

<h2 id="결함-분석-방법">결함 분석 방법</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">고립화</code> : 입력값, 절차, 환경 중 무엇이 영향을 미치는지 파악</li>
  <li><code class="language-plaintext highlighter-rouge">구체화</code> : 입력값, 절차, 환경을 정확히 파악</li>
  <li><code class="language-plaintext highlighter-rouge">일반화</code> : 결함에 영향을 주는 요소를 최대한 일반화</li>
</ol>

<h3 id="결함-분석">결함 분석</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">결함 추이 분석</code> : 결함 지표를 분석해 추후 발생될 결함을 추정하는 작업</li>
  <li><code class="language-plaintext highlighter-rouge">결함 분포 분석</code> : 특정 속성에 해당하는 결함 수를 측정</li>
  <li><code class="language-plaintext highlighter-rouge">결함 추세 분석</code> : 테스트 시간 흐름에 따른 결함 수를 측정</li>
  <li><code class="language-plaintext highlighter-rouge">결함 에이징 분석</code> : 특정 결함의 지속 시간을 측정</li>
</ul>

<h2 id="결함-분류">결함 분류</h2>
<ol>
  <li>시스템 결함(비정상적인 종료, DB 에러)</li>
  <li>기능 결함(요구사항 불일치, 스크립트 에러)</li>
  <li>GUI 결함(부정확한 메세지)</li>
  <li>문서 결함(매뉴얼 불일치)</li>
</ol>

<h2 id="결함-심각도">결함 심각도</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">Critical(치명적)</code> : 테스트 불가할 정도</li>
  <li><code class="language-plaintext highlighter-rouge">Major(주요)</code> : 기능이 기대와 다르게 동작</li>
  <li><code class="language-plaintext highlighter-rouge">Normal(보통)</code> : 사소한 기능 오작동</li>
  <li><code class="language-plaintext highlighter-rouge">Minor(경미)</code> : UI 오류</li>
  <li><code class="language-plaintext highlighter-rouge">Simple(단순)</code> : 미관성 해침</li>
</ol>

<h3 id="결함-우선순위">결함 우선순위</h3>
<ol>
  <li>Critical : 이 결함으로 전체 기능 미동작</li>
  <li>High : 이 결함으로 다른 기능 미동작</li>
  <li>Medium</li>
  <li>Low</li>
</ol>

<h2 id="성능-분석">성능 분석</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">처리량</code> : 주어진 시간에 처리 가능한 트랜잭션(웹 페이지) 수</li>
  <li><code class="language-plaintext highlighter-rouge">응답시간</code> : 사용자 입력 -&gt; 응답 출력 개시까지 걸린 시간</li>
  <li><code class="language-plaintext highlighter-rouge">경과시간</code> : 사용자 입력 -&gt; 트랜잭션 처리 -&gt; 결과 출력까지 걸린 시간</li>
  <li><code class="language-plaintext highlighter-rouge">자원 사용률</code> : 트랜잭션 처리 동안 사용하는 자원 사용량</li>
</ol>

<h3 id="성능-테스트-수행-방법">성능 테스트 수행 방법</h3>
<ol>
  <li>성능 테스트 도구 설치</li>
  <li>환경설정</li>
  <li>시나리오 작성</li>
  <li>성능 테스트 실행 및 모니터링</li>
</ol>

<h3 id="성능-저하-원인---db-관련">성능 저하 원인 - DB 관련</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">DB Lock</code> : Lock 해제 시까지 타임 아웃</li>
  <li><code class="language-plaintext highlighter-rouge">불필요한 DB Fetch</code> : 대량의 데이터 요청으로 응답 시간 저하, 결과 세트에서 마지막 위치로 커서 옮기는 작업 빈번 시 응답 저하</li>
  <li><code class="language-plaintext highlighter-rouge">연결 누수 Connection Leak</code> : JDBC 객체 사용 후 미종료</li>
  <li><code class="language-plaintext highlighter-rouge">부적절한 DB Connection Pool Size</code> : 커넥션 풀이 너무 작거나 큼</li>
  <li><code class="language-plaintext highlighter-rouge">커밋 관련</code> : 트랜잭션이 커밋되지 않고 반환되거나 불필요한 커밋이 잦음</li>
</ol>

<h2 id="리팩토링">리팩토링</h2>
<ul>
  <li>기능을 변경하지 않고 내부 코드를 보완해 유지보수성을 향상시키는 것</li>
  <li>목적 : 유지보수성 향상, 품질 향상, 생산성 향상, 유연한 시스템</li>
</ul>

<h2 id="클린-코드">클린 코드</h2>
<ul>
  <li>잘 작성되어 가독성 높고 단순한 코드</li>
  <li>작성원칙
    <ol>
      <li>가독성</li>
      <li>단순성</li>
      <li>의존성 최소화</li>
      <li>중복 제거</li>
      <li>추상화</li>
    </ol>
  </li>
</ul>

<h3 id="베드-코드">베드 코드</h3>
<ul>
  <li>다른 개발자가 로직을 이해하기 어려운 코드</li>
  <li><code class="language-plaintext highlighter-rouge">외계인 코드</code> : 아주 오래되거나 참고할 개발자/문서가 없어 유지보수가 힘든 코드</li>
  <li><code class="language-plaintext highlighter-rouge">스파게티 코드</code> : 동작은 하지만 내부 코드가 복잡하여 파악이 어려운 코드</li>
</ul>

<h3 id="베드-코드-유형">베드 코드 유형</h3>
<ol>
  <li>오염 : 비즈니스 기능을 수행하지 못하는 컴포넌트가 많음</li>
  <li>문서 부족 : 코드와 문서 불일치</li>
  <li>의미없는 이름</li>
  <li>높은 결합도</li>
  <li>아키텍처 침식 : 아키텍처가 변형되어 품질 저하</li>
</ol>

<h3 id="코드-품질-분석-도구">코드 품질 분석 도구</h3>
<ul>
  <li>정적 분석 도구 : pmd, cppcheck, SonarQube, checkstyle, cobertuna</li>
  <li>동적 분석 도구 : Avalance, Valgrind<br /><br /></li>
</ul>

<h1 id="os-운영체제">OS (운영체제)</h1>
<ul>
  <li>사용자가 하드웨어를 쉽게 사용할 수 있도록 인터페이스 기능을 제공하는 소프트웨어</li>
</ul>

<h2 id="os의-특징">OS의 특징</h2>
<ol>
  <li>사용자 편리성 제공</li>
  <li>인터페이스 기능 제공</li>
  <li>스케줄링 담당 : 자원 분배</li>
  <li>자원 관리 : CPU, 메모리 관리</li>
  <li>제어 기능 : 입출력 장치 등</li>
</ol>

<h2 id="os의-쉘">OS의 쉘</h2>
<ul>
  <li>사용자 명령에 대한 처리를 담당</li>
  <li>사용자 명령을 입력받아 기계어 형태로 변환해 커널에 전달</li>
</ul>

<h2 id="os의-커널">OS의 커널</h2>
<ul>
  <li>하드웨어와 관련된 핵심 처리 기능 담당</li>
</ul>

<h2 id="windows의-특징">Windows의 특징</h2>
<ol>
  <li>GUI 제공</li>
  <li>선점형 멀티태스킹 방식 제공 : 동시에 여러 프로그램을 실행하면서 자원 사용을 제어</li>
  <li>자동 감지 기능 제공 : HW 설치 시 환경 구성</li>
  <li>OLE 기능 제공 : 문서에 개체 삽입/연결</li>
</ol>

<h2 id="windows-기본-명령어">Windows 기본 명령어</h2>
<ul>
  <li>ATTRIB : 파일 속성 표시</li>
  <li>CALL : 일괄 프로그램에서 다른 일괄 프로그램 호출</li>
  <li>CD : 디렉토리 표시</li>
  <li>CHKDSK : 디스크 검사</li>
  <li>CLS : 화면 지움</li>
  <li>CMD : 명령 프롬프트 실행</li>
  <li>COMP : 두 개 이상 파일 비교</li>
  <li>DISKPART : 파티션 구성 표시</li>
  <li>ECHO : 메시지 표시</li>
  <li>ERASE : 파일 삭제</li>
  <li>EXIT : 인터프리터 종료</li>
</ul>

<h2 id="unix의-특징">Unix의 특징</h2>
<ol>
  <li>대화식 운영체제 기능 : 명령어 입력 시 해당 명령어 수행</li>
  <li>다중 작업 기능</li>
  <li>다중 사용자 기능</li>
  <li>이식성 제공</li>
  <li>계층 트리 구조 파일 시스템 기능 제공</li>
</ol>

<h2 id="linux">Linux</h2>
<ul>
  <li>Unix 기반의 오픈 소스 운영 체제</li>
</ul>

<h2 id="mac-os">Mac OS</h2>
<ul>
  <li>Unix 기반의 GUI 운영 체제</li>
</ul>

<h2 id="andoroid">Andoroid</h2>
<ul>
  <li>Linux 기반의 휴대용 장치를 위한 운영체제</li>
</ul>
:ET