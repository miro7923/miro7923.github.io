I"P<ul>
  <li>최근 미뤄뒀던 정보처리기사 실기를 준비하며… 꼭 외워야 하는 내용 정리 🥲<br /><br /></li>
</ul>

<h1 id="소프트웨어-아키텍처-패턴">소프트웨어 아키텍처 패턴</h1>
<ul>
  <li>소프트웨어 설계 시 참조 가능한 솔루션</li>
  <li>일반적으로 발생하는 문제점들에 대해 일반화되고 재사용 가능한 솔루션<br /><br /></li>
</ul>

<h1 id="요구공학-관리-단계-구성cmm-level-2">요구공학 관리 단계 구성(CMM Level 2)</h1>
<ol>
  <li>협상 : 구현 가능한 기능 협상</li>
  <li>기준선 설정 : 기준선(베이스라인) 설정
    <ul>
      <li>베이스라인 : 개발 과정의 산출물의 변화를 통제하는 시점</li>
    </ul>
  </li>
  <li>변경관리 : 형상통제 위원회를 운영하여 변경 관리
    <ul>
      <li>CCB : 형상 관리의 방침을 정하고 산출물을 검토하는 조직</li>
    </ul>
  </li>
  <li>확인 및 검증 : 요구사항에 부합하는지 확인<br /><br /></li>
</ol>

<h1 id="요구사항-확인-기법">요구사항 확인 기법</h1>
<ol>
  <li>정형 기술 검토(TCR)</li>
  <li>프로토타이핑 활용</li>
  <li>테스트 케이스를 통한 확인</li>
  <li>CASE 도구 활용</li>
  <li>베이스라인 검증</li>
  <li>요구사항 추적표 (RTM : Requirement Tracebility Matrix) 통해 검증
    <ul>
      <li>요구사항 정의서 기준으로 개발단계별 최종 산출물이 어떻게 변경되었는지 확인 가능한 문서<br /><br /></li>
    </ul>
  </li>
</ol>

<h1 id="정형-기술-검토-tcr-기법">정형 기술 검토 (TCR) 기법</h1>
<ul>
  <li>동료 검토 (Peer Review) : 작성자가 설명하고, 이해 관계자들이 설명을 들으며 결함 발견</li>
  <li>워크 스루 (Walk Through) : 검토 자료 사전 배포 후, 짧은 시간 동안 회의 진행</li>
  <li>인스펙션 (Inspection) : 저작자가 아닌 다른 전문가가 검토</li>
  <li>참가자 구성
    <ul>
      <li>주재자(Moderator) : 참가자를 선정하고 계획 및 주재</li>
      <li>작성자</li>
      <li>낭독자</li>
      <li>기록자</li>
      <li>검토자</li>
    </ul>
  </li>
  <li>관리 리뷰 (Management Review) : 프로젝트 진행 상황을 전반적으로 검토</li>
  <li>기술 리뷰 (Technical Review) : 명세를 준수하고 있는지 검토</li>
  <li>감사 (Audit) : 제품이 표준이나 가이드라인을 준수하는지 검토. 제품 제공자, 소비자, 제 3기관이 수행<br /><br /></li>
</ul>

<h1 id="요구사항-명세-원리-및-검증-항목">요구사항 명세 원리 및 검증 항목</h1>
<ol>
  <li>명확성 : 각 명세 내용은 하나의 의미만 부여</li>
  <li>완전성 : 모든 요구사항이 포함되어야 함</li>
  <li>검증 가능성 : 달성 정도를 확인할 수 있어야 함</li>
  <li>일관성 : 모순이 없어야 함</li>
  <li>수정 용이성 : 쉽게 수정할 수 있어야 함</li>
  <li>개발 후 이용성 : 운영 및 유지보수에 이용이 가능해야 함</li>
  <li>추적 가능성 : 추적이 가능해야 함<br /><br /></li>
</ol>

<h1 id="요구사항-명세-기법">요구사항 명세 기법</h1>
<ol>
  <li>비정형 명세 기법 : 자연어 기반 서술</li>
  <li>정형 명세 기법 : 수학적 표기법으로 서술<br /><br /></li>
</ol>

<h1 id="요구사항-분석-단계">요구사항 분석 단계</h1>
<ol>
  <li>요구사항 분류 : 기능적 요구사항 (시스템이 제공해야 할 기능) vs 비기능적 요구사항(시스템이 준수해야 할 제약사항)</li>
  <li>개념 모델링 생성 : 주로 UML 사용. 요구사항을 쉽게 이해할 수 있도록 개념적 표현</li>
  <li>요구사항 할당 : 요구사항 만족을 위한 아키텍처 구성요소 식별</li>
  <li>요구사항 협상 : 충돌되는 경우 합의, 우선순위 부여</li>
  <li>정형 분석 : 정형화된 언어를 통해 수학적 기호로 표현<br /><br /></li>
</ol>

<h1 id="요구사항-도출-기법">요구사항 도출 기법</h1>
<ul>
  <li>인터뷰 : 직접 대화</li>
  <li>브레인스토밍 : 말하기 쉬운 분위기 속에서 비판없이 의견을 수용</li>
  <li>델파이 기법 : 전문가 경험 활용</li>
  <li>롤 플레잉 : 각자 맡은 역을 연기</li>
  <li>워크숍 : 단기간 집중하여 정보 획득 후 공유(사전 준비 필요)</li>
  <li>설문 조사<br /><br /></li>
</ul>

<h1 id="요구공학">요구공학</h1>
<ul>
  <li>요구사항을 도출, 분석, 명세, 확인하는 구조화된 활동<br /><br /></li>
</ul>

<h1 id="요구공학-개발-단계-구성-cmm-level-3">요구공학 개발 단계 구성 (CMM Level 3)</h1>
<ol>
  <li>도출 : 이해관계자 식별, 고객 분석</li>
  <li>분석 : 분류 -&gt; 개념 모델링 생성 -&gt; 할당 -&gt; 협상 -&gt; 분석</li>
  <li>명세 : 정형화된 형태로 명세 작성</li>
  <li>확인 : 요구사항 이해를 확인하고 문서가 완전한지 검증<br /><br /></li>
</ol>

<h1 id="요구공학-프로세스">요구공학 프로세스</h1>
<ol>
  <li>개발 단계(CMM Level 3) : 요구사항 분석</li>
  <li>관리 단계 (CMM Levle 2) : 설계 - 개발 - 테스트를 거치는 동안 요구사항 잘 만족하는지 확인<br /><br /></li>
</ol>

<h1 id="요구사항-분석-기법">요구사항 분석 기법</h1>
<ul>
  <li>자료 흐름 지향 분석 : 데이터 흐름도(DFD)와 자료 사전(DD)을 통해 분석</li>
  <li>객체지향 분석 : 시스템 기능과 데이터를 함께 분석해 UML로 표준화<br /><br /></li>
</ul>

<h1 id="미들웨어">미들웨어</h1>
<ul>
  <li>컴퓨터와 컴퓨터 간 연결 및 연결 관리를 돕는 소프트웨어<br /><br /></li>
</ul>

<h1 id="dbms">DBMS</h1>
<ul>
  <li>데이터베이스를 관리할 수 있는 응용 프로그램<br /><br /></li>
</ul>

<h1 id="dbms-분석-시-고려-사항">DBMS 분석 시 고려 사항</h1>
<ol>
  <li>성능 측면 - 가용성, 성능, 상호 호환성</li>
  <li>지원 측면 - 기술 지원, 구축 비용<br /><br /></li>
</ol>

<h1 id="네트워크">네트워크</h1>
<ul>
  <li>원하는 정보를 수신자에게 정확하게 전달하기 위한 인프라<br /><br /></li>
</ul>

<h1 id="osi-7계층">OSI 7계층</h1>
<ul>
  <li>네트워크 통신에서 충돌 문제를 최소화하고자, 국제표준화기구(ISO)에서 제시한 네트워크 통신 규약</li>
  <li>물데네트세표응!</li>
</ul>

<h2 id="물리-계층">물리 계층</h2>
<ul>
  <li>데이터를 전기적인 신호로 변환시켜 통신
    <ol>
      <li>단위 : 비트</li>
      <li>프로토콜 : RS-232C</li>
      <li>장비 : 허브, 리피터<br /><br /></li>
    </ol>
  </li>
</ul>

<h3 id="물리-계층-장비">물리 계층 장비</h3>
<ul>
  <li>허브 : 여러 대의 컴퓨터를 연결해 네트워크로 보내거나, 하나의 네트워크로 수신된 정보를 여러 대의 컴퓨터로 보내는 장비</li>
  <li>리피터 : 디지털 신호를 증폭시키는 장비<br /><br /></li>
</ul>

<h2 id="데이터링크-계층">데이터링크 계층</h2>
<ul>
  <li>노드 간 오류 제어, 흐름 제어, 회선 제어
    <ol>
      <li>단위 : 프레임</li>
      <li>장비 : L2 스위치, 브릿지, NIC, 스위칭 허브</li>
      <li>프로토콜 : HDLC, PPP, Frame Relay, ATM<br /><br /></li>
    </ol>
  </li>
</ul>

<h3 id="데이터링크-계층-장비">데이터링크 계층 장비</h3>
<ul>
  <li>L2 스위치 : 목적지 MAC 주소를 기반으로 빠르게 데이터를 전송하는 장비
    <ol>
      <li>Store and Forwarding : 데이터를 전부 받은 후 처리</li>
      <li>Cut Through : 목적지 주소만 확인 후 바로 전송</li>
      <li>Fragment Frame : 앞 64비트만 읽어 에러 처리 후 전송</li>
    </ol>
  </li>
  <li>브릿지 : LAN과 LAN을 연결하는 장비</li>
  <li>NIC : 네트워크 인터페이스 카드. 외부 네트워크와 빠른 통신을 위해 컴퓨터 내에 설치되는 장비</li>
  <li>스위칭 허브 : 스위치 기능을 가진 허브<br /><br /></li>
</ul>

<h3 id="데이터링크-계층-프로토콜">데이터링크 계층 프로토콜</h3>
<ul>
  <li>HDLC : 점대점, 다중점 통신에 사용하는 프로토콜</li>
  <li>PPP : 통신 노드 간 연결을 위한 프로토콜</li>
  <li>Frame Relay : 프레임 간 중계기능, 다중화 기능을 통해 빠른 데이터 전송이 가능한 고속 전송 기술</li>
  <li>ATM : 고정 크기 단위로 전송하는 비동기식 전송 기술<br /><br /></li>
</ul>

<h2 id="네트워크-계층">네트워크 계층</h2>
<ul>
  <li>데이터 전송을 위한 최적의 경로 설정
    <ol>
      <li>단위 : 패킷</li>
      <li>장비 : L3 스위치, 라우터, 게이트웨이, 인터넷 공유기, 망(백본) 스위칭 허브</li>
      <li>프로토콜 : IP, 라우팅 프로토콜, ARP, RARP, ICMP, IGMP</li>
    </ol>
  </li>
</ul>

<h3 id="네트워크-계층-장비">네트워크 계층 장비</h3>
<ul>
  <li>L3 스위치 : 3계층에서 동작하는 스위치 (L2 스위치 기능 + L3 라우터 기능을 모두 갖춘 장비)</li>
  <li>라우터 : 최적의 경로를 지정하고 경로에 따라 전송시키는 장비</li>
  <li>게이트웨이 : 다른 통신망에 접속할 수 있게 해주는 장비</li>
  <li>인터넷 공유기 : 하나의 인터넷 라인을 여러 컴퓨터가 공유할 수 있게 해주는 장비</li>
  <li>망(백본) 스위칭 허브 : 광역 네트워크를 커버하는 스위칭 허브</li>
</ul>

<h3 id="네트위크-계층-프로토콜">네트위크 계층 프로토콜</h3>
<ul>
  <li>IP : 패킷 단위의 네트워크 통신 프로토콜</li>
  <li>라우팅 프로토콜 : 최적의 데이터 전송 경로를 설정하는 프로토콜</li>
  <li>ARP : IP주소(3계층)를 MAC 주소(2계층)으로 변환하는 프로토콜</li>
  <li>RARP : MAC 주소는 알지만 IP 주소를 모를 때 사용하는 프로토콜</li>
  <li>ICMP : IP 패킷 처리 시의 문제를 알려주는 프로토콜</li>
  <li>IGMP : 멀티캐스트 실시간 전송을 위해 사용하는 프로토콜(화상회의 등)<br /><br /></li>
</ul>

<h2 id="전송계층transport">전송계층(Transport)</h2>
<ul>
  <li>종단 간 신뢰성있고 효율적으로 데이터 전송
    <ol>
      <li>단위 : 세그먼트</li>
      <li>장비 : L4 스위치</li>
      <li>프로토콜 : TCP, UDP</li>
    </ol>
  </li>
</ul>

<h3 id="전송계층-장비">전송계층 장비</h3>
<ul>
  <li>L4 스위치 : OSI 4계층에서 네트워크 단위를 연결하는 장비. TCP/UDP 등 스위칭 수행</li>
</ul>

<h3 id="전송계층-프로토콜">전송계층 프로토콜</h3>
<ul>
  <li>TCP
    <ol>
      <li>신뢰성 보장 : 패킷 손실, 중복이 없도록 보장 (IP 계층 보완)</li>
      <li>연결지향적 : 연결 회선을 통해 통신이 이뤄짐</li>
      <li>흐름제어 : 송신-수신 속도 일치시킴</li>
      <li>혼잡제어 : 네트워크 혼잡도에 따라 송신율 제어</li>
    </ol>
  </li>
  <li>TCP 헤더 구조
    <ol>
      <li>Source Port Number</li>
      <li>Destination Port Number</li>
      <li>Sequence Number : 신뢰성과 흐름 담당</li>
      <li>Acknowledgement Number : 승인 번호(수신을 기대하는 다음 번호)</li>
      <li>HLEN : 헤더 길이</li>
      <li>Flag Bit : 값 유효 여부 등을 표시하는 플래그</li>
      <li>Window Size</li>
      <li>Checksum : 에러 확인</li>
      <li>Urgent Pointer : 시퀀스 번호로부터의 옵셋</li>
      <li>Options and Padding</li>
    </ol>
  </li>
  <li>UDP
    <ol>
      <li>비신뢰성 : 메시지의 도착을 보장하지 않음</li>
      <li>비순서화 : 수신된 메시지 순서 맞추지 않음</li>
      <li>실시간 응용 및 멀티캐스팅 가능</li>
      <li>단순 헤더 (고정 크기 헤더)</li>
    </ol>
  </li>
  <li>UDP 헤더 구조
    <ol>
      <li>Source Port Number</li>
      <li>Destination Port Number</li>
      <li>UDP Length</li>
      <li>UDP Checksum</li>
      <li>Data<br /><br /></li>
    </ol>
  </li>
</ul>

<h2 id="세션계층-session">세션계층 (Session)</h2>
<ul>
  <li>송수신간 연결을 제어
    <ol>
      <li>단위 : 데이터</li>
      <li>프로토콜 : RPC, NetBIOS, SSH, SSL/TLS</li>
    </ol>
  </li>
</ul>

<h3 id="세션계층-프로토콜">세션계층 프로토콜</h3>
<ul>
  <li>RPC : 원격 프로시저 호출. 다른 주소 공간에 있는 프로세스 실행 가능</li>
  <li>NetBIOS : 응용계층의 애플리케이션에 API 제공</li>
  <li>SSH : 보안 쉘. 원격 호스트에 접근하기 위한 프로토콜</li>
  <li>SSL/TLS : 안전한 데이터 전송을 위한 보안 프로토콜 (4계층(응용) - 7계층(전송) 사이에서 안전한 데이터 전송을 보장)<br /><br /></li>
</ul>

<h2 id="표현계층-presentaion">표현계층 (Presentaion)</h2>
<ul>
  <li>응용프로그램의 데이터를 통신에 알맞은 형태로 만들거나, 하위 계층의 데이터를 사용자가 이해할 수 있는 형태로 만드는 계층
    <ol>
      <li>단위 : 데이터</li>
      <li>프로토콜 : JPEG, MPEG</li>
    </ol>
  </li>
</ul>

<h3 id="표현계층-프로토콜">표현계층 프로토콜</h3>
<ul>
  <li>JPEG : 이미지를 위한 표준 규격</li>
  <li>MPEG : 멀티미디어를 위한 표준 규격<br /><br /></li>
</ul>

<h2 id="응용계층-application">응용계층 (Application)</h2>
<ul>
  <li>사용자가 OSI 환경에 접근할 수 있도록 서비스(인터페이스)를 제공하는 계층
    <ol>
      <li>단위 : 데이터</li>
      <li>프로토콜 : HTTP, FTP, SMTP, POP3, IMAP, Telnet</li>
    </ol>
  </li>
</ul>

<h3 id="응용계층-프로토콜">응용계층 프로토콜</h3>
<ul>
  <li>HTTP : 인터넷에서 데이터를 주고받기 위한 텍스트 기반의 프로토콜</li>
  <li>FTP : 서버-클라이언트 간 파일 전송을 위한 프로토콜</li>
  <li>SMTP : 이메일을 보내기 위한 프로토콜</li>
  <li>POP3 : 이메일을 가져오기 위한 프로토콜 (로컬 PC에 저장 후 불러옴)</li>
  <li>IMAP : 이메일을 가져오기 위한 프로토콜 (메일 서버에서 불러옴)</li>
  <li>Telnet : 네트워크 연결에 사용하는 응용계층의 프로토콜<br /><br /></li>
</ul>

<h1 id="os">OS</h1>
<ul>
  <li>컴퓨터의 하드웨어를 사용자가 쉽게 사용할 수 있도록 인터페이스를 담당하는 소프트웨어</li>
</ul>

<h2 id="os-현행-시스템-분석">OS 현행 시스템 분석</h2>
<ol>
  <li>품질 측면 - 신뢰도, 성능</li>
  <li>지원 측면 - 기술 지원, 주변 기기, 구축 비용<br /><br /></li>
</ol>

<h1 id="디자인-패턴">디자인 패턴</h1>
<ul>
  <li>소프트웨어 설계 시 자주 쓰이는 방법을 정리한 패턴으로, 참고 시 개발 효율성이 높아진다.</li>
</ul>

<h2 id="디자인-패턴-구성요소">디자인 패턴 구성요소</h2>
<ol>
  <li>패턴 이름</li>
  <li>문제 및 배경</li>
  <li>솔루션</li>
  <li>사례</li>
  <li>결과</li>
  <li>샘플코드
    <ul>
      <li>라이브러리 구성 : 도움말, 설치파일, 샘플코드</li>
    </ul>
  </li>
</ol>

<h2 id="디자인-패턴-유형">디자인 패턴 유형</h2>
<ol>
  <li>생성(5) : 객체의 생성방식을 결정하는 패턴</li>
  <li>구조(7) : 객체를 조직화하는데 유용한 패턴</li>
  <li>행위(11) : 객체의 행위를 조직, 관리, 연합하는데 사용하는 패턴</li>
</ol>

<h3 id="디자인-패턴---생성-패턴">디자인 패턴 - 생성 패턴</h3>
<ol>
  <li>팩토리 메소드(Factory Method) : 상위 클래스에서 인터페이스 정의, 서브 클래스가 실제 생성</li>
  <li>프로토타입(Prototype) : 원형 객체를 복사하여 생성 (객체 생성 시 갖춰야 할 기본 형태가 있을 때 사용)</li>
  <li>빌더(Builder) : 객체를 조립하여 생성. 생성 방법과 구현 방법을 구분하여, 동일한 객체 생성이여도 다른 결과가 나올 수 있음)</li>
  <li>싱글톤(Singletone) : 클래스 내 객체가 하나 뿐임을 보장. 하나의 객체를 생성해 어디든 참조할 수 있으나 동시 참조 불가</li>
  <li>추상 팩토리(Abstract Factory) : 구체적인 클래스에 의존하지 않고, 연관된 객체들의 그룹으로 생성 (객체 간 결합이 느슨해짐)</li>
</ol>

<h3 id="디자인-패턴---구조-패턴">디자인 패턴 - 구조 패턴</h3>
<ol>
  <li>퍼싸드(Facade) : 복잡한 시스템에 단순한 인터페이스를 제공해 접근성을 높인 패턴</li>
  <li>플라이웨이트(Flyweight) : 객체가 필요할 때 생성하는 대신 공유하여 메모리 절약</li>
  <li>컴포지트(Composite) : 객체 관계를 파일 트리 구조로 구성하여, 복합 객체와 단일 객체를 동일하게 취급</li>
  <li>프록시(Proxy) : 실제 기능을 수행하는 객체(Real object) 대신 가상의 객체(Proxy object)를 사용해 로직의 흐름을 제어하는 디자인 패턴</li>
  <li>브리지(Bridge) : 구현부에서 추상층을 분리하여 결합도를 낮춘 패턴</li>
  <li>어댑터(Adapter) : 호환성 없는 클래스의 인터페이스를 이용할 수 있게 변환</li>
  <li>데코레이터(Decorator) : 객체 결합을 통해 기능을 확장</li>
</ol>

<h3 id="디자인-패턴---행위-패턴">디자인 패턴 - 행위 패턴</h3>
<ol>
  <li>중재자(Mediator) : 객체 사이에 중재자를 두어 의존성을 줄이는 패턴</li>
  <li>인터프리터(Interpreter) : 여러 언어 구문을 해석할 수 있게 해주는 패턴</li>
  <li>템플릿 메소드(Template Method) : 상위 클래스에서 기능을 정의하고, 하위 클래스에서 세부 처리 방법을 구체화하는 패턴</li>
  <li>옵저버(Observer) : 객체를 지켜보고 있다가, 객체의 상태가 변하면 그 객체에 의존하는 다른 객체들에게 변화된 상태를 전달</li>
  <li>커맨드(Command) : 요청을 객체로 캡슐화하여, 각 요청(명령)이 들어오면 그에 맞는 서브 클래스 실행</li>
  <li>비지터(Visitor) : 처리 기능을 별도로 분리한 패턴 (분리된 처리 기능은 클래스를 방문하여 수행)</li>
  <li>반복자(Iterator) : 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴 (내부 노출 없이 순차적 접근 가능)</li>
  <li>상태(State) : 객체의 상태를 캡슐화하고, 이를 참조해 동작을 다르게 처리</li>
  <li>전략(Strategy) : 동일한 계열의 알고리즘을 캡슐화하고, 전략을 선택해 사용</li>
  <li>책임 연쇄(Chain of Responsibility) : 한 객체가 요청을 처리하지 못하면, 연결된 객체로 넘어가 처리</li>
  <li>메멘토(Memento) : 특정 시점의 객체 내부 상태를 객체화하여, 해당 시점으로 되돌리는 기능을 제공<br /><br /></li>
</ol>

<h1 id="소프트웨어-아키텍처">소프트웨어 아키텍처</h1>
<ul>
  <li>소프트웨어 구성요소와, 구성요소의 특성, 구성요소 간 관계를 표현하는 구조</li>
</ul>

<h2 id="현행-시스템-파악">현행 시스템 파악</h2>
<ol>
  <li>구성 현황 / 기능 현황 / 인터페이스 파악</li>
  <li>아키텍처, 소프트웨어 구성 파악</li>
  <li>하드웨어, 네트워크 구성 파악</li>
</ol>

<h2 id="소프트웨어-41-뷰">소프트웨어 4+1 뷰</h2>
<ul>
  <li>요구사항을 4개의 관점에서 바라보는 방법. 4개 구조가 충돌되지 않는지, 요구사항을 충족하는지 증명하기 위해 유스케이스 사용</li>
</ul>

<h1 id="소프트웨어-아키텍처-비용-평가-모델">소프트웨어 아키텍처 비용 평가 모델</h1>
<ol>
  <li>SAAM : 변경 용이성과 기능성에 집중. 경험없어도 쉽게 사용 가능</li>
  <li>ATAM : SAAM을 계승. 아키텍처 품질 속성을 만족하는지도 평가</li>
  <li>CBAM : ATAM에 경제성 평가 보장</li>
  <li>ADR : 아키텍처 구성요소 간 응집도 평가</li>
  <li>ARID : ATAM + ADR. 전체가 아닌 특정 부분에 대한 비용 평가<br /><br /></li>
</ol>

<h1 id="모델-뷰-컨트롤러mvc-패턴">모델-뷰-컨트롤러(MVC) 패턴</h1>
<ul>
  <li>3개의 서브시스템으로 구조화한 패턴
    <ol>
      <li>모델 : 핵심 기능과 데이터 보관</li>
      <li>뷰 : 사용자에게 정보 표시</li>
      <li>컨트롤러 : 사용자의 입력 처리 - 하나의 모델에 여러 개의 뷰를 필요로 하는 대화형 애플리케이션에 적합</li>
    </ol>
  </li>
</ul>
:ET