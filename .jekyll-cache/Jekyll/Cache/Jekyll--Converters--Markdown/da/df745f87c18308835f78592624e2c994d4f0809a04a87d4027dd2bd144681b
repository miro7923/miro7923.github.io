I"<h1 id="-demain-paging">👀 Demain Paging</h1>
<ul>
  <li>실제로 필요할 때 <code class="language-plaintext highlighter-rouge">page</code>를 메모리에 올리는 것</li>
  <li>왜냐면 프로그램의 대부분의 코드는 (거의 발생하지 않는 치명적인) 오류를 해결하기 위한 코드라 평소에는 쓰지지 않는 부분이 대다수다. 그래서 이걸 다 메모리에 올려 놓으면 메모리 공간만 차지하고 비효율적이다.</li>
  <li>그래서 프로세스 동작에 실제로 필요한 <code class="language-plaintext highlighter-rouge">page</code>만 메모리에 올리는 것이 효율적이다.</li>
  <li>장점
    <ul>
      <li><code class="language-plaintext highlighter-rouge">I/O</code> 양의 감소</li>
      <li>메모리 사용량 감소</li>
      <li>빠른 응답 시간</li>
      <li>더 많은 사용자 수용
<br /><br /></li>
    </ul>
  </li>
  <li>물리적 메모리에 <code class="language-plaintext highlighter-rouge">page</code>가 올려질 <code class="language-plaintext highlighter-rouge">page entry</code>에서 <code class="language-plaintext highlighter-rouge">Valid/Invalid bit</code>를 사용해 현재 메모리에 <code class="language-plaintext highlighter-rouge">page</code>가 올려져 확인한다. 만약 어떤 메모리 주소에 접근했을 때 해당 위치가 <code class="language-plaintext highlighter-rouge">Invalid bit</code>로 세팅되어 있으면 <code class="language-plaintext highlighter-rouge">page fault</code>가 일어났다고 한다.</li>
  <li><code class="language-plaintext highlighter-rouge">page fault</code>가 일어나면 디스크에 직접 접근해서 해당 페이지를 가져와야 하는데 이는 메모리에 접근해서 가져오는 것에 비해 시간이 아주 많이 걸린다.</li>
</ul>

<h1 id="replacement-algorithm">Replacement Algorithm</h1>
<h2 id="page-replacement">Page replacement</h2>
<ul>
  <li>새로운 페이지를 올릴 공간이 없으면 올려져 있는 페이지 중 어떤 것을 쫓아낼 지 결정해야 한다.</li>
  <li>이를 위한 여러 알고리즘이 있는데 대체로 <code class="language-plaintext highlighter-rouge">page fault</code>를 최소화하기 위해 곧바로 사용되지 않을 페이지를 쫓아내는 형태로 구현되어 있다.</li>
</ul>

<h2 id="optimal-algorithm">Optimal Algorithm</h2>
<ul>
  <li>가장 먼 미래에 사용될(당장 사용되지 않을) 페이지를 쫓아내는 알고리즘</li>
  <li>미래에 참조될 페이지를 미리 예측할 수 있다는 가정하에 사용할 수 있는 알고리즘이다. 하지만 미래를 아는 것은 불가능하기 때문에 실제 시스템에 사용은 불가능하다.</li>
</ul>

<h2 id="fifo-first-in-first-out-algorithm">FIFO (First In First Out) Algorithm</h2>
<ul>
  <li>먼저 들어온 것을 먼저 내쫓는 알고리즘</li>
  <li>실제 시스템에 사용되는 알고리즘이다.</li>
  <li>먼저 들어온 것을 내쫓는 과정에서 페이지 프레임 크기를 늘렸는데 오히려 <code class="language-plaintext highlighter-rouge">page fault</code>가 늘어나 성능이 하락하는 경우가 생길 수 있다.</li>
</ul>

<h2 id="lru-least-recently-used-algorithm">LRU (Least Recently Used) Algorithm</h2>
<ul>
  <li>가장 오래 전에 참조된 것을 지우는 알고리즘</li>
  <li>실제 시스템에서 많이 사용된다.</li>
  <li>링크드 리스트(Linked list) 형태로 구현한다. 시간복잡도는 <code class="language-plaintext highlighter-rouge">O(1)</code></li>
</ul>

<h2 id="lfu-least-frequently-used-algorithm">LFU (Least Frequently Used) Algorithm</h2>
<ul>
  <li>참조 횟수(reference count)가 가장 적은 페이지를 지우는 알고리즘
    <ul>
      <li>최저 참조 횟수 페이지가 여러 개 있는 경우
        <ul>
          <li>내쫓을 페이지를 임의로 선정한다.</li>
          <li>성능 향상을 위해 가장 오래 전에 참조된 페이지를 지우게 구현할 수도 있다.</li>
        </ul>
      </li>
      <li>장단점
        <ul>
          <li>LRU처럼 직전 참조 시점만 보는 것이 아니라 장기적인 시간 규모를 보기 때문에 페이지의 인기도를 좀 더 정확히 반영할 수 있다.</li>
          <li>참조 시점의 최근성을 반영하지 못 한다.(만약 1초 전에 처음으로 참조 되었다면 인기도가 낮은 것으로 간주하고 내쫓게 된다)</li>
          <li>LRU보다 구현이 복잡하다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>최소힙(Min heap) 형태로 구현한다. 참조 횟수가 가장 적은 페이지가 힙의 최상단에 있는 것이다. 시간복잡도는 <code class="language-plaintext highlighter-rouge">O(log n)</code></li>
</ul>

<h1 id="출처">출처</h1>
<ul>
  <li><a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323">운영체제 - 이화여자대학교 KOCW 공개강의</a></li>
</ul>
:ET