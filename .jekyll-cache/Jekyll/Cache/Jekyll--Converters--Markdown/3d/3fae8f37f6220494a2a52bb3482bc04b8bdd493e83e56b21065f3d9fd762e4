I"%<h1 id="-논리적-주소와-물리적-주소">👀 논리적 주소와 물리적 주소</h1>
<ul>
  <li>
    <p>데이터가 메모리에 위치하고 있는 곳을 가리키는 주소는 논리적 주소와 물리적 주소로 나뉜다.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Logical address (= virtual address)</code>
    <ul>
      <li>프로세스마다 독립적으로 가지는 주소 공간</li>
      <li>각 프로세스마다 0번지부터 시작</li>
      <li><code class="language-plaintext highlighter-rouge">CPU</code>가 보는 주소는 <code class="language-plaintext highlighter-rouge">logical address</code>임</li>
      <li>왜냐면 코드상의 주소가 <code class="language-plaintext highlighter-rouge">logical address</code>인데 이게 물리적 주소로 바뀐다 해서 코드상의 주소도 물리적 주소로 바뀌는 것은 아니다. 만약 바뀐다면 컴파일을 새로 해야 하는데 이러면 이상하다. 그래서 <code class="language-plaintext highlighter-rouge">CPU</code>는 논리적 주소를 참고하게 된다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Physical address</code>
    <ul>
      <li>메모리에 실제로 올라가는 위치</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">CPU</code>가 <code class="language-plaintext highlighter-rouge">instruction</code>을 수행하다가 메모리에 있는 데이터에 접근할 필요가 있으면 그 데이터가 위치하고 있는 주소를 알아야 한다.</li>
  <li>이때 코드에 물리적 주소가 항상 명시되어 있어서 바로 그 위치로 가서 읽어오면 서로 편하겠지만 프로그램이 실행되는 컴퓨터와 환경에 따라 항상 같은 물리적 주소를 사용할 수 있다는 보장이 없다.</li>
  <li>그래서 코드에는 논리적 주소를 사용해 각 프로세스별로 전용 주소공간을 사용할 수 있게 하고 그 논리적 주소를 이용해 메모리에 실제로 올려져 있는 위치를 참고할 수 있도록 하는 것이다.</li>
  <li><code class="language-plaintext highlighter-rouge">CPU</code>는 메모리에 접근할 필요가 있으면 먼저 논리적 주소를 물리적 주소로 변환한 뒤 해당 위치에 접근해서 데이터를 읽어온다.</li>
</ul>

<h2 id="주소-바인딩address-binding">주소 바인딩(Address Binding)</h2>
<ul>
  <li>논리적 주소를 물리적 주소로 변환하는 것</li>
  <li>하지만 주소변환은 <code class="language-plaintext highlighter-rouge">CPU</code>가 하는 것이 아닌 하드웨어적으로 이루어진다.</li>
  <li>주소변환이 필요할 때마다 <code class="language-plaintext highlighter-rouge">CPU</code>가 필요하면 그 때마다 <code class="language-plaintext highlighter-rouge">interrupt</code>가 일어나게 될 것이고 그건 굉장히 비효율적일 것이다.</li>
</ul>

<h3 id="주소-바인딩-시점에-따른-분류">주소 바인딩 시점에 따른 분류</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Compile time binding</code>
    <ul>
      <li>컴파일될 때 물리적 주소가 결정된다.</li>
      <li>시작위치가 변경되면 재컴파일</li>
      <li>컴파일러는 절대 코드(absolute code) 생성</li>
      <li>옛날에 많이 쓰다가 지금은 잘 안 쓴다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Load time binding</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Loader</code>의 책임하에 물리적 메모리 주소 부여</li>
      <li>프로그램이 메모리에 로드될 때 물리적 주소가 결정된다.</li>
      <li>컴파일러가 재배치 가능 코드(relocatable code)를 생성한 경우 가능</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Execution time binding (= Run time binding)</code>
    <ul>
      <li>수행이 시작된 이후에도 프로세스의 메모리 상 위치를 옮길 수 있다.</li>
      <li><code class="language-plaintext highlighter-rouge">CPU</code>가 주소를 참조할 때마다 <code class="language-plaintext highlighter-rouge">binding</code> 점검 (address mapping table)</li>
      <li>하드웨어에서 지원해야 가능하다.</li>
      <li>최근 시스템에서 사용하는 방식</li>
    </ul>
  </li>
</ul>

<h2 id="memory-management-unit-mmu">Memory-Management Unit (MMU)</h2>
<ul>
  <li>주소 변환을 위한 하드웨어</li>
  <li>논리적 주소를 물리적 주소로 매핑해 준다.</li>
  <li>실제 물리적 주소의 시작점에서 논리적 주소의 <code class="language-plaintext highlighter-rouge">offset</code>만큼을 더해서 물리적 주소를 알려준다.</li>
  <li><code class="language-plaintext highlighter-rouge">Limit register</code> : 만약 프로세스가 자기 범위를 넘어가는 위치에 있는 데이터에 접근을 요구하면 다른 프로세스의 중요 데이터에 접근하게 될 수 있다. 그래서 주소를 변환할 때 프로세스가 가질 수 있는 주소의 최대 크기를 먼저 제한해놓고 그 범위 안에서만 변환할 수 있도록 한다.<br /><br /></li>
</ul>

<h1 id="메모리-로드-기법들">메모리 로드 기법들</h1>
<h2 id="dynamic-loading">Dynamic Loading</h2>
<ul>
  <li>프로세스 전체를 메모리에 미리 다 올리는 것이 아니라 해당 루틴이 불려질 때 메모리에 <code class="language-plaintext highlighter-rouge">load</code>하는 것</li>
  <li><code class="language-plaintext highlighter-rouge">memory utilization</code>이 향상됨</li>
  <li>가끔씩 사용되는 코드가 많을 때 유용하다.
    <ul>
      <li>자주 사용되는 부분이 한정적인데 전체를 올리면 비효율적이다.</li>
      <li>예 : 오류 처리 루틴</li>
    </ul>
  </li>
  <li>운영체제의 특별한 지원 없이 프로그램 자체에서 구현 가능 (<code class="language-plaintext highlighter-rouge">OS</code>는 라이브러리를 통해 지원 가능)</li>
</ul>

<h2 id="dynamic-linking">Dynamic Linking</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Linking</code>을 실행시간(execution time)`까지 미루는 기법</li>
  <li><code class="language-plaintext highlighter-rouge">Static linking</code>
    <ul>
      <li>라이브러리가 프로그램의 실행 파일 코드에 포함됨</li>
      <li>실행 파일의 크기가 커짐</li>
      <li>동일한 라이브러리를 각각의 프로세스가 메모리에 올리므로 메모리 낭비가 생긴다.(예: <code class="language-plaintext highlighter-rouge">printf</code>함수의 라이브러리 코드)</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Overlays</code>
    <ul>
      <li>메모리에 프로세스의 부분 중 실제 필요한 정보만을 올림</li>
      <li>이렇게 보면 <code class="language-plaintext highlighter-rouge">Dynamic loading</code>과 비슷해 보이지만 프로그래머가 수작업으로 구현해야 한다는 점에서 다르다. 작은 공간의 메모리를 사용하던 초창기 시스템에서 사용하던 방식으로 프로그래밍이 매우 복잡하다.</li>
      <li>프로세스의 크기가 메모리보다 클 때 유용</li>
      <li>운영체제의 지원 없이 사용자에 의해 구현</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Dynamic linking</code>
    <ul>
      <li>라이브러리가 실행시 연결된다.</li>
      <li>라이브러리 호출 부분에 라이브러리 루틴의 위치를 찾기 위한 <code class="language-plaintext highlighter-rouge">stub</code>이라는 작은 코드를 둔다.</li>
      <li>라이브러리가 이미 메모리에 있으면 그 루틴의 주소로 가고 없으면 디스크에서 읽어옴</li>
      <li>운영체제의 도움 필요</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Swapping</code>
    <ul>
      <li>프로세스를 일시적으로 메모리에서 <code class="language-plaintext highlighter-rouge">backing store(하드디스크)</code>로 쫓아내는 것</li>
      <li><code class="language-plaintext highlighter-rouge">Backing store</code> : 많은 사용자의 프로세스 이미지를 담을 만큼 충분히 빠르고 큰 저장 공간</li>
      <li>일반적으로 중기 스케줄러(swapper)에 의해 <code class="language-plaintext highlighter-rouge">swap in/out</code>될 프로세스가 선정된다.</li>
      <li>프로세스의 우선순위에 따라 <code class="language-plaintext highlighter-rouge">swap</code>이 이루어진다.</li>
      <li><code class="language-plaintext highlighter-rouge">Compile time</code> 혹은 <code class="language-plaintext highlighter-rouge">load time binding</code>에서는 원래 메모리 위치로 <code class="language-plaintext highlighter-rouge">swap in</code>해야 함</li>
      <li><code class="language-plaintext highlighter-rouge">Execution time binding</code>에서는 추후 빈 메모리 영역 아무 곳에나 올릴 수 있다.</li>
      <li><code class="language-plaintext highlighter-rouge">swap time</code>은 대부분 <code class="language-plaintext highlighter-rouge">transfer time</code>(swap되는 양에 비례하는 시간)이다.</li>
    </ul>
  </li>
</ul>

<h1 id="출처">출처</h1>
<ul>
  <li><a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323">운영체제 - 이화여자대학교 KOCW 공개강의</a></li>
</ul>
:ET