I"<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://school.programmers.co.kr/learn/courses/30/lessons/64065">https://school.programmers.co.kr/learn/courses/30/lessons/64065</a><br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>
    <p>셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다.</p>
  </li>
  <li>(a1, a2, a3, …, an)</li>
  <li>
    <p>튜플은 다음과 같은 성질을 가지고 있습니다.</p>
  </li>
  <li>중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2)</li>
  <li>원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다. ex : (1, 2, 3) ≠ (1, 3, 2)</li>
  <li>튜플의 원소 개수는 유한합니다.</li>
  <li>
    <p>원소의 개수가 n개이고, 중복되는 원소가 없는 튜플 (a1, a2, a3, …, an)이 주어질 때(단, a1, a2, …, an은 자연수), 이는 다음과 같이 집합 기호 ‘{‘, ‘}’를 이용해 표현할 수 있습니다.</p>
  </li>
  <li>
    <p>전문은 링크에…</p>
  </li>
  <li>특정 튜플을 표현하는 집합이 담긴 문자열 s가 매개변수로 주어질 때, s가 표현하는 튜플을 배열에 담아 return 하도록 solution 함수를 완성해주세요.<br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<ul>
  <li>s의 길이는 5 이상 1,000,000 이하입니다.</li>
  <li>s는 숫자와 ‘{‘, ‘}’, ‘,’ 로만 이루어져 있습니다.</li>
  <li>숫자가 0으로 시작하는 경우는 없습니다.</li>
  <li>s는 항상 중복되는 원소가 없는 튜플을 올바르게 표현하고 있습니다.</li>
  <li>s가 표현하는 튜플의 원소는 1 이상 100,000 이하인 자연수입니다.</li>
  <li>return 하는 배열의 길이가 1 이상 500 이하인 경우만 입력으로 주어집니다.<br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>처음엔 그래도 풀이가 떠올라서 희망을 가지고 풀어본 문제이다.</li>
</ul>

<h2 id="첫-번째-접근">첫 번째 접근</h2>
<ol>
  <li>문제에서 보이는대로 문자열을 {} 묶음 기준으로 자른 다음 거기서 또 숫자를 추출해 정렬을 하려 했다.</li>
  <li>문제를 보면 {} 묶음의 길이가 짧을 수록 앞으로 와야 하기 때문에 저렇게 정렬을 한 다음에 문제를 풀려 했다.</li>
  <li>근데 이 방법의 최대 단점은 {} 묶음까진 어떻게 만든다 쳐도 <code class="language-plaintext highlighter-rouge">[{2}, {2, 1}, {2, 1, 3}]</code>과 같이 이루어진 배열에서 숫자만 뽑아내 올바른 순서로 정렬을 하려면 순회를 여러번 해야 하는 것이었다. 내가 처음에 생각했던 방법은 다른 {} 원소의 숫자 정렬 순서를 참고해 정답을 찾는 방식으로 하려했다. 하지만 이것은 정답에 도달할 수 없는 방법이었다.</li>
  <li>왜냐면 집합 내에서의 순서는 상관없기 때문에 <code class="language-plaintext highlighter-rouge">[{2}, {1, 2}, {1, 3, 2}]</code>과 같은 배열도 주어지기 때문이다. 그래서 2번에서 얻을 수 있는 저 배열을 한 번만 순회해서는 정답을 절대로 얻을 수 없다. 그렇기 때문에 배열을 여러 번 순회하게 된다… 여기서 시간초과가 발생했다. 그리고 통과를 한 다음에 이 방법을 다시 생각해보니 정말 여러가지로 통과할 수 없는 풀이였다.</li>
</ol>

<h2 id="두-번째-접근">두 번째 접근</h2>
<ol>
  <li>시간 초과를 받은 다음에 질문 게시판을 참고해서.. 풀었다.</li>
  <li>키포인트는 <code class="language-plaintext highlighter-rouge">{},</code> &lt;- 얘네를 없애고 숫자만 추출한 다음 각 숫자들의 출현횟수를 센다.</li>
  <li>출현횟수가 많은 순서대로 내림차순 정렬을 한 다음 차례로 배열에 담아 리턴한다.</li>
</ol>

<ul>
  <li>이 힌트글을 보고 통과할 수 있었다. 그러고보니 문제에 힌트가 있었는데 미처 보지 못 했다. 앞으론 문제에서 힌트를 찾을 수 있도록 하자!<br /><br /></li>
</ul>

<h1 id="자기-성찰">자기 성찰</h1>
<ul>
  <li>코테에서 나의 발목을 잡는 정규식… 그동안 정규식과 <code class="language-plaintext highlighter-rouge">Matcher, Pattern</code> 클래스의 사용법을 잘 몰랐는데 이번 기회에 사용해 볼 수 있어 좋은 공부가 되었다고 생각한다.</li>
  <li>그리고 정답 풀이들에 set을 사용한 분이 계셨는데 덕분에 <code class="language-plaintext highlighter-rouge">set의 add()</code>에 리턴값이 있다는 것도 알게 되었고 그것을 활용한 방법도 알 수 있었다.<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/07d37bd5ed07f2bf099fe63697a07aee.js"></script>

:ET