<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-01-31T11:53:00+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yujin Dev Log</title><subtitle>개발 공부하는 블로그</subtitle><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><entry><title type="html">깃허브 프로필(Github Profile) 꾸미기</title><link href="http://localhost:4000/story/decorate-github-profile/" rel="alternate" type="text/html" title="깃허브 프로필(Github Profile) 꾸미기" /><published>2022-01-31T00:00:00+09:00</published><updated>2022-01-31T00:00:00+09:00</updated><id>http://localhost:4000/story/decorate-github-profile</id><content type="html" xml:base="http://localhost:4000/story/decorate-github-profile/"><![CDATA[<h1 id="-시작">🎬 시작<br /></h1>
<p>드디어 깃헙 블로그를 만들고… 다른 깃헙들을 구경하다 보니까 깃헙 메인 화면 자체를 예쁘게 꾸며놓으신 분들이 많더라고요!<br /><br />
<img src="../../assets/images/githubProfileComplete.png" alt="githubProfileComplete" /><br /><br />
이렇게요!<br /><br />
되게 좋아 보이잖아요?ㅎㅎㅎ 그래서 저도 꾸며보기로 했습니다.<br /><br /></p>

<h1 id="1-new-repository-만들기">1. New Repository 만들기<br /></h1>
<p><img src="../../assets/images/createNewRepo.png" alt="createNewRepo" /><br /><br />
먼저 내 아이디와 같은 이름으로 새로운 레포지토리를 만들어 줍니다.<br />
처음 깃헙 블로그를 만들 때 봤을 때엔 깃헙 프로필 페이지 자체를 꾸밀 수 있다는 것을 몰라서 뭔 소린가 했는데 이런 뜻이었네요…<br /><br /></p>

<p><img src="../../assets/images/addReadme.png" alt="addReadme" /><br /><br />
만들 때엔 add a readme에 꼭 체크해 주세요! readme로 프로필 페이지를 꾸며야 하거든요.<br /><br /></p>

<h1 id="2-readmemd-편집하기">2. README.md 편집하기<br /></h1>
<p><img src="../../assets/images/editReadme01.png" alt="editReadme01" /><br /><br />
새로 만든 레포로 들어오면 아무것도 없어서 휑한 모습을 볼 수 있습니다. 전 까먹고 스샷을 좀 늦게 찍었더니 어느정도 꾸미기를 진행한 상태였네요 😅 <br />
여기서 리드미 파일 상단의 연필 그림을 누르거나 오른쪽에 보이는 초록색 edit readme 버튼을 눌러서 웹상에서 바로 편집을 진행하셔도 되고 로컬로 다운받아서 편집한 다음에 푸시하셔도 됩니다.<br /><br /></p>

<h2 id="-markdown-미리보기">🔸 markdown 미리보기<br /></h2>
<p>혹은 <a href="https://dillinger.io/">https://dillinger.io/</a><br />
<img src="../../assets/images/markdownPreviewService.png" alt="markdownPreviewService" /><br /><br />
라는 사이트가 있는데 여기에서는 마크다운으로 작성하는 파일을 실시간으로 미리볼 수 있는 서비스를 제공하고 있습니다.<br />
보통 마크다운 파일을 편집할 땐 미리보기가 가능하지 않으니까 여러번 커밋과 푸시를 하게 되어서 좀 귀찮은데 이 사이트에서는 실시간으로 확인하면서 작성한 다음에 복붙해서 한 번에 커밋할 수 있어서 꽤 편합니다.<br /><br />
하지만 전 쓸 게 그렇게 많지는 않아서 여기 쓰려다가 안 쓰고 그냥 레포에서 바로 수정했습니다…😅<br /><br /></p>

<h2 id="-배지-만들기">🔸 배지 만들기<br /></h2>
<p><img src="../../assets/images/techStack.png" alt="techStack" /><br /><br />
다른 분들 보니까 이런식으로 c++같은 프로그래밍 언어들을 그냥 텍스트로 쓰지 않고 배지 그림으로 달아 놓으셨더라고요. 저도 좋아보이는 건 다 해보고 싶어서 배지 이미지를 만들어 주는 사이트에서 만들었습니다.<br /><br /></p>

<h3 id="️-배지--httpsshieldsio">▪️ 배지 : <a href="https://shields.io/">https://shields.io/</a></h3>
<h3 id="️-언어-로고--httpssimpleiconsorg">▪️ 언어 로고 : <a href="https://simpleicons.org/">https://simpleicons.org/</a><br /></h3>
<p>위 사이트들에 가면 저런 폼나는 아이콘들을 얻을 수 있습니다.<br /><br /></p>

<p>배지를 만드시려면<br /><br />
<img src="../../assets/images/makeBadge01.png" alt="makeBadge01" /><br /><br />
이런식으로 넣고 싶은 문구를 입력하고 세번째 칸의 화살표를 눌러서 색상을 선택하거나 직접 입력하시고 나서 오른쪽의 Make Badge 버튼을 누르시면 <br /><br />
<img src="../../assets/images/makeBadge02.png" alt="makeBadge02" /><br /><br />
이렇게 배지를 만들어 줍니다. 여기서 주소를 복사하세요.<br /><br /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;img src="https://img.shields.io/badge/-TechBlog-brightgreen"&gt;
</code></pre></div></div>
<p>위 태그를 리드미에 입력하시면 우리가 만든 배지를 불러옵니다. 하지만 이렇게만 작성하면 단순히 그림만 불러오고 이 그림을 눌렀을 때 어디로 이동할지는 정해주지 않았기 때문에 그냥 새 창에서 그림이 호출될 것이어요… <br /><br /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;a href="https://miro7923.github.io/"&gt;
&lt;img src="https://img.shields.io/badge/-TechBlog-brightgreen"&gt;
</code></pre></div></div>
<p>그렇기 때문에 이런식으로 a 태그를 이용해 하이퍼링크를 걸어주시면 우리가 만든 배지 그림을 눌렀을 때 나의 블로그로 이동하게 됩니다.<br /><br /></p>

<p>일반화한다면 <br /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;img src="https://img.shields.io/badge/라벨-메세지-색상"&gt;
</code></pre></div></div>
<p>이렇게 작성하시면 됩니다.<br /><br /></p>

<p>만약 이메일 주소도 추가하고 싶으시면 <br /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;a href="mailto:miro7923@gmail.com"&gt;
</code></pre></div></div>
<p>mailto를 이용해 메일주소를 적어주세요!<br /><br /></p>

<h2 id="-프로그래밍-언어-로고-만들기">🔸 프로그래밍 언어 로고 만들기<br /></h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;img src="https://img.shields.io/badge/C++-00599C?style=flat-square&amp;logo=C%2B%2B&amp;logoColor=white"/&gt;&lt;/a&gt;&amp;nbsp 
</code></pre></div></div>
<p>프로그래밍 언어 로고는 위와 같이 태그를 입력하면 되는데 이것을 일반화하면<br /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;img src="https://img.shields.io/badge/언어-색상?style=flat-square&amp;logo=simpleicons에서 로고 이름&amp;logoColor=white"/&gt;&lt;/a&gt;&amp;nbsp 
</code></pre></div></div>
<p>위와 같은 형태로 만들 수 있습니다.<br /><br />
<img src="../../assets/images/simpleIcons.png" alt="simpleIcons" /><br /><br />
simpleicons 사이트에서 원하는 언어를 검색해서 그 언어의 이름과 색상을 넣어준 다음 simpleicons 사이트에서 표시되어 있는 언어의 이름을 넣어주시면 됩니다. <br /><br /></p>

<p>단, c++을 쓸 때에만 좀 주의하면 되는데 simpleicons 사이트에는 단순히 C++이라 나와있지만 이걸 그대로 쓰면 적용이 안 되고 C%2B%2B라고 적어주어야 적용이 된다고 합니다. %2B가 +에 대응된다고 합니다.<br /><br />
c#은 C Sharp 이라는 이름으로 등록되어 있었습니다.<br /><br /></p>

<p><img src="../../assets/images/editReadme02.png" alt="editReadme02" /><br /><br />
대략 이렇게 태그들을 쓴 다음에 <br /><br /></p>

<p><img src="../../assets/images/editReadme03.png" alt="editReadme03" /><br /><br />
커밋 버튼 눌러서 마무리!<br /><br /></p>

<h1 id="3-최종-완성">3. 최종 완성<br /></h1>
<p><img src="../../assets/images/completeReadme.png" alt="completeReadme" /><br /><br />
짠 👏 커밋 버튼을 눌러서 나오면 이렇게 완성된 리드미를 볼 수 있습니다.<br /><br /></p>

<p><img src="../../assets/images/githubProfileComplete.png" alt="githubProfileComplete" /><br /><br />
그리고 제 깃헙 프로필 메인 페이지를 확인해보면 이렇게 있어보이게 바꼈습니다! 😄 뿌듯~~!!<br /><br />
이렇게 보니까 할 줄 아는거 되게 많네요! ㅎㅎ 더 뿌듯하다…<br /><br /></p>

<p>앞으로 공부 더 열심히 해야겠습니다. 그럼 다음 글에서 만나요! 👋<br /></p>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Story" /><category term="story" /><summary type="html"><![CDATA[🎬 시작 드디어 깃헙 블로그를 만들고… 다른 깃헙들을 구경하다 보니까 깃헙 메인 화면 자체를 예쁘게 꾸며놓으신 분들이 많더라고요! 이렇게요! 되게 좋아 보이잖아요?ㅎㅎㅎ 그래서 저도 꾸며보기로 했습니다.]]></summary></entry><entry><title type="html">DB 기초</title><link href="http://localhost:4000/database/DB-start/" rel="alternate" type="text/html" title="DB 기초" /><published>2022-01-31T00:00:00+09:00</published><updated>2022-01-31T00:00:00+09:00</updated><id>http://localhost:4000/database/DB-start</id><content type="html" xml:base="http://localhost:4000/database/DB-start/"><![CDATA[<h1 id="-db란">🎬 DB란?<br /></h1>

<h2 id="-db를-쓰는-이유">🔸 DB를 쓰는 이유</h2>
<ul>
  <li>데이터를 오프라인으로 캐비넷에 저장하자니 물리적 저장 공간은 한정되어 있다.</li>
  <li>그렇다면 엑셀 파일을 만들어 암호를 걸어 쓰는 방법이 있는데 만약 암호가 유출된다면 그 엑셀 파일 안에 저장된 정보도 모두 유출된다. 따라서 이것도 안전한 방법은 아니다.</li>
  <li>그래서 서버에 데이터베이스를 구축하고 거기에 고객 정보를 저정하고 관리하는 것이다.
    <ul>
      <li>데이터베이스엔 애초에 허가받은 사용자만 접근할 수 있고 허가받은 권한 만큼만 데이터에 접근할 수 있다.<br /><br /></li>
    </ul>
  </li>
</ul>

<h2 id="-dbms">🔸 DBMS</h2>
<ul>
  <li>데이터베이스 관리 시스템</li>
  <li>DB에서 필요한 데이터를 검색하거나 삽입, 수정, 삭제하기 위한 프로그램</li>
  <li>ORACLE, MySQL등이 있으며 이것들이 DB 자체를 의미하는 것은 아니다.
    <ul>
      <li>DB를 다루기 위한 수단으로서 MySQL을 사용하면 MySQL을 사용한 DB 프로그램인 것이다.<br /><br /></li>
    </ul>
  </li>
</ul>

<h2 id="-rdbms">🔸 RDBMS</h2>
<ul>
  <li>관계형 DBMS</li>
  <li>시중에 나와있는 대부분의 DBMS라고 보면 된다.<br /><br /></li>
</ul>

<h2 id="-sql">🔸 SQL</h2>
<ul>
  <li>데이터 액세스를 위해 ORACLE server와 통신하는 언어로 DB와 소통하기 위한 언어</li>
  <li>모든 DBMS에서 사용하는 공용언어<br /><br /></li>
</ul>

<h2 id="-table">🔸 TABLE</h2>
<ul>
  <li>DB에서 사용하는 대표 객체(오브젝트)</li>
  <li>테이블을 사용해서 데이터를 분류한다.<br /><br />
<img src="../../assets/images/table.png" alt="table" /><br /><br /></li>
  <li>세로는 <strong>열(column)</strong>, 가로는 <strong>행(row)</strong>!!</li>
  <li>column과 row가 만나는 곳은 <strong>Field(Record)값</strong>이라고 부른다.<br /></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Database" /><category term="DB" /><summary type="html"><![CDATA[🎬 DB란?]]></summary></entry><entry><title type="html">컴퓨터의 분류</title><link href="http://localhost:4000/computer%20science/CS04/" rel="alternate" type="text/html" title="컴퓨터의 분류" /><published>2022-01-30T00:00:00+09:00</published><updated>2022-01-30T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/CS04</id><content type="html" xml:base="http://localhost:4000/computer%20science/CS04/"><![CDATA[<h1 id="컴퓨터의-분류">컴퓨터의 분류<br /></h1>

<h2 id="1-사용-목적에-따른-분류">1. 사용 목적에 따른 분류<br /></h2>
<h3 id="1-특수용-컴퓨터">1) 특수용 컴퓨터<br /></h3>
<ul>
  <li>한 가지 작업만을 처리할 수 있도록 설계되고 만들어진 컴퓨터<br /><br /></li>
</ul>

<h3 id="2-범용-컴퓨터">2) 범용 컴퓨터<br /></h3>
<ul>
  <li>여러 분야에서 다양한 일을 할 수 있도록 설계된 컴퓨터<br /></li>
  <li>일반적인 자료 처리는 물론이고 프로그램을 교체하여 다른 작업에 이용할 수 있다.<br /></li>
  <li>연구, 기업업무용으로 주로 사용되어 우리가 흔히 아는 개인용 컴퓨터와는 약간 다르다.<br /><br /></li>
</ul>

<h3 id="3-개인용-컴퓨터">3) 개인용 컴퓨터<br /></h3>
<ul>
  <li>개인의 업무를 처리하도록 설계된 컴퓨터<br /></li>
  <li>우리가 흔히 볼 수 있는 컴퓨터로 교육용, 가정용, 기업용 등으로 널리 보급되어 있다.<br /><br /><br /></li>
</ul>

<h2 id="2-데이터-표현-방식에-따른-분류">2. 데이터 표현 방식에 따른 분류<br /></h2>
<h3 id="1-디지털-컴퓨터">1) 디지털 컴퓨터<br /></h3>
<ul>
  <li>일반적으로 생각하는 컴퓨터<br /></li>
  <li>이산적(discrete, 연속적이지 않다)인 형태로 이용한다.<br /></li>
  <li>시간에 따른 연속적인 변화량을 정해진 시간에 측정된 수치로 기억한다. 연결된 것처럼 보일만큼 작은 단위로 쪼개서 기억한다고 볼 수 있다.<br /><br /></li>
</ul>

<h3 id="2-아날로그-컴퓨터">2) 아날로그 컴퓨터<br /></h3>
<ul>
  <li>연속적인 자료를 이용하여 물리적인 유사성으로 변수나 양을 표현하고 이를 수학적으로 분석한 물리적 상태를 흉내 내는 방식으로 작동한다.<br /></li>
  <li>거리, 속도, 가속도, 온도, 압력 등의 물리량을 전압이나 전류의 양으로 대치하고 기계적 또는 전자적으로 동등한 회로에서 작동시킨 결과를 이용하는 방식이다.<br /><br /></li>
</ul>

<h3 id="3-하이브리드-컴퓨터">3) 하이브리드 컴퓨터<br /></h3>
<ul>
  <li>변환기를 통해 아날로그 형태로 입력된 데이터를 디지털 형태로 변환하여 처리한 후 결과를 디지털 형태나 다시 아날로그 형태로 변환하여 출력할 수 있다.<br /><br /><br /></li>
</ul>

<h2 id="3-처리-용량에-따른-분류">3. 처리 용량에 따른 분류<br /></h2>
<ul>
  <li>현재는 크기와는 별도로 컴퓨터의 처리 속도에 따른 분류를 주로 사용한다.<br /><br /></li>
</ul>

<h3 id="1-슈퍼-컴퓨터">1) 슈퍼 컴퓨터<br /></h3>
<ul>
  <li>가장 빠르고 가장 가격이 비싼 컴퓨터를 총칭하는 용어이다.<br /></li>
  <li>항공 우주, 입자물리와 화학, 전자, 자동차 및 석유 탐사 분야와 기상 예측, 지진 분석, 유전자 분석 등 시간이 오래 걸리는 복잡한 수학 공식을 반복적으로 방대한 분량을 계산하는 과학 기술 분야에서 주로 사용된다.<br /></li>
  <li>10기가 플롭스 이상의 속도를 가지고 있는 컴퓨터가 슈퍼 컴퓨터의 범주에 포함된다.<br /><br /></li>
</ul>

<h3 id="2-메인프레임-컴퓨터">2) 메인프레임 컴퓨터<br /></h3>
<ul>
  <li>대규모 회사에서 주로 사용하는 컴퓨터<br /></li>
  <li>계산의 양보다는 입력과 출력되는 데이터의 양이 많은 경우에서 주로 사용된다.<br /></li>
  <li>다중 사용자(multi-user) 시스템<br /><br /></li>
</ul>

<h3 id="3-미니-컴퓨터">3) 미니 컴퓨터<br /></h3>
<ul>
  <li>메인프레임 컴퓨터보다 저렴하면서 메인프레임 컴퓨터와 유사한 기능을 이용할 수 있는 컴퓨터<br /></li>
  <li>약 200명 정도의 동시 사용자를 지원해주는 시스템을 가지고 있다.<br /></li>
  <li>메인프레임 컴퓨터의 하위 호완버전이라고 생각하면 된다.<br /></li>
  <li>다중 사용자(multi-user) 시스템<br /><br /></li>
</ul>

<h3 id="4-워크스테이션과-마이크로-컴퓨터">4) 워크스테이션과 마이크로 컴퓨터<br /></h3>
<ul>
  <li>단일 사용자(single-user) 시스템<br /><br /></li>
</ul>

<p>4-1) 워크스테이션<br />
    * 강력한 계산, 고성능의 그래픽 디스플레이를 필요로 하는 공학자와 건축가, 그 외의 여러 분야의 전문가들의 작업에 적합하도록 설계된 데스크탑 컴퓨터<br /><br /></p>

<p>4-2) 마이크로 컴퓨터<br />
    * 우리가 흔히 볼 수 있는 데스크탑 컴퓨터<br />
    * 현재 많은 사람들이 사용하는 개인용 컴퓨터(PC)는 마이크로프로세서를 이용한 마이크로 컴퓨터를 뜻한다.<br /><br /></p>

<h3 id="5-휴대형-컴퓨터">5) 휴대형 컴퓨터<br /></h3>
<p>5-1) 랩탑 컴퓨터<br />
    * 3~4kg 정도의 무게에 무릎 위에 올려놓고 사용할 수 있는 컴퓨터<br /><br /></p>

<p>5-2) 노트북 컴퓨터<br />
    * 우리가 흔히 사용하는 노트북<br /><br /></p>

<p>5-3) 팜탑 컴퓨터<br />
    * 처리해야 할 작업의 종류가 다양하지 않고 노트북을 휴대하는 것조차 부담스러운 이용자들을 위해 개발된 컴퓨터<br />
    * 대표적인 것이 PDA로 약속 시간 관리 및 전화 번호부, 메모장 등의 용도로 한정되어 있다. 최근에는 무선 및 유선 통신 기능을 추가하여 근로용 단말기로도 이용되고 있다.<br /><br /></p>

<p>5-4) 스마트폰<br />
    * 우리가 흔히 사용하는 스마트폰<br />
    * 다양한 기능 수용을 위해서 iOS, 안드로이드와 같은 표준화된 전용 운영체제를 갖추고 있다.<br /><br /></p>

<p>5-5) 태플릿 PC<br />
    * 아이패드와 같은 태블릿<br />
    * 일반 업무용과 개인 멀티미디어 기기로 활용하며, 프레젠테이션, 교육, 모바일 네트워크 기기로 활용<br /><br /></p>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><summary type="html"><![CDATA[컴퓨터의 분류]]></summary></entry><entry><title type="html">데이터의 표현과 연산</title><link href="http://localhost:4000/computer%20science/CS05/" rel="alternate" type="text/html" title="데이터의 표현과 연산" /><published>2022-01-30T00:00:00+09:00</published><updated>2022-01-30T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/CS05</id><content type="html" xml:base="http://localhost:4000/computer%20science/CS05/"><![CDATA[<h1 id="데이터의-표현과-연산">데이터의 표현과 연산<br /></h1>

<h2 id="1-컴퓨터의-수-체계">1. 컴퓨터의 수 체계<br /></h2>
<ul>
  <li>우리는 10진수를 사용하지만 컴퓨터는 0과 1로 모든 것을 판단하기 때문에 2진수를 사용한다.<br /></li>
  <li>컴퓨터의 연산과 제어의 기본은 부울대수이며, 컴퓨터가 다루는 데이터를 2진 숫자(Binary digIT)라고 하며 약자로 비트(BIT)라고 한다.<br /></li>
  <li>8개의 비트를 한 단위로 하여 1바이트(byte)로 사용한다.<br /></li>
  <li>2진수의 최상위 비트를 MSB(most significant bit)라 하고 최하위 비트를 LSB(least significant bit)라 한다.<br /><br /></li>
</ul>

<h2 id="2-데이터의-표현">2. 데이터의 표현<br /></h2>
<p>1) BCD 코드<br /></p>
<ul>
  <li>Binary Coded Decimal의 약자로 8421 코드라고도 한다.<br /></li>
  <li>BCD 코드는 각 비트 자리가 자리값을 갖는데 1010이라는 4자리 비트가 있다고 했을 때 왼쪽(10진수로 생각할 때 1000의 자리)부터 <br /></li>
  <li>2^3 = 8<br /></li>
  <li>2^2 = 4<br /></li>
  <li>2^1 = 2<br /></li>
  <li>2^0 = 1<br /></li>
  <li>의 값을 가지므로 8421코드라 부른다. <br /></li>
  <li>일반적으로 10진수를 2진수로 표현하는 것과 비슷하지만 10이 넘어가면 2진수는 1010이라고 표현하지만 BCD 코드는 0001 0000, 11은 0001 0001 … 와 같은 방식으로 표현한다.<br /><br /></li>
</ul>

<p>2) 문자 데이터<br /></p>
<ul>
  <li>문자 데이터는 1바이트의 데이터이다. 아스키코드의 문자 ABC를 2진법과 16진법으로 나타낸다면 다음과 같이 된다.<br /></li>
</ul>

<table>
  <thead>
    <tr>
      <th>문자</th>
      <th>2진법</th>
      <th>16진법</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>A</td>
      <td>0100 0001</td>
      <td>41H</td>
      <td> </td>
    </tr>
    <tr>
      <td>B</td>
      <td>0100 0010</td>
      <td>42H</td>
      <td> </td>
    </tr>
    <tr>
      <td>C</td>
      <td>0100 0011</td>
      <td>43H</td>
      <td><br /><br /></td>
    </tr>
  </tbody>
</table>

<p>3) 존(Zone) 형식<br /></p>
<ul>
  <li>언팩(unpack) 형식이라고도 하며, 1바이트에 한 개의 10진수가 저장된다. 1바이트의 왼쪽 4비트를 존(zone) 비트라고 하며 항상 F(16진수)가 들어 있다.<br /></li>
</ul>

<table>
  <thead>
    <tr>
      <th>2진수</th>
      <th>1111</th>
      <th>0111</th>
      <th>1111</th>
      <th>0001</th>
      <th>1100</th>
      <th>0010</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>16진수</td>
      <td>F</td>
      <td>7</td>
      <td>F</td>
      <td>1</td>
      <td>C(양수)</td>
      <td>2</td>
      <td><br /></td>
    </tr>
  </tbody>
</table>

<ul>
  <li>10진수를 712로 표현한다면 위와 같이 표현되는데 마지막 바이트의 왼쪽 4비트를 이용해서 부호를 나타낸다. 위와 같은 경우처럼 마지막 바이트의 왼쪽 4비트가 C라면 양수고<br /></li>
</ul>

<table>
  <thead>
    <tr>
      <th>2진수</th>
      <th>1111</th>
      <th>0111</th>
      <th>1111</th>
      <th>0001</th>
      <th>1101</th>
      <th>0010</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>16진수</td>
      <td>F</td>
      <td>7</td>
      <td>F</td>
      <td>1</td>
      <td>D(음수)</td>
      <td>2</td>
      <td><br /></td>
    </tr>
  </tbody>
</table>

<ul>
  <li>위처럼 D라면 음수로 -712가 된다.<br /><br /></li>
</ul>

<p>4) 팩(Pack) 형식<br /></p>
<ul>
  <li>수치를 표현하는 4비트의 BCD를 1바이트에 2개를 나타내며 10진수 숫자 2개를 표시한다. 존 형식이 절반으로 줄어든 형태라고 보면 된다.<br /></li>
</ul>

<table>
  <thead>
    <tr>
      <th>2진수</th>
      <th>0111</th>
      <th>0001</th>
      <th>0010</th>
      <th>1100</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>16진수</td>
      <td>7</td>
      <td>1</td>
      <td>2</td>
      <td>C(양수)</td>
      <td><br /></td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>2진수</th>
      <th>0111</th>
      <th>0001</th>
      <th>0010</th>
      <th>1101</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>16진수</td>
      <td>7</td>
      <td>1</td>
      <td>2</td>
      <td>D(음수)</td>
      <td><br /><br /></td>
    </tr>
  </tbody>
</table>

<p>5) 고정 소수점 형식<br /></p>
<ul>
  <li>고정 소수점 형식은 소수점 위치가 가장 오른쪽 끝에 고정되어 있다고 가정하는 것으로 전체의 수를 정수로 표현한다. 가장 왼쪽의 비트는 부호를 표시하며 0이면 +양수, 1이면 -음수를 나타낸다. 데이터 길이를 n이라고 했을 때 -(2^n-1 - 1) ~ (2^n-1 - 1)의 범위를 나타낼 수 있다.<br /></li>
  <li>고정 소수점은 BCD 코드에 비해서 명령 속도가 빠르다.<br /><br /></li>
</ul>

<p>6) 부동 소수점 표현<br /></p>
<ul>
  <li>아주 큰 수나 아주 작은 수를 표현한다든지 아니면 높은 정도(precision)로 취급할 때 많이 쓰인다. 유효숫자만을 나타내는 소수부(fraction part)와 소수점의 위치를 나타내는 지수부(exponent part)로 구분한다. 10^-78 ~ 10^74의 범위까지를 나타낼 수 있다.<br /><br /><br /></li>
</ul>

<h2 id="3-보수-연산">3. 보수 연산<br /></h2>
<ul>
  <li>보수(complement)란 어떤 기준이 되는 수를 설정했을 때 그 수에 모자라는 수를 말한다. x에 대한 9의 보수는 9로부터 x를 뺀 것인데, 6에 대한 9의 보수는 3이고 2에 대한 10의 보수는 8이다.<br /></li>
  <li>보수 연산은 뺄셈을 할 때 9의 보수를 사용하는 방법과 1의 보수와 2의 보수를 사용하는 방법 등이 있다.<br /><br /><br /></li>
</ul>

<h2 id="4-정보-교환용-코드">4. 정보 교환용 코드<br /></h2>
<ul>
  <li>정보 교환용 코드는 국제표준화기구(ISO)에 의해 정해지고 이것에 준해서 각국에서 정하여 사용하고 있다. 컴퓨터 대 컴퓨터시스템간의 통신을 단순화하고 표준화하기 위해 만들어졌다. <br /></li>
  <li>대표적인 것으로 프로그래밍을 할 때 자주 쓰는 아스키(ASCII)코드가 있다.</li>
  <li>산업 표준으로 전세계 모든 문자들을 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 유니코드(Unicode)가 제정되어 사용되고 있다.<br /><br /><br /></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><summary type="html"><![CDATA[데이터의 표현과 연산]]></summary></entry><entry><title type="html">부울대수</title><link href="http://localhost:4000/computer%20science/CS06/" rel="alternate" type="text/html" title="부울대수" /><published>2022-01-30T00:00:00+09:00</published><updated>2022-01-30T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/CS06</id><content type="html" xml:base="http://localhost:4000/computer%20science/CS06/"><![CDATA[<h1 id="부울대수">부울대수<br /></h1>

<h2 id="1-부울대수의-개요">1. 부울대수의 개요<br /></h2>
<ul>
  <li>부울대수(Boolean algebra)는 논리적 관계의 문제를 다룰 때 대수 형식으로 표시하며, 여러가지 논리회로를 설계하거나 같은 기능을 갖는 논리 회로를 간략화하는 데 사용된다.</li>
  <li>인간의 지식이나 사고를 참, 거짓으로 공식화하고 이를 수학적으로 해석하기 위한 것으로 논리대수라고도 한다.<br /></li>
  <li>주로 컴퓨터의 회로 설계 등에 이용되고 있으며 “0”과 “1”의 두 개의 수치만을 사용하여, 연산의 결과는 언제나 0 또는 1로 표한된다.<br /><br /><br /></li>
</ul>

<h2 id="2-논리회로">2. 논리회로<br /></h2>
<ul>
  <li>논리회로는 2가지 상태를 다루는 방법으로 컴퓨터에서 사용되는 방법이다. NOT, AND, OR 3가지의 기본논리회로의 조합으로 구성된다. <br /><br /></li>
</ul>

<p>1) NOT 회로<br /></p>
<ul>
  <li>인버터(inverter)라고도 한다. 입력이 1개로 구성된 것으로 입력신호와 반대되는 출력을 내놓는다.<br /></li>
  <li>입력신호가 1이면 출력은 0, 입력신호가 0이면 출력은 1<br /><br /></li>
</ul>

<p>2) AND 게이트<br /></p>
<ul>
  <li>두 입력이 모두 1일 때 출력이 1이 되고 그 외에는 모두 0이 출력된다.<br /><br /></li>
</ul>

<p>3) OR 게이트<br /></p>
<ul>
  <li>입력신호 중 어느 하나 또는 두 개가 모두 1일 때 1이 출력된다.<br /><br /></li>
</ul>

<p>4) 부정논리곱<br /></p>
<ul>
  <li>AND와 NOT 회로를 결합한 것으로 AND의 결과를 반전한 결과를 얻는다.<br /></li>
  <li>두 입력이 모두 1일 때에만 0을 출력하고 나머지는 모두 1 출력<br /><br /></li>
</ul>

<p>5) 부정논리합<br /></p>
<ul>
  <li>OR와 NOT 회로를 결합한 것으로 OR의 출력이 반전된 결과를 얻는다. <br /></li>
  <li>두 입력이 모두 0이면 1을 출력하고 나머지는 모두 0 출력<br /><br /></li>
</ul>

<p>6) 베타논리합(XOR : exclusive-OR)<br /></p>
<ul>
  <li>두 개의 입력조건이 서로 다르면 1이고, 조건이 같으면 0이 된다.<br /><br /></li>
</ul>

<h2 id="3-조합-논리-회로">3. 조합 논리 회로<br /></h2>
<ul>
  <li>입력 논리치가 정해지면 출력 논리치가 결정되는 논리회로, AND, OR, XOR 등의 논리가 해당된다.<br /><br /></li>
</ul>

<p>1) 반 가산기(half adder)<br /></p>
<ul>
  <li>1비트의 2진수 2개를 합하여 그 결과를 한 비트의 합과 한 비트의 올림수로 발생시키는 논리회로<br /><br /></li>
</ul>

<p>2) 전 가산기(full adder)<br /></p>
<ul>
  <li>반 가산기는 자리 올림수를 더해줄 수 없기 때문에 이것을 보완하여 만든 회로<br /></li>
  <li>두 개의 입력과 전 단계에서 발생한 자리 올림수를 더할 수 있도록 구성된 회로<br /></li>
  <li>여러 자리의 2진수 덧셈을 위해서는 첫 자리의 덧셈은 반 가산기를 이용하고, 다음 단계부터는 자리 올림수를 더해줘야 하기 때문에 전 가산기를 사용한다.<br /><br /></li>
</ul>

<p>3) 인코더(encoder)<br /></p>
<ul>
  <li>1게의 입력을 다수의 신호로 변환하여 출력을 얻는 회로로 부호기라고도 한다.<br /></li>
  <li>0, 1, 2, … 와 같은 하나의 십진수를 4개의 비트를 이용한 2진수 코드로 변환할 때 사용할 수 있다.<br /><br /></li>
</ul>

<p>4) 디코더(decoder)<br /></p>
<ul>
  <li>인코더와 반대로 다수의 입력신호로서 1개의 출력신호를 얻는 회로이다.<br /></li>
  <li>2진수 코드의 정보를 다른 부호로 바꾸어야 할 때 사용하는 회로로 해독기라고도 한다.<br /><br /></li>
</ul>

<p>5) 멀티플렉서(multiplexer)<br /></p>
<ul>
  <li>n개의 선택입력에 따라 2^n 개의 입력 중 하나를 선택하여 출력하는 회로로 다중기라고도 한다.<br /></li>
  <li>데이터통신 장치에 많이 사용된다.<br /><br /><br /></li>
</ul>

<h1 id="4-순서-논리-회로">4. 순서 논리 회로<br /></h1>
<ul>
  <li>조합 논리 회로가 입력신호의 조합에 따라 출력값이 결정되었다면 순서 논리 회로는 입력신호의 조합뿐만 아니라 논리회로의 내부 상태에 따라 다르게 출력이 나타난다. <br /></li>
  <li>입력 신호에 의하여 상태를 바꾸도록 지시할 때까지 계속적으로 컴퓨터 내부에서 0, 1의 값을 가지는 bit을 기억하고 유지하기 위하여 사용된다.<br /></li>
  <li>이런 소자를 플립플롭(Flip-Flop)이라 하며, 정보를 기억하는 레지스터 및 카운터 등의 구성소자에서 사용된다.<br /></li>
</ul>

<h2 id="레지스터register">@레지스터(register)<br /></h2>
<ul>
  <li>CPU의 연산장치와 기억장치 중에서 기억장치에서 읽어내는 정보와 연산결과 등을 일시 기억하는 데 사용된다.<br /></li>
  <li>1개의 플립플롭은 1비트의 정보가 기억되기 때문에 n개의 플립플롭을 사용하면 n비트의 정보를 기억하는 레지스터가 된다.<br /><br /></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><summary type="html"><![CDATA[부울대수]]></summary></entry><entry><title type="html">컴퓨터 하드웨어 구성</title><link href="http://localhost:4000/computer%20science/CS07/" rel="alternate" type="text/html" title="컴퓨터 하드웨어 구성" /><published>2022-01-30T00:00:00+09:00</published><updated>2022-01-30T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/CS07</id><content type="html" xml:base="http://localhost:4000/computer%20science/CS07/"><![CDATA[<h1 id="컴퓨터-하드웨어-구성">컴퓨터 하드웨어 구성<br /></h1>
<ul>
  <li>컴퓨터 시스템은 크게 하드웨어(hardware)와 소프트웨어(software)로 이루어져 있다.<br /></li>
  <li>하드웨어는 눈으로 볼 수 있는 기계의 본체로 중앙처리장치(CPU), 보조기억장치, 입출력장치로 구성되어 있다.<br /></li>
  <li>중앙처리장치는 주기억장치, 연산장치, 제어장치로 나눌 수 있다.<br /></li>
  <li>소프트웨어는 컴퓨터를 이용하는 기술을 말하는 것으로 시스템 프로그램과 응용 프로그램으로 분류된다.<br /><br /></li>
</ul>

<h2 id="컴퓨터-하드웨어의-구성">컴퓨터 하드웨어의 구성<br /></h2>
<h3 id="1-입력-장치">1) 입력 장치<br /></h3>
<ul>
  <li>자료를 컴퓨터에 읽어 들이는 기능을 가지고 있다.<br /></li>
  <li>디스크 장치, 테이프 장치, 단말기, 카드 판독기 등이 있다.<br /><br /></li>
</ul>

<h3 id="2-기억-장치">2) 기억 장치<br /></h3>
<ul>
  <li>주기억 장치와 보조 기억 장치로 나누며, 입력된 자료가 처리될 때까지 일시적으로 기억하거나 연산 결과와 출력할 내용 등을 기억한다.<br /><br /></li>
</ul>

<h3 id="3-연산-장치">3) 연산 장치<br /></h3>
<ul>
  <li>산술 논리 연산 장치(ALU : Arithmetic and Logic Unit)라고도 한다.<br /></li>
  <li>제어 장치의 지시에 따라 전송된 자료를 처리하기 위하여 사칙 연산, 논리 연산, 자리 이동 등의 연산을 수행하는 장치이다.<br /><br /></li>
</ul>

<h3 id="4-제어-장치">4) 제어 장치<br /></h3>
<ul>
  <li>자료를 처리하는 순서를 저장한 프로그램의 명령어를 해독하여 입력 장치, 기억 장치, 연산 장치, 출력 장치 등을 제어한다.<br /><br /></li>
</ul>

<h3 id="5-출력-장치">5) 출력 장치<br /></h3>
<ul>
  <li>CPU로부터 출력 결과를 받아서 사람이 알 수 있는 형태로 변환하거나 다른 기억 장치(자기 테이프, 자기 디스크 장치 등)로 전송한다.<br /></li>
</ul>

<table>
  <thead>
    <tr>
      <th>중앙 처리 장치(CPU)</th>
      <th>주변 장치</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>제어 장치</td>
      <td>보조 기억 장치</td>
    </tr>
    <tr>
      <td>주기억 장치</td>
      <td>입력 장치</td>
    </tr>
    <tr>
      <td>연산 장치</td>
      <td>출력 장치</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><summary type="html"><![CDATA[컴퓨터 하드웨어 구성 컴퓨터 시스템은 크게 하드웨어(hardware)와 소프트웨어(software)로 이루어져 있다. 하드웨어는 눈으로 볼 수 있는 기계의 본체로 중앙처리장치(CPU), 보조기억장치, 입출력장치로 구성되어 있다. 중앙처리장치는 주기억장치, 연산장치, 제어장치로 나눌 수 있다. 소프트웨어는 컴퓨터를 이용하는 기술을 말하는 것으로 시스템 프로그램과 응용 프로그램으로 분류된다.]]></summary></entry><entry><title type="html">컴퓨터 하드웨어 기억장치</title><link href="http://localhost:4000/computer%20science/CS08/" rel="alternate" type="text/html" title="컴퓨터 하드웨어 기억장치" /><published>2022-01-30T00:00:00+09:00</published><updated>2022-01-30T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/CS08</id><content type="html" xml:base="http://localhost:4000/computer%20science/CS08/"><![CDATA[<h1 id="컴퓨터-하드웨어-기억장치">컴퓨터 하드웨어 기억장치<br /></h1>

<h2 id="기억-장치">기억 장치<br /></h2>
<ul>
  <li>입력 장치에서 읽어 들인 숫자, 문자, 각종 기호 등의 자료들을 저장하는 장치로 주기억 장치와 보조 기억 장치로 나누어진다.<br /><br /></li>
</ul>

<h3 id="1-주기억-장치main-memory-unit">1) 주기억 장치(main memory unit)<br /></h3>
<ul>
  <li>컴퓨터 중앙 처리 장치(CPU)에 위치하며 실행하고자 하는 프로그램이나 자료를 기억시키는 장치<br /><br /></li>
</ul>

<h3 id="2-보조-기억-장치auxiliary-storage-unit">2) 보조 기억 장치(auxiliary storage unit)<br /></h3>
<ul>
  <li>주변 장치로서(CPU에 속하지 않음!) 주기억 장치에 필요한 프로그램이나 자료를 보낼 수 있고, 처리된 자료 또는 개발된 프로그램 등을 저장할 수 있다.<br /><br /></li>
</ul>

<h3 id="3-기억-장치에서-사용되는-단위">3) 기억 장치에서 사용되는 단위<br /></h3>
<ul>
  <li>최소 단위는 비트(bit : binary digit)이다. <br /></li>
  <li>8개의 비트가 모이면 1바이트가 된다.<br /></li>
  <li>1바이트는 영문자 1개를 기억하며 한글 1문자를 저장하는 데엔 2바이트가 필요하다.<br /></li>
  <li>
    <p>1킬로 바이트(KB)는 1,024바이트로 구성되며, 1메가 바이트(MB)는 1,024킬로 바이트이고, 1기가 바이트(GB)는 1,024메가 바이트가 된다.<br /><br /></p>
  </li>
  <li>메모리 셀(memory cell)<br />
    <ul>
      <li><u>**한 소자나 전기회로가 하나의 비트를 저장**</u>하는 데 사용된다.<br /></li>
      <li>(0 또는 1) 플립플롭, 충전된 커패시터, 자기테이프 또는 디스크 등을 예로 들 수 있다.<br /><br /></li>
    </ul>
  </li>
  <li>메모리 워드(memory word)<br />
    <ul>
      <li>메모리에 있는 비트는 몇 가지 형태의 명령이나 데이터로 표현된다.<br /></li>
      <li>예를 들면, 8개의 플립플롭으로 구성된 레지스터는 8비트 워드로 저장되는 메모리로 생각할 수 있다.<br /></li>
      <li>워드의 용량은 보통 4~8바이트 사이이다.<br /><br /></li>
    </ul>
  </li>
  <li>바이트(byte)<br />
    <ul>
      <li>8비트 워드에 대해 사용되는 용어이다.<br /></li>
      <li>항상 8비트로 구성된다.<br /></li>
      <li>마이크로컴퓨터에서 가장 일반적인 워드 크기이다.<br /><br /></li>
    </ul>
  </li>
  <li>용량(capacity)<br />
    <ul>
      <li>비트들을 저장할 수 있는 공간<br /></li>
      <li>메모리에 있어 워드수는 대개 1024의 곱이다.<br /></li>
      <li>우리가 흔히 보는 하드 용량 몇 GB는 2^10(1,024), 2^20(1,048), … 와 같이 딱 나눠 떨어지는 10의 배수가 아닌 2의 거듭제곱들이다.<br /><br /></li>
    </ul>
  </li>
</ul>

<h2 id="주기억-장치">주기억 장치<br /></h2>
<h3 id="1-주기억-장치의-구성">1) 주기억 장치의 구성<br /></h3>
<ul>
  <li>주기억 장치는 수많은 바이트로 구성된다.</li>
  <li>입력 장치를 통하여 읽어 들은 자료는 1과 0의 상태가 모아져 바이트 단위로 구성되며 순서에 따라 특정한 장소에 저장된다.<br /></li>
  <li>
    <p>자료를 저장하거나 저장된 자료를 읽기 위하여 각 기억 장소는 고유한 주소를 갖는다.<br />
<img src="../../assets/images/main_memory_unit.jpeg" alt="main_memory_unit" /><br /></p>
  </li>
  <li>기억부<br />
    <ul>
      <li>주어진 프로그램이나 데이터를 기억해 두는 2진 기억 소자(memory cell)들이 2차원 행렬(matrix)로 구성되어 있다.<br /><br /></li>
    </ul>
  </li>
  <li>메모리 주소 레지스터(MAR : Memory Address Register)<br />
    <ul>
      <li>프로그램이나 데이터를 입출력하기 위한 번지를 가지고 있다.<br /><br /></li>
    </ul>
  </li>
  <li>메모리 버퍼 레지스터(MBR : Memory Buffer Register)<br />
    <ul>
      <li>입출력하고자 하는 프로그램이나 데이터를 임시 보관하는 레지스터<br /><br /></li>
    </ul>
  </li>
  <li>번지 선택 회로<br />
    <ul>
      <li>MAR(메모리 주소 레지스터)에 의하여 기억 장소를 선택하는 회로<br /><br /></li>
    </ul>
  </li>
  <li>제어 회로<br />
    <ul>
      <li>기억 장치에 저장하라는 Write 신호와 기억 장치로부터 읽어내리는 Read 신호를 발생시키는 회로<br /></li>
      <li>칩이나 모듈 개념으로 여러개로 나누어 구성될 경우 칩 선택 신호나 메모리 모듈 선택 신호가 필요하다.<br /><br /></li>
    </ul>
  </li>
</ul>

<h3 id="2-기억-장치에-저장하는-외부-동작의-순서">2) 기억 장치에 저장하는 외부 동작의 순서<br /></h3>
<ol>
  <li>기억 장치의 위치(번지)를 MAR(메모리 주소 레지스터)에 넣는다.<br /></li>
  <li>프로그램이나 데이터의 비트를 MBR(메모리 버퍼 레지스터)에 넣는다.<br /></li>
  <li>입력 신호로 MBR(메모리 버퍼 레지스터)의 내용이 메모리에 저장된다.<br /><br /></li>
</ol>

<h3 id="3-기억-장치로부터-읽어낼-때-외부-동작-순서">3) 기억 장치로부터 읽어낼 때 외부 동작 순서<br /></h3>
<ol>
  <li>읽어내려는 프로그램이나 데이터 번지를 MAR에 넣은 후 출력신호를 준다.<br /></li>
  <li>메모리의 해당 내용이 MBR로 옮겨져 외부로 출력하게 된다.<br /><br /></li>
</ol>

<h3 id="4-어드레스address">4) 어드레스(Address)<br /></h3>
<ul>
  <li>메모리에서 한 워드의 위치를 식별하는 주소(숫자)<br /></li>
  <li>메모리소자 또는 시스템에 저장된 각 워드는 고유의 주소를 갖는다.<br /></li>
  <li>주소는 보통 2진수, 8진수, 16진수로 표현되고, 편의를 위해 10진수로 표현되기도 한다.<br /></li>
  <li>메모리에 있는 특정 워드의 위치를 언급할 때마다 그것을 식별하기 위해서 그 위치의 주소코드를 사용한다.<br /></li>
</ul>

<h1 id="모든-프로그램은-주기억-장치에서만-실행된다">!모든 프로그램은 주기억 장치에서만 실행된다!</h1>
<ul>
  <li>그래서 주기억 장치(RAM)의 용량이 클수록 더 많은 정보를 기억하고 실행할 수 있기 때문에 비싸다.<br /><br /><br /></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><summary type="html"><![CDATA[컴퓨터 하드웨어 기억장치]]></summary></entry><entry><title type="html">컴퓨터 하드웨어 주기억 장치의 종류</title><link href="http://localhost:4000/computer%20science/CS09/" rel="alternate" type="text/html" title="컴퓨터 하드웨어 주기억 장치의 종류" /><published>2022-01-30T00:00:00+09:00</published><updated>2022-01-30T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/CS09</id><content type="html" xml:base="http://localhost:4000/computer%20science/CS09/"><![CDATA[<h1 id="주기억-장치의-종류">주기억 장치의 종류<br /></h1>
<ul>
  <li>컴퓨터 하드웨어 기술의 발전은 기억 용량의 급속한 증가와 함께 기억 소자 크기의 감소, 그리고 가격면에서 급격한 하락을 가져왔다.<br /><br /></li>
</ul>

<h2 id="1-과거의-주기억-장치">1. 과거의 주기억 장치</h2>
<ul>
  <li>초기</li>
  <li>
    <p>처음엔 진공관을 사용했다. 진공관 한 개는 1비트의 정보를 나타내는데, 그 크기와 전력 소모, 열 발생 등으로 문제점이 많았다. 이후 적은 전력 소모와 신뢰성을 가진 트랜지스터(transistor)가 사용된다.<br /><br /></p>
  </li>
  <li>1960년대 초반 ~ 1970년대 중반</li>
  <li>
    <p>자기 코어(magnetic core)가 기억 소자로 사용되었다. 매우 작은 링(ring) 형태로 되어 있으며, 페라이트(ferrite)라는 자기 재료를 사용해서 페라이트 코어 메모리라고도 한다.<br /><br /></p>
  </li>
  <li>기억 원리
    <ul>
      <li>코어의 링을 통과하는 도선에 전류를 흘려 ‘플레밍의 오른손 법칙’에 따라 <strong>자화</strong>의 방향을 바꾸어 준다.</li>
      <li>자기 코어는 한 번 1 또는 0의 상태가 되면 어떠한 변화를 주지 않는 한 계속 자화 상태를 유지하여 정보를 기억하게 되고, 여러 개의 코어를 코어판(core plane)의 형태로 묶어서 사용하게 된다.<br /><br /></li>
    </ul>
  </li>
  <li>자화(magnetization)
    <ul>
      <li>물질을 자기장 속에 놓았을 때 그 물질 전체가 갖는 거시적인 자기(磁氣)모멘트</li>
      <li>물질의 자기적 성질은 주로 전자의 자기모멘트에 연유하는데, 전자가 가진 극히 작은 미시적인 자기모멘트가 많이 모여, 그 총합으로 거시적으로 물질이 나타내는 자기모멘트를 <strong>자화</strong>라고 한다.<br /><br /></li>
    </ul>
  </li>
  <li>플레밍의 오른손 법칙<br /><br />
<img src="../../assets/images/rightHand.png" alt="rightHand" /><br />
    <ul>
      <li>N극에서 S극 방향으로 자기장이 형성되었을 때 그림처럼 자기장의 방향과 수직으로 도체(금속 막대 등)가 움직이고 있다면 전류는 가운데 손가락 방향으로 흐른다.</li>
      <li>엄지손가락 방향 : 도체를 움직이는 힘(속도)의 방향</li>
      <li>두번째 손가락 방향 : 자기장의 방향</li>
      <li>가운데 손가락 방향 : 전류가 흐르는 방향</li>
    </ul>
  </li>
</ul>

<h2 id="2-현재의-주기억-장치">2. 현재의 주기억 장치</h2>
<ul>
  <li>1960년대 후반부터 반도체 집적 회로(IC : Integrated Circuit) 기술의 개발과 함께 기억 소자로의 적용이 추진된 후, 1968년에는 주기억 장치의 버퍼 메모리로 사용되기 시작했다.</li>
  <li>집적 회로는 집적도, 소비 전력, 소형성, 경제성 등으로 코어 메모리를 대체하여 널리 이용되고 있다.<br /><br /></li>
</ul>

<h2 id="3-미래의-주기억-장치">3. 미래의 주기억 장치</h2>
<ul>
  <li>현재보다 크기가 작고, 대용량, 고속의 기억 소자가 사용될 것이라 예상된다.</li>
  <li>그 중 하나가 조셉슨 소자(Josephson device)인데, 현재의 기억 소자보다 10배 이상 빠르게 나타나고 있으며 대량 생산과 가격 등의 문제점을 해결하고 있다.<br /></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><summary type="html"><![CDATA[주기억 장치의 종류 컴퓨터 하드웨어 기술의 발전은 기억 용량의 급속한 증가와 함께 기억 소자 크기의 감소, 그리고 가격면에서 급격한 하락을 가져왔다. 1. 과거의 주기억 장치 초기 처음엔 진공관을 사용했다. 진공관 한 개는 1비트의 정보를 나타내는데, 그 크기와 전력 소모, 열 발생 등으로 문제점이 많았다. 이후 적은 전력 소모와 신뢰성을 가진 트랜지스터(transistor)가 사용된다. 1960년대 초반 ~ 1970년대 중반 자기 코어(magnetic core)가 기억 소자로 사용되었다. 매우 작은 링(ring) 형태로 되어 있으며, 페라이트(ferrite)라는 자기 재료를 사용해서 페라이트 코어 메모리라고도 한다.]]></summary></entry><entry><title type="html">컴퓨터 하드웨어 - 반도체 메모리</title><link href="http://localhost:4000/computer%20science/CS10/" rel="alternate" type="text/html" title="컴퓨터 하드웨어 - 반도체 메모리" /><published>2022-01-30T00:00:00+09:00</published><updated>2022-01-30T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/CS10</id><content type="html" xml:base="http://localhost:4000/computer%20science/CS10/"><![CDATA[<h1 id="반도체-메모리">반도체 메모리</h1>
<ul>
  <li>현재 주기억 장치로 사용되고 있는 반도체 메모리는 하나의 칩(chip)상에 수메가 비트를 저장할 수 있다. 반도체 제조공법상 쌍극성(bipolar type)과 모스형(mos type)의 두 가지로 구분된다.<br /><br /></li>
</ul>

<h2 id="메모리의-제조기술적인-분류에-따른-특성">메모리의 제조기술적인 분류에 따른 특성<br /></h2>
<p>1) 밀도(chip당 bit 용량)<br />
2) 속도<br />
3) 소비전력(bit당 mW)<br />
4) bit당 cost(반도체 제조가격 측면)<br />
5) Noise 면역성<br /><br /></p>

<h2 id="읽기동작read-operation과-쓰기동작">읽기동작(read operation)과 쓰기동작</h2>
<ul>
  <li>특별한 메모리위치(주소)에 저장되어 있는 2진 워드가 감지되어 다른 소자에 전달되는 동작</li>
  <li>만약 100번 주소에 있는 메모리에서 워드 4를 사용하려 한다면 주소 100번에서 읽기동작을 실행해야 한다.</li>
  <li>한 워드를 메모리부터 가져오기 때문에 패치(fetch)동작이라고도 한다.<br /><br /></li>
</ul>

<h2 id="접근-시간access-time">접근 시간(access time)</h2>
<ul>
  <li>기억 장치가 출력 신호를 받은 시간부터 데이터가 출력된 때까지의 시간</li>
  <li>자기 코어 기억 장치에서는 접근 시간과 복원 시간을 합해서 사이클(cycle) 시간이라 하며, IC 메모리에서는 사이클 시간이 접근 시간과 같다.</li>
  <li>메모리소자 동작속도의 측정치로 읽기동작하는 데 필요한 시간이라고도 할 수 있으며, 이는 주소입력 순간으로부터 메모리 내용의 출력순간까지의 시간이다.<br /><br /></li>
</ul>

<h2 id="랜덤-액세스메모리ram">랜덤 액세스메모리(RAM)</h2>
<ul>
  <li>한 메모리 워드의 실제 물리적 위치가 그 위치로부터 읽거나 쓰는 데 걸리는 시간이 얼마나 걸리는가에는 영향을 받지 않는 메모리이다. 즉 액세스시간이 메모리의 모든 주소에 대해서 같은 메모리이다.</li>
  <li>대부분의 반도체메모리와 코어메모리는 RAM이다.
    <ul>
      <li>사용 예 : CDP(컴팩트 디스크 플레이어)는 적당한 코드를 입력함으로써 어떤 한 노래를 선택하든간에 같은 시간을 갖는다.<br /><br /><br /></li>
    </ul>
  </li>
</ul>

<h1 id="순차-액세스-메모리sam">순차 액세스 메모리(SAM)</h1>
<ul>
  <li>액세스시간이 일정하지 않고 주소위치에 따라 변하는 메모리의 한 형태이다.</li>
  <li>원하는 주소에 도달할 때까지 모든 주소위치를 통하여 저장된 워드를 순차적으로 찾기 때문에 랜덤 액세스메모리보다 더 긴 액세스시간을 갖는다.
    <ul>
      <li>사용 예 : 자기테이프, 디스크, 자기버블메모리<br /><br /></li>
    </ul>
  </li>
</ul>

<h2 id="읽기전용메모리rom">읽기전용메모리(ROM)</h2>
<ul>
  <li>읽기동작이 쓰기동작보다 매우 많은 응용분야를 위해 설계된 반도체메모리의 종류</li>
  <li>기술적으로 (주로 제작자에 의해)단 한 번만 프로그래밍되어 쓸 수 있으며, 이후로는 내용을 수정할 수 없으며 읽기만 가능하다.</li>
  <li>모든 ROM은 비휘발성이며 전원이 제거되어도 데이터는 그대로 저장된다.</li>
  <li>한 번 이상 쓰기동작을 할 수 있는 메모리 RMM(Read Mostly Memory)도 있는데 읽기동작보다 쓰기동작이 훨씬 복잡하기 때문에 자주 사용되지는 않는다.<br /><br />
<img src="../../assets/images/rom.png" alt="rom" /><br />
    <blockquote>
      <p>ROM의 구성도<br /></p>
    </blockquote>
  </li>
  <li>ROM은 읽어내기만 하기 때문에 기억부와 번지 해독기, 출력 버퍼만으로 구성된다.<br /><br /></li>
</ul>

<h3 id="프로그램이나-자료-저장-방법에-따른-rom-분류">프로그램이나 자료 저장 방법에 따른 ROM 분류</h3>
<ul>
  <li>마스크(Mask) ROM : 사용자의 요구에 따라 제작사가 자료를 넣기 때문에 내용을 바꿀 수는 없지만 대량 생산에 적합</li>
  <li>PROM(Programmable ROM) : 제작시에 아무런 내용을 넣지 않은 상태로 만들어져서 사용자가 원하는 내용을 저장할 수 있다. 하지만 한 번 기억되면 그 내용을 변경할 수 없다.</li>
  <li>EPROM(Erasable ROM) : ROM의 내용을 자외선 삭제 장치로 지울 수 있다. 지운 후에 새로운 내용을 써 넣는 것도 가능</li>
  <li>EEPROM(Electrically Erasable PROM) : ROM의 내용을 전기신호로 지울 수 있다. 지운 후에 새로운 내용을 써 넣는 것도 가능<br /><br /></li>
</ul>

<h2 id="정적-램static-ram-device-sram">정적 램(static RAM device, SRAM)</h2>
<ul>
  <li>전원이 인가되는 동안은 저장된 데이터가 영원히 저장되고, 주기적으로 데이터를 다시 쓸 필요가 없는 반도체 메모리장치</li>
  <li>플립플롭 조합으로 구성되어 있다.<br /><br /></li>
</ul>

<h2 id="동적-램dynamic-ram-device-dram">동적 램(dynamic RAM device, DRAM)</h2>
<ul>
  <li>전원이 인가되어도 저장된 데이터가 영원히 유지되지 못하며, 데이터가 메모리에 주기적으로 다시 쓰여져야 저장된 데이터가 계속 저장되는 반도체메모리</li>
  <li>이러한 주기적 동작을 리플레시(refresh)동작이라 한다.<br /><br /></li>
</ul>

<h2 id="휘발성-메모리volatile-memory">휘발성 메모리(volatile memory)</h2>
<ul>
  <li>전원이 제거되면 메모리에 있는 모든 정보가 소실된다.</li>
  <li>반도체메모리가 휘발성 메모리에 해당한다.<br /><br /></li>
</ul>

<h2 id="캐시-메모리cache-memory">캐시 메모리(cache memory)</h2>
<ul>
  <li>SRAM과 구성이 동일하다.</li>
  <li>기억 용량은 작으나 속도가 매우 빠른 버퍼(buffer) 메모리로 주기억 장치와 CPU와의 속도 차이를 줄여서 처리의 효율을 높이기 위해서 사용된다.</li>
  <li>캐시 기억 장치의 호출 시간은 주기억 장치의 호출 시간보다 5~10배 정도 빠르다.</li>
  <li>전체 기억 장치 시스템의 총 소요 시간을 최소화하면서 가능한 하 높은 평균 액세스 속도를 얻기 위해서 사용한다.<br /><br /><br /></li>
</ul>

<h1 id="메모리의-연결">메모리의 연결</h1>
<ul>
  <li>컴퓨터 내부메모리는 어드레스(Address) 버스, 데이터(Data) 버스, 제어(Control) 버스라는 세 종류의 버스로 CPU에 연결되는 신호선이 구성된다.<br /><br /></li>
</ul>

<h2 id="버스">버스<br /></h2>
<p>1) 어드레스 버스 : CPU에서 메모리 IC까지 2진 어드레스 출력을 전달하는 단방향 버스<br />
2) 데이터 버스 : CPU와 메모리 IC 사이에 데이터를 옮기는 양방향 버스<br />
3) 제어 버스 : CPU에서 메모리 IC까지 제어신호들 전달<br /><br /></p>

<h2 id="cpu의-쓰기동작-순서">CPU의 쓰기동작 순서<br /></h2>
<p>1) CPU가 데이터가 저장될 메모리 위치에 2진 어드레스 공급. 어드레스 버스선에서 이 어드레스를 인가한다.<br />
2) CPU가 데이터 버스선에 저장될 데이터 인가<br />
3) CPU가 메모리 쓰기 동작을 위해 제어신호선 동작시킴<br />
4) 메모리 IC들은 저장될 위치를 선택하기 위해 2진 어드레스 해독<br />
5) 데이터 버스에 있는 데이터가 선택된 메모리 위치로 전송됨<br /><br /></p>

<h2 id="cpu의-읽기동작-순서">CPU의 읽기동작 순서<br /></h2>
<p>1) 어드레스 버스선에 이 어드레스 인가. CPU가 데이터의 메모리 위치의 2진 어드레스 공급<br />
2) CPU가 메모리 읽기동작을 위해 제어신호선 활성화 시킴<br />
3) 메모리 IC중에서 읽기동작이 실행되는 위치를 선택하기 위해, 2진 어드레스를 해독한다.<br />
4) 메모리 IC들은 선택된 메모리 위치로부터 데이터 버스에 데이터 인가. 데이터가 전송되는 곳으로부터 CPU로 데이터 인가<br /><br /></p>

<h1 id="메모리-맵memory-map">메모리 맵(Memory Map)</h1>
<ul>
  <li>원하는 용량 및 워드사이즈에 알맞게 응용하기 위해 메모리칩을 조합하거나 큰 용량을 나누어 쓰는 것<br /><br /><br /></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><summary type="html"><![CDATA[반도체 메모리 현재 주기억 장치로 사용되고 있는 반도체 메모리는 하나의 칩(chip)상에 수메가 비트를 저장할 수 있다. 반도체 제조공법상 쌍극성(bipolar type)과 모스형(mos type)의 두 가지로 구분된다.]]></summary></entry><entry><title type="html">컴퓨터 하드웨어 - 보조 기억 장치</title><link href="http://localhost:4000/computer%20science/CS11/" rel="alternate" type="text/html" title="컴퓨터 하드웨어 - 보조 기억 장치" /><published>2022-01-30T00:00:00+09:00</published><updated>2022-01-30T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/CS11</id><content type="html" xml:base="http://localhost:4000/computer%20science/CS11/"><![CDATA[<h1 id="보조-기억-장치">보조 기억 장치</h1>
<ul>
  <li>주기억 장치는 적은 자료를 기억하여 고속으로 처리한다.</li>
  <li><u>**그에 반해 많은 양의 자료를 기억시켜 관리하기 위한 장치**</u>를 보조 기억 장치 또는 2차 기억 장치(secondary memory)라 한다.</li>
  <li>보조 기억 장치의 자료를 액세스하는 방법에 따라 <u>**순차 액세스**</u>와 <u>**임의 액세스**</u>로 분류할 수 있다.<br /><br /></li>
</ul>

<h2 id="순차-액세스sequential-access">순차 액세스(sequential access)</h2>
<ul>
  <li>물리적으로 저장된 순서에 따라 자료를 검색해 나가기 때문에 일괄 처리(batch processiong)에 적합하다.</li>
  <li>그렇기 때문에 빠른 액세스가 요구되는 실시간 처리에는 잘 사용되지 않는다.
    <ul>
      <li>사용 예 : 자기 테이프<br /><br /></li>
    </ul>
  </li>
</ul>

<h2 id="임의-액세스random-access">임의 액세스(random access)</h2>
<ul>
  <li>원하는 레코드에 직접 액세스할 수 있는 방식</li>
  <li>레코드를 순차적으로 읽지 않기 때문에 원하는 데이터를 빠르게 검색할 수 있다.</li>
  <li>주로 실시간 처리 시스템에서 사용된다.
    <ul>
      <li>사용 예 : 자기 디스크<br /><br /><br /></li>
    </ul>
  </li>
</ul>

<h1 id="보조-기억-장치의-종류">보조 기억 장치의 종류</h1>
<h2 id="자기-테이프magnetic-tape">자기 테이프(magnetic tape)</h2>
<ul>
  <li>플라스틱 테이프의 표면에 자성 도료를 입혀 제작된 것<br /><br /></li>
</ul>

<p>1) 특성<br /></p>
<ul>
  <li>녹음 테이프와 비슷하게 생겼는데 폭이 1/2~3/4인지 정도로 넓고 기록 밀도가 높다.<br />
<img src="../../assets/images/magneticTape.jpeg" alt="magneticTape" /><br /><br /></li>
  <li>대량의 자료를 반영구적으로 보관할 수 있고 가격이 저렴하다는 장점을 가지고 있다.</li>
  <li>하지만 테이프가 릴에 순차적으로 감겨 있기 때문에 자료의 순차적 처리만 가능하다.<br /><br /></li>
</ul>

<p>2) 기록 밀도<br /></p>
<ul>
  <li>자기 테이프 1릴(reel)의 길이는 보통 800, 1,200, 1,600, 2,400 피트(feet) 등이며, 테이프의 기록 밀도는 테이프 1인치 당 저장될 수 있는 문자(character)의 수 혹은 바이트(byte)의 수로 계산 되고 있다.</li>
  <li>이 기록 밀도의 단위를 BPI(Byte Per Inch)라고 하며 800, 1,600, 3,200, 6,250, 20,000BPI 등의 기록 밀도가 있다.</li>
  <li>자기 테이프는 최초로부터 4~5m 지점에 BOT(Beginning of Tape) 마커가 있고 끝의 6~7m 앞지점에 EOT(End of Tape) 마커가 있는데, 이 부분에는 자료를 수록할 수 없다.</li>
  <li>자기 테이프는 7개 또는 9개의 트랙(track)으로 구성되어 데이터를 표현한다.</li>
  <li>자료의 저장은 ASCII 코드나 EBCDIC 코드로 표현된다.</li>
  <li>파일의 갱신과 보수를 쉽게 하기 위하여 레이블을 사용하는데 레이블에는 표준 레이블, 비표준 레이블, 레이블이 없는 것 세 가지 종류가 있다.<br /><br /></li>
</ul>

<p>3) 저장 방법<br /></p>
<ul>
  <li>레코드는 자기 테이프에 순차적으로 기록되고 읽혀진다.</li>
  <li>이 때 테이프가 레코드를 읽거나 기록하는 과정에서 테이프를 출발시키거나 멈추게 하는데는 물리적인 가속 및 감속 구간이 필요한데, 이를 IRG(Inter Record Gap)로 나타낸다.</li>
  <li>IRG의 길이는 약 0.3~0.75인치로 각 레코드마다 IRG를 두게 되면 그만큼 저장할 수 있는 공간이 줄어들기 때문에 비효율적이다.</li>
  <li>따라서 효율성을 위해 몇 개의 레코드를 묶어서 한 개의 물리적 레코드로 만들어 준다.</li>
  <li>이것을 블록화라고 하며 하나의 블록에 포함된 논리 레코드의 수를 블록화 인수, 각 블록 사이의 간격을 IBG(Inter Block Gap)라 한다.<br /><br /></li>
</ul>

<p>4) 자기 테이프의 레코드 형식<br /></p>
<ul>
  <li>고정 길이 비블록 레코드(fixed unblock record)
    <ul>
      <li>블록화되지 않은 고정 길이 레코드</li>
      <li>물리 레코드와 논리 레코드의 길이가 같다.</li>
    </ul>
  </li>
  <li>고정 길이 블록 레코드(fixed block record)
    <ul>
      <li>블록화된 고정 길이 레코드</li>
      <li>레코드의 길이가 일정하며 하나의 물리 레코드 내에 2개 이상의 논리 레코드가 존재한다.</li>
    </ul>
  </li>
  <li>가변 길이 비블록 레코드(variable unblock record)
    <ul>
      <li>블록화되지 않은 가변 길이 레코드</li>
      <li>각 논리 레코드의 길이가 일정하지 않다.</li>
    </ul>
  </li>
  <li>가변 길이 블록 레코드(variable block record)
    <ul>
      <li>블록화된 가변 길이 레코드</li>
      <li>길이가 일정하지 않은 논리 레코드가 블록화되어 있는 형식이다.</li>
    </ul>
  </li>
  <li>부정 형식 레코드(undefined record)
    <ul>
      <li>길이를 나타내는 필드가 없는 가변 길이 레코드</li>
      <li>비블록 레코드이다.<br /><br /></li>
    </ul>
  </li>
</ul>

<h2 id="자기-디스크-장치">자기 디스크 장치<br /></h2>
<p><img src="../../assets/images/magneticDisk.jpeg" alt="magneticDisk" /><br /></p>
<ul>
  <li>대용량을 저장할 수 있고 임의로 호출이 가능하기 때문에 은행 업무, 좌석 예약 업무 등 실시간 처리가 요구되는 자료 처리에 효율적이다.</li>
  <li>처리 속도는 1,200 ~ 3,600 회전/분이며, 기록 밀도는 한 트랙당 3,000 ~ 13,000바이트, 즉 60만 ~ 520만 바이트가 수록된다.</li>
  <li>자기 디스크 장치는 여러 디스크가 하나의 축에 연결되어 있는데 이것을 디스크 팩(pack)이라 한다.</li>
  <li>그리고 각 면의 트랙을 수직으로 연결한 트랙군을 실린더(cylinder)라 한다.</li>
  <li>트랙과 실린더에는 고유 번호인 트랙 번호와 실린더 번호가 있어서 기억 매체상의 주소(address)가 할당되어 있기 때문에 데이터에 직접 액세스 하는 것이 가능하다.<br /><br /></li>
</ul>

<h2 id="자기-드럼-장치magnetic-drum">자기 드럼 장치(magnetic drum)<br /></h2>
<p><img src="../../assets/images/magneticDrum.jpeg" alt="magneticDrum" /><br /></p>
<ul>
  <li>초기에 사용되던 주기억 장치</li>
  <li>새로운 기억 장치가 개발되면서 보조 기억 장치로 사용되기 시작했지만 현재는 그마저도 잘 안 쓴다.</li>
  <li>직경 20~30cm인 금속 원통의 표면에 자성 물질을 입힌 드럼으로 드럼을 회전시킬 때 표면에 헤드를 접근시켜 기억된 내용을 읽거나 새로운 내용을 기억시킨다.<br /><br /></li>
</ul>

<h2 id="플로피-디스크-장치floppy-disk">플로피 디스크 장치(floppy disk)<br /></h2>
<p><img src="../../assets/images/floppyDisk.jpeg" alt="floppyDisk" /><br /></p>
<ul>
  <li>자기 디스크와 같이 데이터를 직접 액세스하며 가볍고 취급이 간편한 반면, 먼지, 햇볕, 열 또는 자성 물질에 가까이 두지 않는 등 관리상 주의가 필요하다.</li>
  <li>기록 방법에 따라 단밀도, 배밀도, 고밀도 등이 있으며, 2D는 양면 배밀도를 뜻하고 2HD는 양면 고밀도를 뜻한다.<br /><br /></li>
</ul>

<h2 id="하드-디스크hard-disk">하드 디스크(hard disk)<br /></h2>
<p><img src="../../assets/images/hardDisk.jpeg" alt="hardDisk" /><br /></p>
<ul>
  <li>개인용 컴퓨터의 보조 기억 장치로 널리 사용되고 있다.</li>
  <li>동작 속도는 ms로 나타내며, 보통 평균 액세스 속도와 트랙간 이동 속도, 최대 이동 거리 속도 등을 표시한다.</li>
  <li>평균 속도가 빠를수록 전체적으로 동작이 빠르며 가격도 높아진다.</li>
  <li>하드 디스크는 본체에 내장되어 사용되는 것이 보통이나 기억 용량의 증가, 편의성 등으로 외장형 하드 디스크도 사용되고 있다.<br /><br /></li>
</ul>

<h2 id="광학-디스크optical-disk">광학 디스크(optical disk)<br /></h2>
<ul>
  <li>레이저를 이용해서 자료를 기록한다.</li>
  <li>레이저가 필요한 표면에 도착하면 표면을 태워서 비트 형태의 데이터를 저장한다.</li>
  <li>광학 디스크는 데이터가 잘 지워지지 않는 백업 파일, 역사적 기록 등의 분야에 이용된다.<br /><br /></li>
</ul>

<h3 id="광-디스크의-종류">광 디스크의 종류<br /></h3>
<h4 id="1-cd-romcompact-disk-read-only-memory">1) CD-ROM(Compact Disk-Read Only Memory)<br /></h4>
<p><img src="../../assets/images/cdrom.jpeg" alt="cdrom" /><br /></p>
<ul>
  <li>지름이 12cm인 소형 디스크 위에 정보를 기록, 저장 및 검색할 수 있는 형식의 시스템으로 광학 드라이브를 이용해서 읽을 수 있다.</li>
  <li>원본에 정보를 기록하기 위해서는 WORM 장치가 사용된다.</li>
  <li>오디오 디스크, 비디오 디스크, 각종 상품화된 소프트웨어의 저장에 이용된다.<br /><br /></li>
</ul>

<h4 id="2-wormwrite-once-read-memory">2) WORM(Write Once Read Memory)<br /></h4>
<ul>
  <li>디스크에 단 한 번만 정보를 기록할 수 있고 기록한 후에 지울 수 없고 판독만 할 수 있는데, 그 후에는 드라이브에 있는 데이터가 삭제되지 않도록 보호하는 데이터 저장기술이다.</li>
  <li>문서용 파일, 비디오용 파일 등에 이용된다.<br /><br /></li>
</ul>

<h4 id="3-mo-diskmagneto-optical-disk">3) MO DISK(Magneto Optical Disk)<br /></h4>
<p><img src="../../assets/images/magnetoOpticalDisk.jpeg" alt="magnetoOpticalDisk" /><br /></p>
<ul>
  <li>자기광학 디스크라고도 하며 자기박막의 광자기 효과를 이용하여 자료를 기록하고 읽어낼 수 있는 CD-ROM 형태의 외부 기억 매체</li>
  <li>자료를 기록할 때엔 레이저광을 사용하여 자화시키는데 이 자화가 유지되어 정보가 기록된다.</li>
  <li>판독시엔 피트(pit : 광자기 디스크 표면의 미세한 홈)에 반사되는 빛의 유무로 데이터를 판독한다.</li>
  <li>광자기 디스크는 3.5인치 디스켓보다는 빠르지만 하드 디스크보다는 느리다.</li>
  <li>광자기 디스크는 자료 백업용 기억매체로 사용하기 좋으며 이동이 간편하고 신뢰성이 높은 것이 장점이다.</li>
  <li>오디오용, 비디오용, 컴퓨터 데이터 파일 등에 이용된다.<br /><br /></li>
</ul>

<h4 id="4-dvd">4) DVD<br /></h4>
<ul>
  <li>CD에서 더 발전한 광학 디스크 기술을 이용하는 저장매체이다.</li>
  <li>외형은 CD와 같지만 다른 포맷으로 저장되며 높은 용량을 가지고 있다.</li>
  <li>DVD는 MPEG-2 파일과 압축 표준을 사용한다.</li>
  <li>MPEG-2 이미지들은 MPEG-1 이미지의 4배 해상도를 가지며, 2개의 필드가 하나의 이미지 프레임을 구성하는 상황에서 초당 60개의 인터레이스드 필드(Interlaced Field)를 전송할 수 있다. (MPEG-1은 초당 30개의 인터레이스되지 않은 프레임을 전송한다)<br /><br /></li>
</ul>

<p><img src="../../assets/images/memoryHierarchy.png" alt="memoryHierarchy" /><br /></p>
<blockquote>
  <p>메모리 계층 구조<br /></p>
</blockquote>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><summary type="html"><![CDATA[보조 기억 장치 주기억 장치는 적은 자료를 기억하여 고속으로 처리한다. **그에 반해 많은 양의 자료를 기억시켜 관리하기 위한 장치**를 보조 기억 장치 또는 2차 기억 장치(secondary memory)라 한다. 보조 기억 장치의 자료를 액세스하는 방법에 따라 **순차 액세스**와 **임의 액세스**로 분류할 수 있다.]]></summary></entry></feed>